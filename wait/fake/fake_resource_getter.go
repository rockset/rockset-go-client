// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"context"
	"sync"

	"github.com/rockset/rockset-go-client/openapi"
	"github.com/rockset/rockset-go-client/retry"
	"github.com/rockset/rockset-go-client/wait"
)

type FakeResourceGetter struct {
	GetAliasStub        func(context.Context, string, string) (openapi.Alias, error)
	getAliasMutex       sync.RWMutex
	getAliasArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	getAliasReturns struct {
		result1 openapi.Alias
		result2 error
	}
	getAliasReturnsOnCall map[int]struct {
		result1 openapi.Alias
		result2 error
	}
	GetCollectionStub        func(context.Context, string, string) (openapi.Collection, error)
	getCollectionMutex       sync.RWMutex
	getCollectionArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	getCollectionReturns struct {
		result1 openapi.Collection
		result2 error
	}
	getCollectionReturnsOnCall map[int]struct {
		result1 openapi.Collection
		result2 error
	}
	GetCollectionCommitStub        func(context.Context, string, string, []string) (openapi.GetCollectionCommitData, error)
	getCollectionCommitMutex       sync.RWMutex
	getCollectionCommitArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 []string
	}
	getCollectionCommitReturns struct {
		result1 openapi.GetCollectionCommitData
		result2 error
	}
	getCollectionCommitReturnsOnCall map[int]struct {
		result1 openapi.GetCollectionCommitData
		result2 error
	}
	GetCollectionMountStub        func(context.Context, string, string) (openapi.CollectionMount, error)
	getCollectionMountMutex       sync.RWMutex
	getCollectionMountArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	getCollectionMountReturns struct {
		result1 openapi.CollectionMount
		result2 error
	}
	getCollectionMountReturnsOnCall map[int]struct {
		result1 openapi.CollectionMount
		result2 error
	}
	GetIntegrationStub        func(context.Context, string) (openapi.Integration, error)
	getIntegrationMutex       sync.RWMutex
	getIntegrationArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getIntegrationReturns struct {
		result1 openapi.Integration
		result2 error
	}
	getIntegrationReturnsOnCall map[int]struct {
		result1 openapi.Integration
		result2 error
	}
	GetQueryInfoStub        func(context.Context, string) (openapi.QueryInfo, error)
	getQueryInfoMutex       sync.RWMutex
	getQueryInfoArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getQueryInfoReturns struct {
		result1 openapi.QueryInfo
		result2 error
	}
	getQueryInfoReturnsOnCall map[int]struct {
		result1 openapi.QueryInfo
		result2 error
	}
	GetQueryLambdaVersionStub        func(context.Context, string, string, string) (openapi.QueryLambdaVersion, error)
	getQueryLambdaVersionMutex       sync.RWMutex
	getQueryLambdaVersionArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	getQueryLambdaVersionReturns struct {
		result1 openapi.QueryLambdaVersion
		result2 error
	}
	getQueryLambdaVersionReturnsOnCall map[int]struct {
		result1 openapi.QueryLambdaVersion
		result2 error
	}
	GetScheduledLambdaStub        func(context.Context, string, string) (openapi.ScheduledLambda, error)
	getScheduledLambdaMutex       sync.RWMutex
	getScheduledLambdaArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	getScheduledLambdaReturns struct {
		result1 openapi.ScheduledLambda
		result2 error
	}
	getScheduledLambdaReturnsOnCall map[int]struct {
		result1 openapi.ScheduledLambda
		result2 error
	}
	GetViewStub        func(context.Context, string, string) (openapi.View, error)
	getViewMutex       sync.RWMutex
	getViewArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	getViewReturns struct {
		result1 openapi.View
		result2 error
	}
	getViewReturnsOnCall map[int]struct {
		result1 openapi.View
		result2 error
	}
	GetVirtualInstanceStub        func(context.Context, string) (openapi.VirtualInstance, error)
	getVirtualInstanceMutex       sync.RWMutex
	getVirtualInstanceArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getVirtualInstanceReturns struct {
		result1 openapi.VirtualInstance
		result2 error
	}
	getVirtualInstanceReturnsOnCall map[int]struct {
		result1 openapi.VirtualInstance
		result2 error
	}
	GetWorkspaceStub        func(context.Context, string) (openapi.Workspace, error)
	getWorkspaceMutex       sync.RWMutex
	getWorkspaceArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getWorkspaceReturns struct {
		result1 openapi.Workspace
		result2 error
	}
	getWorkspaceReturnsOnCall map[int]struct {
		result1 openapi.Workspace
		result2 error
	}
	RetryStub        func(context.Context, retry.Func) error
	retryMutex       sync.RWMutex
	retryArgsForCall []struct {
		arg1 context.Context
		arg2 retry.Func
	}
	retryReturns struct {
		result1 error
	}
	retryReturnsOnCall map[int]struct {
		result1 error
	}
	RetryWithCheckStub        func(context.Context, retry.CheckFn) error
	retryWithCheckMutex       sync.RWMutex
	retryWithCheckArgsForCall []struct {
		arg1 context.Context
		arg2 retry.CheckFn
	}
	retryWithCheckReturns struct {
		result1 error
	}
	retryWithCheckReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeResourceGetter) GetAlias(arg1 context.Context, arg2 string, arg3 string) (openapi.Alias, error) {
	fake.getAliasMutex.Lock()
	ret, specificReturn := fake.getAliasReturnsOnCall[len(fake.getAliasArgsForCall)]
	fake.getAliasArgsForCall = append(fake.getAliasArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetAliasStub
	fakeReturns := fake.getAliasReturns
	fake.recordInvocation("GetAlias", []interface{}{arg1, arg2, arg3})
	fake.getAliasMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceGetter) GetAliasCallCount() int {
	fake.getAliasMutex.RLock()
	defer fake.getAliasMutex.RUnlock()
	return len(fake.getAliasArgsForCall)
}

func (fake *FakeResourceGetter) GetAliasCalls(stub func(context.Context, string, string) (openapi.Alias, error)) {
	fake.getAliasMutex.Lock()
	defer fake.getAliasMutex.Unlock()
	fake.GetAliasStub = stub
}

func (fake *FakeResourceGetter) GetAliasArgsForCall(i int) (context.Context, string, string) {
	fake.getAliasMutex.RLock()
	defer fake.getAliasMutex.RUnlock()
	argsForCall := fake.getAliasArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeResourceGetter) GetAliasReturns(result1 openapi.Alias, result2 error) {
	fake.getAliasMutex.Lock()
	defer fake.getAliasMutex.Unlock()
	fake.GetAliasStub = nil
	fake.getAliasReturns = struct {
		result1 openapi.Alias
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceGetter) GetAliasReturnsOnCall(i int, result1 openapi.Alias, result2 error) {
	fake.getAliasMutex.Lock()
	defer fake.getAliasMutex.Unlock()
	fake.GetAliasStub = nil
	if fake.getAliasReturnsOnCall == nil {
		fake.getAliasReturnsOnCall = make(map[int]struct {
			result1 openapi.Alias
			result2 error
		})
	}
	fake.getAliasReturnsOnCall[i] = struct {
		result1 openapi.Alias
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceGetter) GetCollection(arg1 context.Context, arg2 string, arg3 string) (openapi.Collection, error) {
	fake.getCollectionMutex.Lock()
	ret, specificReturn := fake.getCollectionReturnsOnCall[len(fake.getCollectionArgsForCall)]
	fake.getCollectionArgsForCall = append(fake.getCollectionArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetCollectionStub
	fakeReturns := fake.getCollectionReturns
	fake.recordInvocation("GetCollection", []interface{}{arg1, arg2, arg3})
	fake.getCollectionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceGetter) GetCollectionCallCount() int {
	fake.getCollectionMutex.RLock()
	defer fake.getCollectionMutex.RUnlock()
	return len(fake.getCollectionArgsForCall)
}

func (fake *FakeResourceGetter) GetCollectionCalls(stub func(context.Context, string, string) (openapi.Collection, error)) {
	fake.getCollectionMutex.Lock()
	defer fake.getCollectionMutex.Unlock()
	fake.GetCollectionStub = stub
}

func (fake *FakeResourceGetter) GetCollectionArgsForCall(i int) (context.Context, string, string) {
	fake.getCollectionMutex.RLock()
	defer fake.getCollectionMutex.RUnlock()
	argsForCall := fake.getCollectionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeResourceGetter) GetCollectionReturns(result1 openapi.Collection, result2 error) {
	fake.getCollectionMutex.Lock()
	defer fake.getCollectionMutex.Unlock()
	fake.GetCollectionStub = nil
	fake.getCollectionReturns = struct {
		result1 openapi.Collection
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceGetter) GetCollectionReturnsOnCall(i int, result1 openapi.Collection, result2 error) {
	fake.getCollectionMutex.Lock()
	defer fake.getCollectionMutex.Unlock()
	fake.GetCollectionStub = nil
	if fake.getCollectionReturnsOnCall == nil {
		fake.getCollectionReturnsOnCall = make(map[int]struct {
			result1 openapi.Collection
			result2 error
		})
	}
	fake.getCollectionReturnsOnCall[i] = struct {
		result1 openapi.Collection
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceGetter) GetCollectionCommit(arg1 context.Context, arg2 string, arg3 string, arg4 []string) (openapi.GetCollectionCommitData, error) {
	var arg4Copy []string
	if arg4 != nil {
		arg4Copy = make([]string, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.getCollectionCommitMutex.Lock()
	ret, specificReturn := fake.getCollectionCommitReturnsOnCall[len(fake.getCollectionCommitArgsForCall)]
	fake.getCollectionCommitArgsForCall = append(fake.getCollectionCommitArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 []string
	}{arg1, arg2, arg3, arg4Copy})
	stub := fake.GetCollectionCommitStub
	fakeReturns := fake.getCollectionCommitReturns
	fake.recordInvocation("GetCollectionCommit", []interface{}{arg1, arg2, arg3, arg4Copy})
	fake.getCollectionCommitMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceGetter) GetCollectionCommitCallCount() int {
	fake.getCollectionCommitMutex.RLock()
	defer fake.getCollectionCommitMutex.RUnlock()
	return len(fake.getCollectionCommitArgsForCall)
}

func (fake *FakeResourceGetter) GetCollectionCommitCalls(stub func(context.Context, string, string, []string) (openapi.GetCollectionCommitData, error)) {
	fake.getCollectionCommitMutex.Lock()
	defer fake.getCollectionCommitMutex.Unlock()
	fake.GetCollectionCommitStub = stub
}

func (fake *FakeResourceGetter) GetCollectionCommitArgsForCall(i int) (context.Context, string, string, []string) {
	fake.getCollectionCommitMutex.RLock()
	defer fake.getCollectionCommitMutex.RUnlock()
	argsForCall := fake.getCollectionCommitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeResourceGetter) GetCollectionCommitReturns(result1 openapi.GetCollectionCommitData, result2 error) {
	fake.getCollectionCommitMutex.Lock()
	defer fake.getCollectionCommitMutex.Unlock()
	fake.GetCollectionCommitStub = nil
	fake.getCollectionCommitReturns = struct {
		result1 openapi.GetCollectionCommitData
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceGetter) GetCollectionCommitReturnsOnCall(i int, result1 openapi.GetCollectionCommitData, result2 error) {
	fake.getCollectionCommitMutex.Lock()
	defer fake.getCollectionCommitMutex.Unlock()
	fake.GetCollectionCommitStub = nil
	if fake.getCollectionCommitReturnsOnCall == nil {
		fake.getCollectionCommitReturnsOnCall = make(map[int]struct {
			result1 openapi.GetCollectionCommitData
			result2 error
		})
	}
	fake.getCollectionCommitReturnsOnCall[i] = struct {
		result1 openapi.GetCollectionCommitData
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceGetter) GetCollectionMount(arg1 context.Context, arg2 string, arg3 string) (openapi.CollectionMount, error) {
	fake.getCollectionMountMutex.Lock()
	ret, specificReturn := fake.getCollectionMountReturnsOnCall[len(fake.getCollectionMountArgsForCall)]
	fake.getCollectionMountArgsForCall = append(fake.getCollectionMountArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetCollectionMountStub
	fakeReturns := fake.getCollectionMountReturns
	fake.recordInvocation("GetCollectionMount", []interface{}{arg1, arg2, arg3})
	fake.getCollectionMountMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceGetter) GetCollectionMountCallCount() int {
	fake.getCollectionMountMutex.RLock()
	defer fake.getCollectionMountMutex.RUnlock()
	return len(fake.getCollectionMountArgsForCall)
}

func (fake *FakeResourceGetter) GetCollectionMountCalls(stub func(context.Context, string, string) (openapi.CollectionMount, error)) {
	fake.getCollectionMountMutex.Lock()
	defer fake.getCollectionMountMutex.Unlock()
	fake.GetCollectionMountStub = stub
}

func (fake *FakeResourceGetter) GetCollectionMountArgsForCall(i int) (context.Context, string, string) {
	fake.getCollectionMountMutex.RLock()
	defer fake.getCollectionMountMutex.RUnlock()
	argsForCall := fake.getCollectionMountArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeResourceGetter) GetCollectionMountReturns(result1 openapi.CollectionMount, result2 error) {
	fake.getCollectionMountMutex.Lock()
	defer fake.getCollectionMountMutex.Unlock()
	fake.GetCollectionMountStub = nil
	fake.getCollectionMountReturns = struct {
		result1 openapi.CollectionMount
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceGetter) GetCollectionMountReturnsOnCall(i int, result1 openapi.CollectionMount, result2 error) {
	fake.getCollectionMountMutex.Lock()
	defer fake.getCollectionMountMutex.Unlock()
	fake.GetCollectionMountStub = nil
	if fake.getCollectionMountReturnsOnCall == nil {
		fake.getCollectionMountReturnsOnCall = make(map[int]struct {
			result1 openapi.CollectionMount
			result2 error
		})
	}
	fake.getCollectionMountReturnsOnCall[i] = struct {
		result1 openapi.CollectionMount
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceGetter) GetIntegration(arg1 context.Context, arg2 string) (openapi.Integration, error) {
	fake.getIntegrationMutex.Lock()
	ret, specificReturn := fake.getIntegrationReturnsOnCall[len(fake.getIntegrationArgsForCall)]
	fake.getIntegrationArgsForCall = append(fake.getIntegrationArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetIntegrationStub
	fakeReturns := fake.getIntegrationReturns
	fake.recordInvocation("GetIntegration", []interface{}{arg1, arg2})
	fake.getIntegrationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceGetter) GetIntegrationCallCount() int {
	fake.getIntegrationMutex.RLock()
	defer fake.getIntegrationMutex.RUnlock()
	return len(fake.getIntegrationArgsForCall)
}

func (fake *FakeResourceGetter) GetIntegrationCalls(stub func(context.Context, string) (openapi.Integration, error)) {
	fake.getIntegrationMutex.Lock()
	defer fake.getIntegrationMutex.Unlock()
	fake.GetIntegrationStub = stub
}

func (fake *FakeResourceGetter) GetIntegrationArgsForCall(i int) (context.Context, string) {
	fake.getIntegrationMutex.RLock()
	defer fake.getIntegrationMutex.RUnlock()
	argsForCall := fake.getIntegrationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResourceGetter) GetIntegrationReturns(result1 openapi.Integration, result2 error) {
	fake.getIntegrationMutex.Lock()
	defer fake.getIntegrationMutex.Unlock()
	fake.GetIntegrationStub = nil
	fake.getIntegrationReturns = struct {
		result1 openapi.Integration
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceGetter) GetIntegrationReturnsOnCall(i int, result1 openapi.Integration, result2 error) {
	fake.getIntegrationMutex.Lock()
	defer fake.getIntegrationMutex.Unlock()
	fake.GetIntegrationStub = nil
	if fake.getIntegrationReturnsOnCall == nil {
		fake.getIntegrationReturnsOnCall = make(map[int]struct {
			result1 openapi.Integration
			result2 error
		})
	}
	fake.getIntegrationReturnsOnCall[i] = struct {
		result1 openapi.Integration
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceGetter) GetQueryInfo(arg1 context.Context, arg2 string) (openapi.QueryInfo, error) {
	fake.getQueryInfoMutex.Lock()
	ret, specificReturn := fake.getQueryInfoReturnsOnCall[len(fake.getQueryInfoArgsForCall)]
	fake.getQueryInfoArgsForCall = append(fake.getQueryInfoArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetQueryInfoStub
	fakeReturns := fake.getQueryInfoReturns
	fake.recordInvocation("GetQueryInfo", []interface{}{arg1, arg2})
	fake.getQueryInfoMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceGetter) GetQueryInfoCallCount() int {
	fake.getQueryInfoMutex.RLock()
	defer fake.getQueryInfoMutex.RUnlock()
	return len(fake.getQueryInfoArgsForCall)
}

func (fake *FakeResourceGetter) GetQueryInfoCalls(stub func(context.Context, string) (openapi.QueryInfo, error)) {
	fake.getQueryInfoMutex.Lock()
	defer fake.getQueryInfoMutex.Unlock()
	fake.GetQueryInfoStub = stub
}

func (fake *FakeResourceGetter) GetQueryInfoArgsForCall(i int) (context.Context, string) {
	fake.getQueryInfoMutex.RLock()
	defer fake.getQueryInfoMutex.RUnlock()
	argsForCall := fake.getQueryInfoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResourceGetter) GetQueryInfoReturns(result1 openapi.QueryInfo, result2 error) {
	fake.getQueryInfoMutex.Lock()
	defer fake.getQueryInfoMutex.Unlock()
	fake.GetQueryInfoStub = nil
	fake.getQueryInfoReturns = struct {
		result1 openapi.QueryInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceGetter) GetQueryInfoReturnsOnCall(i int, result1 openapi.QueryInfo, result2 error) {
	fake.getQueryInfoMutex.Lock()
	defer fake.getQueryInfoMutex.Unlock()
	fake.GetQueryInfoStub = nil
	if fake.getQueryInfoReturnsOnCall == nil {
		fake.getQueryInfoReturnsOnCall = make(map[int]struct {
			result1 openapi.QueryInfo
			result2 error
		})
	}
	fake.getQueryInfoReturnsOnCall[i] = struct {
		result1 openapi.QueryInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceGetter) GetQueryLambdaVersion(arg1 context.Context, arg2 string, arg3 string, arg4 string) (openapi.QueryLambdaVersion, error) {
	fake.getQueryLambdaVersionMutex.Lock()
	ret, specificReturn := fake.getQueryLambdaVersionReturnsOnCall[len(fake.getQueryLambdaVersionArgsForCall)]
	fake.getQueryLambdaVersionArgsForCall = append(fake.getQueryLambdaVersionArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetQueryLambdaVersionStub
	fakeReturns := fake.getQueryLambdaVersionReturns
	fake.recordInvocation("GetQueryLambdaVersion", []interface{}{arg1, arg2, arg3, arg4})
	fake.getQueryLambdaVersionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceGetter) GetQueryLambdaVersionCallCount() int {
	fake.getQueryLambdaVersionMutex.RLock()
	defer fake.getQueryLambdaVersionMutex.RUnlock()
	return len(fake.getQueryLambdaVersionArgsForCall)
}

func (fake *FakeResourceGetter) GetQueryLambdaVersionCalls(stub func(context.Context, string, string, string) (openapi.QueryLambdaVersion, error)) {
	fake.getQueryLambdaVersionMutex.Lock()
	defer fake.getQueryLambdaVersionMutex.Unlock()
	fake.GetQueryLambdaVersionStub = stub
}

func (fake *FakeResourceGetter) GetQueryLambdaVersionArgsForCall(i int) (context.Context, string, string, string) {
	fake.getQueryLambdaVersionMutex.RLock()
	defer fake.getQueryLambdaVersionMutex.RUnlock()
	argsForCall := fake.getQueryLambdaVersionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeResourceGetter) GetQueryLambdaVersionReturns(result1 openapi.QueryLambdaVersion, result2 error) {
	fake.getQueryLambdaVersionMutex.Lock()
	defer fake.getQueryLambdaVersionMutex.Unlock()
	fake.GetQueryLambdaVersionStub = nil
	fake.getQueryLambdaVersionReturns = struct {
		result1 openapi.QueryLambdaVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceGetter) GetQueryLambdaVersionReturnsOnCall(i int, result1 openapi.QueryLambdaVersion, result2 error) {
	fake.getQueryLambdaVersionMutex.Lock()
	defer fake.getQueryLambdaVersionMutex.Unlock()
	fake.GetQueryLambdaVersionStub = nil
	if fake.getQueryLambdaVersionReturnsOnCall == nil {
		fake.getQueryLambdaVersionReturnsOnCall = make(map[int]struct {
			result1 openapi.QueryLambdaVersion
			result2 error
		})
	}
	fake.getQueryLambdaVersionReturnsOnCall[i] = struct {
		result1 openapi.QueryLambdaVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceGetter) GetScheduledLambda(arg1 context.Context, arg2 string, arg3 string) (openapi.ScheduledLambda, error) {
	fake.getScheduledLambdaMutex.Lock()
	ret, specificReturn := fake.getScheduledLambdaReturnsOnCall[len(fake.getScheduledLambdaArgsForCall)]
	fake.getScheduledLambdaArgsForCall = append(fake.getScheduledLambdaArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetScheduledLambdaStub
	fakeReturns := fake.getScheduledLambdaReturns
	fake.recordInvocation("GetScheduledLambda", []interface{}{arg1, arg2, arg3})
	fake.getScheduledLambdaMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceGetter) GetScheduledLambdaCallCount() int {
	fake.getScheduledLambdaMutex.RLock()
	defer fake.getScheduledLambdaMutex.RUnlock()
	return len(fake.getScheduledLambdaArgsForCall)
}

func (fake *FakeResourceGetter) GetScheduledLambdaCalls(stub func(context.Context, string, string) (openapi.ScheduledLambda, error)) {
	fake.getScheduledLambdaMutex.Lock()
	defer fake.getScheduledLambdaMutex.Unlock()
	fake.GetScheduledLambdaStub = stub
}

func (fake *FakeResourceGetter) GetScheduledLambdaArgsForCall(i int) (context.Context, string, string) {
	fake.getScheduledLambdaMutex.RLock()
	defer fake.getScheduledLambdaMutex.RUnlock()
	argsForCall := fake.getScheduledLambdaArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeResourceGetter) GetScheduledLambdaReturns(result1 openapi.ScheduledLambda, result2 error) {
	fake.getScheduledLambdaMutex.Lock()
	defer fake.getScheduledLambdaMutex.Unlock()
	fake.GetScheduledLambdaStub = nil
	fake.getScheduledLambdaReturns = struct {
		result1 openapi.ScheduledLambda
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceGetter) GetScheduledLambdaReturnsOnCall(i int, result1 openapi.ScheduledLambda, result2 error) {
	fake.getScheduledLambdaMutex.Lock()
	defer fake.getScheduledLambdaMutex.Unlock()
	fake.GetScheduledLambdaStub = nil
	if fake.getScheduledLambdaReturnsOnCall == nil {
		fake.getScheduledLambdaReturnsOnCall = make(map[int]struct {
			result1 openapi.ScheduledLambda
			result2 error
		})
	}
	fake.getScheduledLambdaReturnsOnCall[i] = struct {
		result1 openapi.ScheduledLambda
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceGetter) GetView(arg1 context.Context, arg2 string, arg3 string) (openapi.View, error) {
	fake.getViewMutex.Lock()
	ret, specificReturn := fake.getViewReturnsOnCall[len(fake.getViewArgsForCall)]
	fake.getViewArgsForCall = append(fake.getViewArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetViewStub
	fakeReturns := fake.getViewReturns
	fake.recordInvocation("GetView", []interface{}{arg1, arg2, arg3})
	fake.getViewMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceGetter) GetViewCallCount() int {
	fake.getViewMutex.RLock()
	defer fake.getViewMutex.RUnlock()
	return len(fake.getViewArgsForCall)
}

func (fake *FakeResourceGetter) GetViewCalls(stub func(context.Context, string, string) (openapi.View, error)) {
	fake.getViewMutex.Lock()
	defer fake.getViewMutex.Unlock()
	fake.GetViewStub = stub
}

func (fake *FakeResourceGetter) GetViewArgsForCall(i int) (context.Context, string, string) {
	fake.getViewMutex.RLock()
	defer fake.getViewMutex.RUnlock()
	argsForCall := fake.getViewArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeResourceGetter) GetViewReturns(result1 openapi.View, result2 error) {
	fake.getViewMutex.Lock()
	defer fake.getViewMutex.Unlock()
	fake.GetViewStub = nil
	fake.getViewReturns = struct {
		result1 openapi.View
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceGetter) GetViewReturnsOnCall(i int, result1 openapi.View, result2 error) {
	fake.getViewMutex.Lock()
	defer fake.getViewMutex.Unlock()
	fake.GetViewStub = nil
	if fake.getViewReturnsOnCall == nil {
		fake.getViewReturnsOnCall = make(map[int]struct {
			result1 openapi.View
			result2 error
		})
	}
	fake.getViewReturnsOnCall[i] = struct {
		result1 openapi.View
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceGetter) GetVirtualInstance(arg1 context.Context, arg2 string) (openapi.VirtualInstance, error) {
	fake.getVirtualInstanceMutex.Lock()
	ret, specificReturn := fake.getVirtualInstanceReturnsOnCall[len(fake.getVirtualInstanceArgsForCall)]
	fake.getVirtualInstanceArgsForCall = append(fake.getVirtualInstanceArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetVirtualInstanceStub
	fakeReturns := fake.getVirtualInstanceReturns
	fake.recordInvocation("GetVirtualInstance", []interface{}{arg1, arg2})
	fake.getVirtualInstanceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceGetter) GetVirtualInstanceCallCount() int {
	fake.getVirtualInstanceMutex.RLock()
	defer fake.getVirtualInstanceMutex.RUnlock()
	return len(fake.getVirtualInstanceArgsForCall)
}

func (fake *FakeResourceGetter) GetVirtualInstanceCalls(stub func(context.Context, string) (openapi.VirtualInstance, error)) {
	fake.getVirtualInstanceMutex.Lock()
	defer fake.getVirtualInstanceMutex.Unlock()
	fake.GetVirtualInstanceStub = stub
}

func (fake *FakeResourceGetter) GetVirtualInstanceArgsForCall(i int) (context.Context, string) {
	fake.getVirtualInstanceMutex.RLock()
	defer fake.getVirtualInstanceMutex.RUnlock()
	argsForCall := fake.getVirtualInstanceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResourceGetter) GetVirtualInstanceReturns(result1 openapi.VirtualInstance, result2 error) {
	fake.getVirtualInstanceMutex.Lock()
	defer fake.getVirtualInstanceMutex.Unlock()
	fake.GetVirtualInstanceStub = nil
	fake.getVirtualInstanceReturns = struct {
		result1 openapi.VirtualInstance
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceGetter) GetVirtualInstanceReturnsOnCall(i int, result1 openapi.VirtualInstance, result2 error) {
	fake.getVirtualInstanceMutex.Lock()
	defer fake.getVirtualInstanceMutex.Unlock()
	fake.GetVirtualInstanceStub = nil
	if fake.getVirtualInstanceReturnsOnCall == nil {
		fake.getVirtualInstanceReturnsOnCall = make(map[int]struct {
			result1 openapi.VirtualInstance
			result2 error
		})
	}
	fake.getVirtualInstanceReturnsOnCall[i] = struct {
		result1 openapi.VirtualInstance
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceGetter) GetWorkspace(arg1 context.Context, arg2 string) (openapi.Workspace, error) {
	fake.getWorkspaceMutex.Lock()
	ret, specificReturn := fake.getWorkspaceReturnsOnCall[len(fake.getWorkspaceArgsForCall)]
	fake.getWorkspaceArgsForCall = append(fake.getWorkspaceArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetWorkspaceStub
	fakeReturns := fake.getWorkspaceReturns
	fake.recordInvocation("GetWorkspace", []interface{}{arg1, arg2})
	fake.getWorkspaceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceGetter) GetWorkspaceCallCount() int {
	fake.getWorkspaceMutex.RLock()
	defer fake.getWorkspaceMutex.RUnlock()
	return len(fake.getWorkspaceArgsForCall)
}

func (fake *FakeResourceGetter) GetWorkspaceCalls(stub func(context.Context, string) (openapi.Workspace, error)) {
	fake.getWorkspaceMutex.Lock()
	defer fake.getWorkspaceMutex.Unlock()
	fake.GetWorkspaceStub = stub
}

func (fake *FakeResourceGetter) GetWorkspaceArgsForCall(i int) (context.Context, string) {
	fake.getWorkspaceMutex.RLock()
	defer fake.getWorkspaceMutex.RUnlock()
	argsForCall := fake.getWorkspaceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResourceGetter) GetWorkspaceReturns(result1 openapi.Workspace, result2 error) {
	fake.getWorkspaceMutex.Lock()
	defer fake.getWorkspaceMutex.Unlock()
	fake.GetWorkspaceStub = nil
	fake.getWorkspaceReturns = struct {
		result1 openapi.Workspace
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceGetter) GetWorkspaceReturnsOnCall(i int, result1 openapi.Workspace, result2 error) {
	fake.getWorkspaceMutex.Lock()
	defer fake.getWorkspaceMutex.Unlock()
	fake.GetWorkspaceStub = nil
	if fake.getWorkspaceReturnsOnCall == nil {
		fake.getWorkspaceReturnsOnCall = make(map[int]struct {
			result1 openapi.Workspace
			result2 error
		})
	}
	fake.getWorkspaceReturnsOnCall[i] = struct {
		result1 openapi.Workspace
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceGetter) Retry(arg1 context.Context, arg2 retry.Func) error {
	fake.retryMutex.Lock()
	ret, specificReturn := fake.retryReturnsOnCall[len(fake.retryArgsForCall)]
	fake.retryArgsForCall = append(fake.retryArgsForCall, struct {
		arg1 context.Context
		arg2 retry.Func
	}{arg1, arg2})
	stub := fake.RetryStub
	fakeReturns := fake.retryReturns
	fake.recordInvocation("Retry", []interface{}{arg1, arg2})
	fake.retryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResourceGetter) RetryCallCount() int {
	fake.retryMutex.RLock()
	defer fake.retryMutex.RUnlock()
	return len(fake.retryArgsForCall)
}

func (fake *FakeResourceGetter) RetryCalls(stub func(context.Context, retry.Func) error) {
	fake.retryMutex.Lock()
	defer fake.retryMutex.Unlock()
	fake.RetryStub = stub
}

func (fake *FakeResourceGetter) RetryArgsForCall(i int) (context.Context, retry.Func) {
	fake.retryMutex.RLock()
	defer fake.retryMutex.RUnlock()
	argsForCall := fake.retryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResourceGetter) RetryReturns(result1 error) {
	fake.retryMutex.Lock()
	defer fake.retryMutex.Unlock()
	fake.RetryStub = nil
	fake.retryReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceGetter) RetryReturnsOnCall(i int, result1 error) {
	fake.retryMutex.Lock()
	defer fake.retryMutex.Unlock()
	fake.RetryStub = nil
	if fake.retryReturnsOnCall == nil {
		fake.retryReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.retryReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceGetter) RetryWithCheck(arg1 context.Context, arg2 retry.CheckFn) error {
	fake.retryWithCheckMutex.Lock()
	ret, specificReturn := fake.retryWithCheckReturnsOnCall[len(fake.retryWithCheckArgsForCall)]
	fake.retryWithCheckArgsForCall = append(fake.retryWithCheckArgsForCall, struct {
		arg1 context.Context
		arg2 retry.CheckFn
	}{arg1, arg2})
	stub := fake.RetryWithCheckStub
	fakeReturns := fake.retryWithCheckReturns
	fake.recordInvocation("RetryWithCheck", []interface{}{arg1, arg2})
	fake.retryWithCheckMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResourceGetter) RetryWithCheckCallCount() int {
	fake.retryWithCheckMutex.RLock()
	defer fake.retryWithCheckMutex.RUnlock()
	return len(fake.retryWithCheckArgsForCall)
}

func (fake *FakeResourceGetter) RetryWithCheckCalls(stub func(context.Context, retry.CheckFn) error) {
	fake.retryWithCheckMutex.Lock()
	defer fake.retryWithCheckMutex.Unlock()
	fake.RetryWithCheckStub = stub
}

func (fake *FakeResourceGetter) RetryWithCheckArgsForCall(i int) (context.Context, retry.CheckFn) {
	fake.retryWithCheckMutex.RLock()
	defer fake.retryWithCheckMutex.RUnlock()
	argsForCall := fake.retryWithCheckArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResourceGetter) RetryWithCheckReturns(result1 error) {
	fake.retryWithCheckMutex.Lock()
	defer fake.retryWithCheckMutex.Unlock()
	fake.RetryWithCheckStub = nil
	fake.retryWithCheckReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceGetter) RetryWithCheckReturnsOnCall(i int, result1 error) {
	fake.retryWithCheckMutex.Lock()
	defer fake.retryWithCheckMutex.Unlock()
	fake.RetryWithCheckStub = nil
	if fake.retryWithCheckReturnsOnCall == nil {
		fake.retryWithCheckReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.retryWithCheckReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceGetter) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getAliasMutex.RLock()
	defer fake.getAliasMutex.RUnlock()
	fake.getCollectionMutex.RLock()
	defer fake.getCollectionMutex.RUnlock()
	fake.getCollectionCommitMutex.RLock()
	defer fake.getCollectionCommitMutex.RUnlock()
	fake.getCollectionMountMutex.RLock()
	defer fake.getCollectionMountMutex.RUnlock()
	fake.getIntegrationMutex.RLock()
	defer fake.getIntegrationMutex.RUnlock()
	fake.getQueryInfoMutex.RLock()
	defer fake.getQueryInfoMutex.RUnlock()
	fake.getQueryLambdaVersionMutex.RLock()
	defer fake.getQueryLambdaVersionMutex.RUnlock()
	fake.getScheduledLambdaMutex.RLock()
	defer fake.getScheduledLambdaMutex.RUnlock()
	fake.getViewMutex.RLock()
	defer fake.getViewMutex.RUnlock()
	fake.getVirtualInstanceMutex.RLock()
	defer fake.getVirtualInstanceMutex.RUnlock()
	fake.getWorkspaceMutex.RLock()
	defer fake.getWorkspaceMutex.RUnlock()
	fake.retryMutex.RLock()
	defer fake.retryMutex.RUnlock()
	fake.retryWithCheckMutex.RLock()
	defer fake.retryWithCheckMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeResourceGetter) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ wait.ResourceGetter = new(FakeResourceGetter)
