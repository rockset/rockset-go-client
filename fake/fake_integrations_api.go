// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"context"
	"net/http"
	"sync"

	"github.com/rockset/rockset-go-client/openapi"
)

type FakeIntegrationsApi struct {
	CreateIntegrationStub        func(context.Context) openapi.ApiCreateIntegrationRequest
	createIntegrationMutex       sync.RWMutex
	createIntegrationArgsForCall []struct {
		arg1 context.Context
	}
	createIntegrationReturns struct {
		result1 openapi.ApiCreateIntegrationRequest
	}
	createIntegrationReturnsOnCall map[int]struct {
		result1 openapi.ApiCreateIntegrationRequest
	}
	CreateIntegrationExecuteStub        func(openapi.ApiCreateIntegrationRequest) (*openapi.CreateIntegrationResponse, *http.Response, error)
	createIntegrationExecuteMutex       sync.RWMutex
	createIntegrationExecuteArgsForCall []struct {
		arg1 openapi.ApiCreateIntegrationRequest
	}
	createIntegrationExecuteReturns struct {
		result1 *openapi.CreateIntegrationResponse
		result2 *http.Response
		result3 error
	}
	createIntegrationExecuteReturnsOnCall map[int]struct {
		result1 *openapi.CreateIntegrationResponse
		result2 *http.Response
		result3 error
	}
	DeleteIntegrationStub        func(context.Context, string) openapi.ApiDeleteIntegrationRequest
	deleteIntegrationMutex       sync.RWMutex
	deleteIntegrationArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	deleteIntegrationReturns struct {
		result1 openapi.ApiDeleteIntegrationRequest
	}
	deleteIntegrationReturnsOnCall map[int]struct {
		result1 openapi.ApiDeleteIntegrationRequest
	}
	DeleteIntegrationExecuteStub        func(openapi.ApiDeleteIntegrationRequest) (*openapi.DeleteIntegrationResponse, *http.Response, error)
	deleteIntegrationExecuteMutex       sync.RWMutex
	deleteIntegrationExecuteArgsForCall []struct {
		arg1 openapi.ApiDeleteIntegrationRequest
	}
	deleteIntegrationExecuteReturns struct {
		result1 *openapi.DeleteIntegrationResponse
		result2 *http.Response
		result3 error
	}
	deleteIntegrationExecuteReturnsOnCall map[int]struct {
		result1 *openapi.DeleteIntegrationResponse
		result2 *http.Response
		result3 error
	}
	GetIntegrationStub        func(context.Context, string) openapi.ApiGetIntegrationRequest
	getIntegrationMutex       sync.RWMutex
	getIntegrationArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getIntegrationReturns struct {
		result1 openapi.ApiGetIntegrationRequest
	}
	getIntegrationReturnsOnCall map[int]struct {
		result1 openapi.ApiGetIntegrationRequest
	}
	GetIntegrationExecuteStub        func(openapi.ApiGetIntegrationRequest) (*openapi.GetIntegrationResponse, *http.Response, error)
	getIntegrationExecuteMutex       sync.RWMutex
	getIntegrationExecuteArgsForCall []struct {
		arg1 openapi.ApiGetIntegrationRequest
	}
	getIntegrationExecuteReturns struct {
		result1 *openapi.GetIntegrationResponse
		result2 *http.Response
		result3 error
	}
	getIntegrationExecuteReturnsOnCall map[int]struct {
		result1 *openapi.GetIntegrationResponse
		result2 *http.Response
		result3 error
	}
	ListIntegrationsStub        func(context.Context) openapi.ApiListIntegrationsRequest
	listIntegrationsMutex       sync.RWMutex
	listIntegrationsArgsForCall []struct {
		arg1 context.Context
	}
	listIntegrationsReturns struct {
		result1 openapi.ApiListIntegrationsRequest
	}
	listIntegrationsReturnsOnCall map[int]struct {
		result1 openapi.ApiListIntegrationsRequest
	}
	ListIntegrationsExecuteStub        func(openapi.ApiListIntegrationsRequest) (*openapi.ListIntegrationsResponse, *http.Response, error)
	listIntegrationsExecuteMutex       sync.RWMutex
	listIntegrationsExecuteArgsForCall []struct {
		arg1 openapi.ApiListIntegrationsRequest
	}
	listIntegrationsExecuteReturns struct {
		result1 *openapi.ListIntegrationsResponse
		result2 *http.Response
		result3 error
	}
	listIntegrationsExecuteReturnsOnCall map[int]struct {
		result1 *openapi.ListIntegrationsResponse
		result2 *http.Response
		result3 error
	}
	UpdateIntegrationStub        func(context.Context, string) openapi.ApiUpdateIntegrationRequest
	updateIntegrationMutex       sync.RWMutex
	updateIntegrationArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	updateIntegrationReturns struct {
		result1 openapi.ApiUpdateIntegrationRequest
	}
	updateIntegrationReturnsOnCall map[int]struct {
		result1 openapi.ApiUpdateIntegrationRequest
	}
	UpdateIntegrationExecuteStub        func(openapi.ApiUpdateIntegrationRequest) (*openapi.UpdateIntegrationResponse, *http.Response, error)
	updateIntegrationExecuteMutex       sync.RWMutex
	updateIntegrationExecuteArgsForCall []struct {
		arg1 openapi.ApiUpdateIntegrationRequest
	}
	updateIntegrationExecuteReturns struct {
		result1 *openapi.UpdateIntegrationResponse
		result2 *http.Response
		result3 error
	}
	updateIntegrationExecuteReturnsOnCall map[int]struct {
		result1 *openapi.UpdateIntegrationResponse
		result2 *http.Response
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeIntegrationsApi) CreateIntegration(arg1 context.Context) openapi.ApiCreateIntegrationRequest {
	fake.createIntegrationMutex.Lock()
	ret, specificReturn := fake.createIntegrationReturnsOnCall[len(fake.createIntegrationArgsForCall)]
	fake.createIntegrationArgsForCall = append(fake.createIntegrationArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.CreateIntegrationStub
	fakeReturns := fake.createIntegrationReturns
	fake.recordInvocation("CreateIntegration", []interface{}{arg1})
	fake.createIntegrationMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIntegrationsApi) CreateIntegrationCallCount() int {
	fake.createIntegrationMutex.RLock()
	defer fake.createIntegrationMutex.RUnlock()
	return len(fake.createIntegrationArgsForCall)
}

func (fake *FakeIntegrationsApi) CreateIntegrationCalls(stub func(context.Context) openapi.ApiCreateIntegrationRequest) {
	fake.createIntegrationMutex.Lock()
	defer fake.createIntegrationMutex.Unlock()
	fake.CreateIntegrationStub = stub
}

func (fake *FakeIntegrationsApi) CreateIntegrationArgsForCall(i int) context.Context {
	fake.createIntegrationMutex.RLock()
	defer fake.createIntegrationMutex.RUnlock()
	argsForCall := fake.createIntegrationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIntegrationsApi) CreateIntegrationReturns(result1 openapi.ApiCreateIntegrationRequest) {
	fake.createIntegrationMutex.Lock()
	defer fake.createIntegrationMutex.Unlock()
	fake.CreateIntegrationStub = nil
	fake.createIntegrationReturns = struct {
		result1 openapi.ApiCreateIntegrationRequest
	}{result1}
}

func (fake *FakeIntegrationsApi) CreateIntegrationReturnsOnCall(i int, result1 openapi.ApiCreateIntegrationRequest) {
	fake.createIntegrationMutex.Lock()
	defer fake.createIntegrationMutex.Unlock()
	fake.CreateIntegrationStub = nil
	if fake.createIntegrationReturnsOnCall == nil {
		fake.createIntegrationReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiCreateIntegrationRequest
		})
	}
	fake.createIntegrationReturnsOnCall[i] = struct {
		result1 openapi.ApiCreateIntegrationRequest
	}{result1}
}

func (fake *FakeIntegrationsApi) CreateIntegrationExecute(arg1 openapi.ApiCreateIntegrationRequest) (*openapi.CreateIntegrationResponse, *http.Response, error) {
	fake.createIntegrationExecuteMutex.Lock()
	ret, specificReturn := fake.createIntegrationExecuteReturnsOnCall[len(fake.createIntegrationExecuteArgsForCall)]
	fake.createIntegrationExecuteArgsForCall = append(fake.createIntegrationExecuteArgsForCall, struct {
		arg1 openapi.ApiCreateIntegrationRequest
	}{arg1})
	stub := fake.CreateIntegrationExecuteStub
	fakeReturns := fake.createIntegrationExecuteReturns
	fake.recordInvocation("CreateIntegrationExecute", []interface{}{arg1})
	fake.createIntegrationExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeIntegrationsApi) CreateIntegrationExecuteCallCount() int {
	fake.createIntegrationExecuteMutex.RLock()
	defer fake.createIntegrationExecuteMutex.RUnlock()
	return len(fake.createIntegrationExecuteArgsForCall)
}

func (fake *FakeIntegrationsApi) CreateIntegrationExecuteCalls(stub func(openapi.ApiCreateIntegrationRequest) (*openapi.CreateIntegrationResponse, *http.Response, error)) {
	fake.createIntegrationExecuteMutex.Lock()
	defer fake.createIntegrationExecuteMutex.Unlock()
	fake.CreateIntegrationExecuteStub = stub
}

func (fake *FakeIntegrationsApi) CreateIntegrationExecuteArgsForCall(i int) openapi.ApiCreateIntegrationRequest {
	fake.createIntegrationExecuteMutex.RLock()
	defer fake.createIntegrationExecuteMutex.RUnlock()
	argsForCall := fake.createIntegrationExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIntegrationsApi) CreateIntegrationExecuteReturns(result1 *openapi.CreateIntegrationResponse, result2 *http.Response, result3 error) {
	fake.createIntegrationExecuteMutex.Lock()
	defer fake.createIntegrationExecuteMutex.Unlock()
	fake.CreateIntegrationExecuteStub = nil
	fake.createIntegrationExecuteReturns = struct {
		result1 *openapi.CreateIntegrationResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIntegrationsApi) CreateIntegrationExecuteReturnsOnCall(i int, result1 *openapi.CreateIntegrationResponse, result2 *http.Response, result3 error) {
	fake.createIntegrationExecuteMutex.Lock()
	defer fake.createIntegrationExecuteMutex.Unlock()
	fake.CreateIntegrationExecuteStub = nil
	if fake.createIntegrationExecuteReturnsOnCall == nil {
		fake.createIntegrationExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.CreateIntegrationResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.createIntegrationExecuteReturnsOnCall[i] = struct {
		result1 *openapi.CreateIntegrationResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIntegrationsApi) DeleteIntegration(arg1 context.Context, arg2 string) openapi.ApiDeleteIntegrationRequest {
	fake.deleteIntegrationMutex.Lock()
	ret, specificReturn := fake.deleteIntegrationReturnsOnCall[len(fake.deleteIntegrationArgsForCall)]
	fake.deleteIntegrationArgsForCall = append(fake.deleteIntegrationArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteIntegrationStub
	fakeReturns := fake.deleteIntegrationReturns
	fake.recordInvocation("DeleteIntegration", []interface{}{arg1, arg2})
	fake.deleteIntegrationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIntegrationsApi) DeleteIntegrationCallCount() int {
	fake.deleteIntegrationMutex.RLock()
	defer fake.deleteIntegrationMutex.RUnlock()
	return len(fake.deleteIntegrationArgsForCall)
}

func (fake *FakeIntegrationsApi) DeleteIntegrationCalls(stub func(context.Context, string) openapi.ApiDeleteIntegrationRequest) {
	fake.deleteIntegrationMutex.Lock()
	defer fake.deleteIntegrationMutex.Unlock()
	fake.DeleteIntegrationStub = stub
}

func (fake *FakeIntegrationsApi) DeleteIntegrationArgsForCall(i int) (context.Context, string) {
	fake.deleteIntegrationMutex.RLock()
	defer fake.deleteIntegrationMutex.RUnlock()
	argsForCall := fake.deleteIntegrationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIntegrationsApi) DeleteIntegrationReturns(result1 openapi.ApiDeleteIntegrationRequest) {
	fake.deleteIntegrationMutex.Lock()
	defer fake.deleteIntegrationMutex.Unlock()
	fake.DeleteIntegrationStub = nil
	fake.deleteIntegrationReturns = struct {
		result1 openapi.ApiDeleteIntegrationRequest
	}{result1}
}

func (fake *FakeIntegrationsApi) DeleteIntegrationReturnsOnCall(i int, result1 openapi.ApiDeleteIntegrationRequest) {
	fake.deleteIntegrationMutex.Lock()
	defer fake.deleteIntegrationMutex.Unlock()
	fake.DeleteIntegrationStub = nil
	if fake.deleteIntegrationReturnsOnCall == nil {
		fake.deleteIntegrationReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiDeleteIntegrationRequest
		})
	}
	fake.deleteIntegrationReturnsOnCall[i] = struct {
		result1 openapi.ApiDeleteIntegrationRequest
	}{result1}
}

func (fake *FakeIntegrationsApi) DeleteIntegrationExecute(arg1 openapi.ApiDeleteIntegrationRequest) (*openapi.DeleteIntegrationResponse, *http.Response, error) {
	fake.deleteIntegrationExecuteMutex.Lock()
	ret, specificReturn := fake.deleteIntegrationExecuteReturnsOnCall[len(fake.deleteIntegrationExecuteArgsForCall)]
	fake.deleteIntegrationExecuteArgsForCall = append(fake.deleteIntegrationExecuteArgsForCall, struct {
		arg1 openapi.ApiDeleteIntegrationRequest
	}{arg1})
	stub := fake.DeleteIntegrationExecuteStub
	fakeReturns := fake.deleteIntegrationExecuteReturns
	fake.recordInvocation("DeleteIntegrationExecute", []interface{}{arg1})
	fake.deleteIntegrationExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeIntegrationsApi) DeleteIntegrationExecuteCallCount() int {
	fake.deleteIntegrationExecuteMutex.RLock()
	defer fake.deleteIntegrationExecuteMutex.RUnlock()
	return len(fake.deleteIntegrationExecuteArgsForCall)
}

func (fake *FakeIntegrationsApi) DeleteIntegrationExecuteCalls(stub func(openapi.ApiDeleteIntegrationRequest) (*openapi.DeleteIntegrationResponse, *http.Response, error)) {
	fake.deleteIntegrationExecuteMutex.Lock()
	defer fake.deleteIntegrationExecuteMutex.Unlock()
	fake.DeleteIntegrationExecuteStub = stub
}

func (fake *FakeIntegrationsApi) DeleteIntegrationExecuteArgsForCall(i int) openapi.ApiDeleteIntegrationRequest {
	fake.deleteIntegrationExecuteMutex.RLock()
	defer fake.deleteIntegrationExecuteMutex.RUnlock()
	argsForCall := fake.deleteIntegrationExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIntegrationsApi) DeleteIntegrationExecuteReturns(result1 *openapi.DeleteIntegrationResponse, result2 *http.Response, result3 error) {
	fake.deleteIntegrationExecuteMutex.Lock()
	defer fake.deleteIntegrationExecuteMutex.Unlock()
	fake.DeleteIntegrationExecuteStub = nil
	fake.deleteIntegrationExecuteReturns = struct {
		result1 *openapi.DeleteIntegrationResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIntegrationsApi) DeleteIntegrationExecuteReturnsOnCall(i int, result1 *openapi.DeleteIntegrationResponse, result2 *http.Response, result3 error) {
	fake.deleteIntegrationExecuteMutex.Lock()
	defer fake.deleteIntegrationExecuteMutex.Unlock()
	fake.DeleteIntegrationExecuteStub = nil
	if fake.deleteIntegrationExecuteReturnsOnCall == nil {
		fake.deleteIntegrationExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.DeleteIntegrationResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.deleteIntegrationExecuteReturnsOnCall[i] = struct {
		result1 *openapi.DeleteIntegrationResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIntegrationsApi) GetIntegration(arg1 context.Context, arg2 string) openapi.ApiGetIntegrationRequest {
	fake.getIntegrationMutex.Lock()
	ret, specificReturn := fake.getIntegrationReturnsOnCall[len(fake.getIntegrationArgsForCall)]
	fake.getIntegrationArgsForCall = append(fake.getIntegrationArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetIntegrationStub
	fakeReturns := fake.getIntegrationReturns
	fake.recordInvocation("GetIntegration", []interface{}{arg1, arg2})
	fake.getIntegrationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIntegrationsApi) GetIntegrationCallCount() int {
	fake.getIntegrationMutex.RLock()
	defer fake.getIntegrationMutex.RUnlock()
	return len(fake.getIntegrationArgsForCall)
}

func (fake *FakeIntegrationsApi) GetIntegrationCalls(stub func(context.Context, string) openapi.ApiGetIntegrationRequest) {
	fake.getIntegrationMutex.Lock()
	defer fake.getIntegrationMutex.Unlock()
	fake.GetIntegrationStub = stub
}

func (fake *FakeIntegrationsApi) GetIntegrationArgsForCall(i int) (context.Context, string) {
	fake.getIntegrationMutex.RLock()
	defer fake.getIntegrationMutex.RUnlock()
	argsForCall := fake.getIntegrationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIntegrationsApi) GetIntegrationReturns(result1 openapi.ApiGetIntegrationRequest) {
	fake.getIntegrationMutex.Lock()
	defer fake.getIntegrationMutex.Unlock()
	fake.GetIntegrationStub = nil
	fake.getIntegrationReturns = struct {
		result1 openapi.ApiGetIntegrationRequest
	}{result1}
}

func (fake *FakeIntegrationsApi) GetIntegrationReturnsOnCall(i int, result1 openapi.ApiGetIntegrationRequest) {
	fake.getIntegrationMutex.Lock()
	defer fake.getIntegrationMutex.Unlock()
	fake.GetIntegrationStub = nil
	if fake.getIntegrationReturnsOnCall == nil {
		fake.getIntegrationReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiGetIntegrationRequest
		})
	}
	fake.getIntegrationReturnsOnCall[i] = struct {
		result1 openapi.ApiGetIntegrationRequest
	}{result1}
}

func (fake *FakeIntegrationsApi) GetIntegrationExecute(arg1 openapi.ApiGetIntegrationRequest) (*openapi.GetIntegrationResponse, *http.Response, error) {
	fake.getIntegrationExecuteMutex.Lock()
	ret, specificReturn := fake.getIntegrationExecuteReturnsOnCall[len(fake.getIntegrationExecuteArgsForCall)]
	fake.getIntegrationExecuteArgsForCall = append(fake.getIntegrationExecuteArgsForCall, struct {
		arg1 openapi.ApiGetIntegrationRequest
	}{arg1})
	stub := fake.GetIntegrationExecuteStub
	fakeReturns := fake.getIntegrationExecuteReturns
	fake.recordInvocation("GetIntegrationExecute", []interface{}{arg1})
	fake.getIntegrationExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeIntegrationsApi) GetIntegrationExecuteCallCount() int {
	fake.getIntegrationExecuteMutex.RLock()
	defer fake.getIntegrationExecuteMutex.RUnlock()
	return len(fake.getIntegrationExecuteArgsForCall)
}

func (fake *FakeIntegrationsApi) GetIntegrationExecuteCalls(stub func(openapi.ApiGetIntegrationRequest) (*openapi.GetIntegrationResponse, *http.Response, error)) {
	fake.getIntegrationExecuteMutex.Lock()
	defer fake.getIntegrationExecuteMutex.Unlock()
	fake.GetIntegrationExecuteStub = stub
}

func (fake *FakeIntegrationsApi) GetIntegrationExecuteArgsForCall(i int) openapi.ApiGetIntegrationRequest {
	fake.getIntegrationExecuteMutex.RLock()
	defer fake.getIntegrationExecuteMutex.RUnlock()
	argsForCall := fake.getIntegrationExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIntegrationsApi) GetIntegrationExecuteReturns(result1 *openapi.GetIntegrationResponse, result2 *http.Response, result3 error) {
	fake.getIntegrationExecuteMutex.Lock()
	defer fake.getIntegrationExecuteMutex.Unlock()
	fake.GetIntegrationExecuteStub = nil
	fake.getIntegrationExecuteReturns = struct {
		result1 *openapi.GetIntegrationResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIntegrationsApi) GetIntegrationExecuteReturnsOnCall(i int, result1 *openapi.GetIntegrationResponse, result2 *http.Response, result3 error) {
	fake.getIntegrationExecuteMutex.Lock()
	defer fake.getIntegrationExecuteMutex.Unlock()
	fake.GetIntegrationExecuteStub = nil
	if fake.getIntegrationExecuteReturnsOnCall == nil {
		fake.getIntegrationExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.GetIntegrationResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.getIntegrationExecuteReturnsOnCall[i] = struct {
		result1 *openapi.GetIntegrationResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIntegrationsApi) ListIntegrations(arg1 context.Context) openapi.ApiListIntegrationsRequest {
	fake.listIntegrationsMutex.Lock()
	ret, specificReturn := fake.listIntegrationsReturnsOnCall[len(fake.listIntegrationsArgsForCall)]
	fake.listIntegrationsArgsForCall = append(fake.listIntegrationsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ListIntegrationsStub
	fakeReturns := fake.listIntegrationsReturns
	fake.recordInvocation("ListIntegrations", []interface{}{arg1})
	fake.listIntegrationsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIntegrationsApi) ListIntegrationsCallCount() int {
	fake.listIntegrationsMutex.RLock()
	defer fake.listIntegrationsMutex.RUnlock()
	return len(fake.listIntegrationsArgsForCall)
}

func (fake *FakeIntegrationsApi) ListIntegrationsCalls(stub func(context.Context) openapi.ApiListIntegrationsRequest) {
	fake.listIntegrationsMutex.Lock()
	defer fake.listIntegrationsMutex.Unlock()
	fake.ListIntegrationsStub = stub
}

func (fake *FakeIntegrationsApi) ListIntegrationsArgsForCall(i int) context.Context {
	fake.listIntegrationsMutex.RLock()
	defer fake.listIntegrationsMutex.RUnlock()
	argsForCall := fake.listIntegrationsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIntegrationsApi) ListIntegrationsReturns(result1 openapi.ApiListIntegrationsRequest) {
	fake.listIntegrationsMutex.Lock()
	defer fake.listIntegrationsMutex.Unlock()
	fake.ListIntegrationsStub = nil
	fake.listIntegrationsReturns = struct {
		result1 openapi.ApiListIntegrationsRequest
	}{result1}
}

func (fake *FakeIntegrationsApi) ListIntegrationsReturnsOnCall(i int, result1 openapi.ApiListIntegrationsRequest) {
	fake.listIntegrationsMutex.Lock()
	defer fake.listIntegrationsMutex.Unlock()
	fake.ListIntegrationsStub = nil
	if fake.listIntegrationsReturnsOnCall == nil {
		fake.listIntegrationsReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiListIntegrationsRequest
		})
	}
	fake.listIntegrationsReturnsOnCall[i] = struct {
		result1 openapi.ApiListIntegrationsRequest
	}{result1}
}

func (fake *FakeIntegrationsApi) ListIntegrationsExecute(arg1 openapi.ApiListIntegrationsRequest) (*openapi.ListIntegrationsResponse, *http.Response, error) {
	fake.listIntegrationsExecuteMutex.Lock()
	ret, specificReturn := fake.listIntegrationsExecuteReturnsOnCall[len(fake.listIntegrationsExecuteArgsForCall)]
	fake.listIntegrationsExecuteArgsForCall = append(fake.listIntegrationsExecuteArgsForCall, struct {
		arg1 openapi.ApiListIntegrationsRequest
	}{arg1})
	stub := fake.ListIntegrationsExecuteStub
	fakeReturns := fake.listIntegrationsExecuteReturns
	fake.recordInvocation("ListIntegrationsExecute", []interface{}{arg1})
	fake.listIntegrationsExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeIntegrationsApi) ListIntegrationsExecuteCallCount() int {
	fake.listIntegrationsExecuteMutex.RLock()
	defer fake.listIntegrationsExecuteMutex.RUnlock()
	return len(fake.listIntegrationsExecuteArgsForCall)
}

func (fake *FakeIntegrationsApi) ListIntegrationsExecuteCalls(stub func(openapi.ApiListIntegrationsRequest) (*openapi.ListIntegrationsResponse, *http.Response, error)) {
	fake.listIntegrationsExecuteMutex.Lock()
	defer fake.listIntegrationsExecuteMutex.Unlock()
	fake.ListIntegrationsExecuteStub = stub
}

func (fake *FakeIntegrationsApi) ListIntegrationsExecuteArgsForCall(i int) openapi.ApiListIntegrationsRequest {
	fake.listIntegrationsExecuteMutex.RLock()
	defer fake.listIntegrationsExecuteMutex.RUnlock()
	argsForCall := fake.listIntegrationsExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIntegrationsApi) ListIntegrationsExecuteReturns(result1 *openapi.ListIntegrationsResponse, result2 *http.Response, result3 error) {
	fake.listIntegrationsExecuteMutex.Lock()
	defer fake.listIntegrationsExecuteMutex.Unlock()
	fake.ListIntegrationsExecuteStub = nil
	fake.listIntegrationsExecuteReturns = struct {
		result1 *openapi.ListIntegrationsResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIntegrationsApi) ListIntegrationsExecuteReturnsOnCall(i int, result1 *openapi.ListIntegrationsResponse, result2 *http.Response, result3 error) {
	fake.listIntegrationsExecuteMutex.Lock()
	defer fake.listIntegrationsExecuteMutex.Unlock()
	fake.ListIntegrationsExecuteStub = nil
	if fake.listIntegrationsExecuteReturnsOnCall == nil {
		fake.listIntegrationsExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.ListIntegrationsResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.listIntegrationsExecuteReturnsOnCall[i] = struct {
		result1 *openapi.ListIntegrationsResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIntegrationsApi) UpdateIntegration(arg1 context.Context, arg2 string) openapi.ApiUpdateIntegrationRequest {
	fake.updateIntegrationMutex.Lock()
	ret, specificReturn := fake.updateIntegrationReturnsOnCall[len(fake.updateIntegrationArgsForCall)]
	fake.updateIntegrationArgsForCall = append(fake.updateIntegrationArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.UpdateIntegrationStub
	fakeReturns := fake.updateIntegrationReturns
	fake.recordInvocation("UpdateIntegration", []interface{}{arg1, arg2})
	fake.updateIntegrationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIntegrationsApi) UpdateIntegrationCallCount() int {
	fake.updateIntegrationMutex.RLock()
	defer fake.updateIntegrationMutex.RUnlock()
	return len(fake.updateIntegrationArgsForCall)
}

func (fake *FakeIntegrationsApi) UpdateIntegrationCalls(stub func(context.Context, string) openapi.ApiUpdateIntegrationRequest) {
	fake.updateIntegrationMutex.Lock()
	defer fake.updateIntegrationMutex.Unlock()
	fake.UpdateIntegrationStub = stub
}

func (fake *FakeIntegrationsApi) UpdateIntegrationArgsForCall(i int) (context.Context, string) {
	fake.updateIntegrationMutex.RLock()
	defer fake.updateIntegrationMutex.RUnlock()
	argsForCall := fake.updateIntegrationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIntegrationsApi) UpdateIntegrationReturns(result1 openapi.ApiUpdateIntegrationRequest) {
	fake.updateIntegrationMutex.Lock()
	defer fake.updateIntegrationMutex.Unlock()
	fake.UpdateIntegrationStub = nil
	fake.updateIntegrationReturns = struct {
		result1 openapi.ApiUpdateIntegrationRequest
	}{result1}
}

func (fake *FakeIntegrationsApi) UpdateIntegrationReturnsOnCall(i int, result1 openapi.ApiUpdateIntegrationRequest) {
	fake.updateIntegrationMutex.Lock()
	defer fake.updateIntegrationMutex.Unlock()
	fake.UpdateIntegrationStub = nil
	if fake.updateIntegrationReturnsOnCall == nil {
		fake.updateIntegrationReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiUpdateIntegrationRequest
		})
	}
	fake.updateIntegrationReturnsOnCall[i] = struct {
		result1 openapi.ApiUpdateIntegrationRequest
	}{result1}
}

func (fake *FakeIntegrationsApi) UpdateIntegrationExecute(arg1 openapi.ApiUpdateIntegrationRequest) (*openapi.UpdateIntegrationResponse, *http.Response, error) {
	fake.updateIntegrationExecuteMutex.Lock()
	ret, specificReturn := fake.updateIntegrationExecuteReturnsOnCall[len(fake.updateIntegrationExecuteArgsForCall)]
	fake.updateIntegrationExecuteArgsForCall = append(fake.updateIntegrationExecuteArgsForCall, struct {
		arg1 openapi.ApiUpdateIntegrationRequest
	}{arg1})
	stub := fake.UpdateIntegrationExecuteStub
	fakeReturns := fake.updateIntegrationExecuteReturns
	fake.recordInvocation("UpdateIntegrationExecute", []interface{}{arg1})
	fake.updateIntegrationExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeIntegrationsApi) UpdateIntegrationExecuteCallCount() int {
	fake.updateIntegrationExecuteMutex.RLock()
	defer fake.updateIntegrationExecuteMutex.RUnlock()
	return len(fake.updateIntegrationExecuteArgsForCall)
}

func (fake *FakeIntegrationsApi) UpdateIntegrationExecuteCalls(stub func(openapi.ApiUpdateIntegrationRequest) (*openapi.UpdateIntegrationResponse, *http.Response, error)) {
	fake.updateIntegrationExecuteMutex.Lock()
	defer fake.updateIntegrationExecuteMutex.Unlock()
	fake.UpdateIntegrationExecuteStub = stub
}

func (fake *FakeIntegrationsApi) UpdateIntegrationExecuteArgsForCall(i int) openapi.ApiUpdateIntegrationRequest {
	fake.updateIntegrationExecuteMutex.RLock()
	defer fake.updateIntegrationExecuteMutex.RUnlock()
	argsForCall := fake.updateIntegrationExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIntegrationsApi) UpdateIntegrationExecuteReturns(result1 *openapi.UpdateIntegrationResponse, result2 *http.Response, result3 error) {
	fake.updateIntegrationExecuteMutex.Lock()
	defer fake.updateIntegrationExecuteMutex.Unlock()
	fake.UpdateIntegrationExecuteStub = nil
	fake.updateIntegrationExecuteReturns = struct {
		result1 *openapi.UpdateIntegrationResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIntegrationsApi) UpdateIntegrationExecuteReturnsOnCall(i int, result1 *openapi.UpdateIntegrationResponse, result2 *http.Response, result3 error) {
	fake.updateIntegrationExecuteMutex.Lock()
	defer fake.updateIntegrationExecuteMutex.Unlock()
	fake.UpdateIntegrationExecuteStub = nil
	if fake.updateIntegrationExecuteReturnsOnCall == nil {
		fake.updateIntegrationExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.UpdateIntegrationResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.updateIntegrationExecuteReturnsOnCall[i] = struct {
		result1 *openapi.UpdateIntegrationResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIntegrationsApi) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createIntegrationMutex.RLock()
	defer fake.createIntegrationMutex.RUnlock()
	fake.createIntegrationExecuteMutex.RLock()
	defer fake.createIntegrationExecuteMutex.RUnlock()
	fake.deleteIntegrationMutex.RLock()
	defer fake.deleteIntegrationMutex.RUnlock()
	fake.deleteIntegrationExecuteMutex.RLock()
	defer fake.deleteIntegrationExecuteMutex.RUnlock()
	fake.getIntegrationMutex.RLock()
	defer fake.getIntegrationMutex.RUnlock()
	fake.getIntegrationExecuteMutex.RLock()
	defer fake.getIntegrationExecuteMutex.RUnlock()
	fake.listIntegrationsMutex.RLock()
	defer fake.listIntegrationsMutex.RUnlock()
	fake.listIntegrationsExecuteMutex.RLock()
	defer fake.listIntegrationsExecuteMutex.RUnlock()
	fake.updateIntegrationMutex.RLock()
	defer fake.updateIntegrationMutex.RUnlock()
	fake.updateIntegrationExecuteMutex.RLock()
	defer fake.updateIntegrationExecuteMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeIntegrationsApi) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ openapi.IntegrationsApi = new(FakeIntegrationsApi)
