// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"context"
	"net/http"
	"sync"

	"github.com/rockset/rockset-go-client/openapi"
)

type FakeWorkspacesApi struct {
	CreateWorkspaceStub        func(context.Context) openapi.ApiCreateWorkspaceRequest
	createWorkspaceMutex       sync.RWMutex
	createWorkspaceArgsForCall []struct {
		arg1 context.Context
	}
	createWorkspaceReturns struct {
		result1 openapi.ApiCreateWorkspaceRequest
	}
	createWorkspaceReturnsOnCall map[int]struct {
		result1 openapi.ApiCreateWorkspaceRequest
	}
	CreateWorkspaceExecuteStub        func(openapi.ApiCreateWorkspaceRequest) (*openapi.CreateWorkspaceResponse, *http.Response, error)
	createWorkspaceExecuteMutex       sync.RWMutex
	createWorkspaceExecuteArgsForCall []struct {
		arg1 openapi.ApiCreateWorkspaceRequest
	}
	createWorkspaceExecuteReturns struct {
		result1 *openapi.CreateWorkspaceResponse
		result2 *http.Response
		result3 error
	}
	createWorkspaceExecuteReturnsOnCall map[int]struct {
		result1 *openapi.CreateWorkspaceResponse
		result2 *http.Response
		result3 error
	}
	DeleteWorkspaceStub        func(context.Context, string) openapi.ApiDeleteWorkspaceRequest
	deleteWorkspaceMutex       sync.RWMutex
	deleteWorkspaceArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	deleteWorkspaceReturns struct {
		result1 openapi.ApiDeleteWorkspaceRequest
	}
	deleteWorkspaceReturnsOnCall map[int]struct {
		result1 openapi.ApiDeleteWorkspaceRequest
	}
	DeleteWorkspaceExecuteStub        func(openapi.ApiDeleteWorkspaceRequest) (*openapi.DeleteWorkspaceResponse, *http.Response, error)
	deleteWorkspaceExecuteMutex       sync.RWMutex
	deleteWorkspaceExecuteArgsForCall []struct {
		arg1 openapi.ApiDeleteWorkspaceRequest
	}
	deleteWorkspaceExecuteReturns struct {
		result1 *openapi.DeleteWorkspaceResponse
		result2 *http.Response
		result3 error
	}
	deleteWorkspaceExecuteReturnsOnCall map[int]struct {
		result1 *openapi.DeleteWorkspaceResponse
		result2 *http.Response
		result3 error
	}
	GetWorkspaceStub        func(context.Context, string) openapi.ApiGetWorkspaceRequest
	getWorkspaceMutex       sync.RWMutex
	getWorkspaceArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getWorkspaceReturns struct {
		result1 openapi.ApiGetWorkspaceRequest
	}
	getWorkspaceReturnsOnCall map[int]struct {
		result1 openapi.ApiGetWorkspaceRequest
	}
	GetWorkspaceExecuteStub        func(openapi.ApiGetWorkspaceRequest) (*openapi.GetWorkspaceResponse, *http.Response, error)
	getWorkspaceExecuteMutex       sync.RWMutex
	getWorkspaceExecuteArgsForCall []struct {
		arg1 openapi.ApiGetWorkspaceRequest
	}
	getWorkspaceExecuteReturns struct {
		result1 *openapi.GetWorkspaceResponse
		result2 *http.Response
		result3 error
	}
	getWorkspaceExecuteReturnsOnCall map[int]struct {
		result1 *openapi.GetWorkspaceResponse
		result2 *http.Response
		result3 error
	}
	ListWorkspacesStub        func(context.Context) openapi.ApiListWorkspacesRequest
	listWorkspacesMutex       sync.RWMutex
	listWorkspacesArgsForCall []struct {
		arg1 context.Context
	}
	listWorkspacesReturns struct {
		result1 openapi.ApiListWorkspacesRequest
	}
	listWorkspacesReturnsOnCall map[int]struct {
		result1 openapi.ApiListWorkspacesRequest
	}
	ListWorkspacesExecuteStub        func(openapi.ApiListWorkspacesRequest) (*openapi.ListWorkspacesResponse, *http.Response, error)
	listWorkspacesExecuteMutex       sync.RWMutex
	listWorkspacesExecuteArgsForCall []struct {
		arg1 openapi.ApiListWorkspacesRequest
	}
	listWorkspacesExecuteReturns struct {
		result1 *openapi.ListWorkspacesResponse
		result2 *http.Response
		result3 error
	}
	listWorkspacesExecuteReturnsOnCall map[int]struct {
		result1 *openapi.ListWorkspacesResponse
		result2 *http.Response
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeWorkspacesApi) CreateWorkspace(arg1 context.Context) openapi.ApiCreateWorkspaceRequest {
	fake.createWorkspaceMutex.Lock()
	ret, specificReturn := fake.createWorkspaceReturnsOnCall[len(fake.createWorkspaceArgsForCall)]
	fake.createWorkspaceArgsForCall = append(fake.createWorkspaceArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.CreateWorkspaceStub
	fakeReturns := fake.createWorkspaceReturns
	fake.recordInvocation("CreateWorkspace", []interface{}{arg1})
	fake.createWorkspaceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorkspacesApi) CreateWorkspaceCallCount() int {
	fake.createWorkspaceMutex.RLock()
	defer fake.createWorkspaceMutex.RUnlock()
	return len(fake.createWorkspaceArgsForCall)
}

func (fake *FakeWorkspacesApi) CreateWorkspaceCalls(stub func(context.Context) openapi.ApiCreateWorkspaceRequest) {
	fake.createWorkspaceMutex.Lock()
	defer fake.createWorkspaceMutex.Unlock()
	fake.CreateWorkspaceStub = stub
}

func (fake *FakeWorkspacesApi) CreateWorkspaceArgsForCall(i int) context.Context {
	fake.createWorkspaceMutex.RLock()
	defer fake.createWorkspaceMutex.RUnlock()
	argsForCall := fake.createWorkspaceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWorkspacesApi) CreateWorkspaceReturns(result1 openapi.ApiCreateWorkspaceRequest) {
	fake.createWorkspaceMutex.Lock()
	defer fake.createWorkspaceMutex.Unlock()
	fake.CreateWorkspaceStub = nil
	fake.createWorkspaceReturns = struct {
		result1 openapi.ApiCreateWorkspaceRequest
	}{result1}
}

func (fake *FakeWorkspacesApi) CreateWorkspaceReturnsOnCall(i int, result1 openapi.ApiCreateWorkspaceRequest) {
	fake.createWorkspaceMutex.Lock()
	defer fake.createWorkspaceMutex.Unlock()
	fake.CreateWorkspaceStub = nil
	if fake.createWorkspaceReturnsOnCall == nil {
		fake.createWorkspaceReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiCreateWorkspaceRequest
		})
	}
	fake.createWorkspaceReturnsOnCall[i] = struct {
		result1 openapi.ApiCreateWorkspaceRequest
	}{result1}
}

func (fake *FakeWorkspacesApi) CreateWorkspaceExecute(arg1 openapi.ApiCreateWorkspaceRequest) (*openapi.CreateWorkspaceResponse, *http.Response, error) {
	fake.createWorkspaceExecuteMutex.Lock()
	ret, specificReturn := fake.createWorkspaceExecuteReturnsOnCall[len(fake.createWorkspaceExecuteArgsForCall)]
	fake.createWorkspaceExecuteArgsForCall = append(fake.createWorkspaceExecuteArgsForCall, struct {
		arg1 openapi.ApiCreateWorkspaceRequest
	}{arg1})
	stub := fake.CreateWorkspaceExecuteStub
	fakeReturns := fake.createWorkspaceExecuteReturns
	fake.recordInvocation("CreateWorkspaceExecute", []interface{}{arg1})
	fake.createWorkspaceExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeWorkspacesApi) CreateWorkspaceExecuteCallCount() int {
	fake.createWorkspaceExecuteMutex.RLock()
	defer fake.createWorkspaceExecuteMutex.RUnlock()
	return len(fake.createWorkspaceExecuteArgsForCall)
}

func (fake *FakeWorkspacesApi) CreateWorkspaceExecuteCalls(stub func(openapi.ApiCreateWorkspaceRequest) (*openapi.CreateWorkspaceResponse, *http.Response, error)) {
	fake.createWorkspaceExecuteMutex.Lock()
	defer fake.createWorkspaceExecuteMutex.Unlock()
	fake.CreateWorkspaceExecuteStub = stub
}

func (fake *FakeWorkspacesApi) CreateWorkspaceExecuteArgsForCall(i int) openapi.ApiCreateWorkspaceRequest {
	fake.createWorkspaceExecuteMutex.RLock()
	defer fake.createWorkspaceExecuteMutex.RUnlock()
	argsForCall := fake.createWorkspaceExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWorkspacesApi) CreateWorkspaceExecuteReturns(result1 *openapi.CreateWorkspaceResponse, result2 *http.Response, result3 error) {
	fake.createWorkspaceExecuteMutex.Lock()
	defer fake.createWorkspaceExecuteMutex.Unlock()
	fake.CreateWorkspaceExecuteStub = nil
	fake.createWorkspaceExecuteReturns = struct {
		result1 *openapi.CreateWorkspaceResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorkspacesApi) CreateWorkspaceExecuteReturnsOnCall(i int, result1 *openapi.CreateWorkspaceResponse, result2 *http.Response, result3 error) {
	fake.createWorkspaceExecuteMutex.Lock()
	defer fake.createWorkspaceExecuteMutex.Unlock()
	fake.CreateWorkspaceExecuteStub = nil
	if fake.createWorkspaceExecuteReturnsOnCall == nil {
		fake.createWorkspaceExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.CreateWorkspaceResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.createWorkspaceExecuteReturnsOnCall[i] = struct {
		result1 *openapi.CreateWorkspaceResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorkspacesApi) DeleteWorkspace(arg1 context.Context, arg2 string) openapi.ApiDeleteWorkspaceRequest {
	fake.deleteWorkspaceMutex.Lock()
	ret, specificReturn := fake.deleteWorkspaceReturnsOnCall[len(fake.deleteWorkspaceArgsForCall)]
	fake.deleteWorkspaceArgsForCall = append(fake.deleteWorkspaceArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteWorkspaceStub
	fakeReturns := fake.deleteWorkspaceReturns
	fake.recordInvocation("DeleteWorkspace", []interface{}{arg1, arg2})
	fake.deleteWorkspaceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorkspacesApi) DeleteWorkspaceCallCount() int {
	fake.deleteWorkspaceMutex.RLock()
	defer fake.deleteWorkspaceMutex.RUnlock()
	return len(fake.deleteWorkspaceArgsForCall)
}

func (fake *FakeWorkspacesApi) DeleteWorkspaceCalls(stub func(context.Context, string) openapi.ApiDeleteWorkspaceRequest) {
	fake.deleteWorkspaceMutex.Lock()
	defer fake.deleteWorkspaceMutex.Unlock()
	fake.DeleteWorkspaceStub = stub
}

func (fake *FakeWorkspacesApi) DeleteWorkspaceArgsForCall(i int) (context.Context, string) {
	fake.deleteWorkspaceMutex.RLock()
	defer fake.deleteWorkspaceMutex.RUnlock()
	argsForCall := fake.deleteWorkspaceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorkspacesApi) DeleteWorkspaceReturns(result1 openapi.ApiDeleteWorkspaceRequest) {
	fake.deleteWorkspaceMutex.Lock()
	defer fake.deleteWorkspaceMutex.Unlock()
	fake.DeleteWorkspaceStub = nil
	fake.deleteWorkspaceReturns = struct {
		result1 openapi.ApiDeleteWorkspaceRequest
	}{result1}
}

func (fake *FakeWorkspacesApi) DeleteWorkspaceReturnsOnCall(i int, result1 openapi.ApiDeleteWorkspaceRequest) {
	fake.deleteWorkspaceMutex.Lock()
	defer fake.deleteWorkspaceMutex.Unlock()
	fake.DeleteWorkspaceStub = nil
	if fake.deleteWorkspaceReturnsOnCall == nil {
		fake.deleteWorkspaceReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiDeleteWorkspaceRequest
		})
	}
	fake.deleteWorkspaceReturnsOnCall[i] = struct {
		result1 openapi.ApiDeleteWorkspaceRequest
	}{result1}
}

func (fake *FakeWorkspacesApi) DeleteWorkspaceExecute(arg1 openapi.ApiDeleteWorkspaceRequest) (*openapi.DeleteWorkspaceResponse, *http.Response, error) {
	fake.deleteWorkspaceExecuteMutex.Lock()
	ret, specificReturn := fake.deleteWorkspaceExecuteReturnsOnCall[len(fake.deleteWorkspaceExecuteArgsForCall)]
	fake.deleteWorkspaceExecuteArgsForCall = append(fake.deleteWorkspaceExecuteArgsForCall, struct {
		arg1 openapi.ApiDeleteWorkspaceRequest
	}{arg1})
	stub := fake.DeleteWorkspaceExecuteStub
	fakeReturns := fake.deleteWorkspaceExecuteReturns
	fake.recordInvocation("DeleteWorkspaceExecute", []interface{}{arg1})
	fake.deleteWorkspaceExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeWorkspacesApi) DeleteWorkspaceExecuteCallCount() int {
	fake.deleteWorkspaceExecuteMutex.RLock()
	defer fake.deleteWorkspaceExecuteMutex.RUnlock()
	return len(fake.deleteWorkspaceExecuteArgsForCall)
}

func (fake *FakeWorkspacesApi) DeleteWorkspaceExecuteCalls(stub func(openapi.ApiDeleteWorkspaceRequest) (*openapi.DeleteWorkspaceResponse, *http.Response, error)) {
	fake.deleteWorkspaceExecuteMutex.Lock()
	defer fake.deleteWorkspaceExecuteMutex.Unlock()
	fake.DeleteWorkspaceExecuteStub = stub
}

func (fake *FakeWorkspacesApi) DeleteWorkspaceExecuteArgsForCall(i int) openapi.ApiDeleteWorkspaceRequest {
	fake.deleteWorkspaceExecuteMutex.RLock()
	defer fake.deleteWorkspaceExecuteMutex.RUnlock()
	argsForCall := fake.deleteWorkspaceExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWorkspacesApi) DeleteWorkspaceExecuteReturns(result1 *openapi.DeleteWorkspaceResponse, result2 *http.Response, result3 error) {
	fake.deleteWorkspaceExecuteMutex.Lock()
	defer fake.deleteWorkspaceExecuteMutex.Unlock()
	fake.DeleteWorkspaceExecuteStub = nil
	fake.deleteWorkspaceExecuteReturns = struct {
		result1 *openapi.DeleteWorkspaceResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorkspacesApi) DeleteWorkspaceExecuteReturnsOnCall(i int, result1 *openapi.DeleteWorkspaceResponse, result2 *http.Response, result3 error) {
	fake.deleteWorkspaceExecuteMutex.Lock()
	defer fake.deleteWorkspaceExecuteMutex.Unlock()
	fake.DeleteWorkspaceExecuteStub = nil
	if fake.deleteWorkspaceExecuteReturnsOnCall == nil {
		fake.deleteWorkspaceExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.DeleteWorkspaceResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.deleteWorkspaceExecuteReturnsOnCall[i] = struct {
		result1 *openapi.DeleteWorkspaceResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorkspacesApi) GetWorkspace(arg1 context.Context, arg2 string) openapi.ApiGetWorkspaceRequest {
	fake.getWorkspaceMutex.Lock()
	ret, specificReturn := fake.getWorkspaceReturnsOnCall[len(fake.getWorkspaceArgsForCall)]
	fake.getWorkspaceArgsForCall = append(fake.getWorkspaceArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetWorkspaceStub
	fakeReturns := fake.getWorkspaceReturns
	fake.recordInvocation("GetWorkspace", []interface{}{arg1, arg2})
	fake.getWorkspaceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorkspacesApi) GetWorkspaceCallCount() int {
	fake.getWorkspaceMutex.RLock()
	defer fake.getWorkspaceMutex.RUnlock()
	return len(fake.getWorkspaceArgsForCall)
}

func (fake *FakeWorkspacesApi) GetWorkspaceCalls(stub func(context.Context, string) openapi.ApiGetWorkspaceRequest) {
	fake.getWorkspaceMutex.Lock()
	defer fake.getWorkspaceMutex.Unlock()
	fake.GetWorkspaceStub = stub
}

func (fake *FakeWorkspacesApi) GetWorkspaceArgsForCall(i int) (context.Context, string) {
	fake.getWorkspaceMutex.RLock()
	defer fake.getWorkspaceMutex.RUnlock()
	argsForCall := fake.getWorkspaceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorkspacesApi) GetWorkspaceReturns(result1 openapi.ApiGetWorkspaceRequest) {
	fake.getWorkspaceMutex.Lock()
	defer fake.getWorkspaceMutex.Unlock()
	fake.GetWorkspaceStub = nil
	fake.getWorkspaceReturns = struct {
		result1 openapi.ApiGetWorkspaceRequest
	}{result1}
}

func (fake *FakeWorkspacesApi) GetWorkspaceReturnsOnCall(i int, result1 openapi.ApiGetWorkspaceRequest) {
	fake.getWorkspaceMutex.Lock()
	defer fake.getWorkspaceMutex.Unlock()
	fake.GetWorkspaceStub = nil
	if fake.getWorkspaceReturnsOnCall == nil {
		fake.getWorkspaceReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiGetWorkspaceRequest
		})
	}
	fake.getWorkspaceReturnsOnCall[i] = struct {
		result1 openapi.ApiGetWorkspaceRequest
	}{result1}
}

func (fake *FakeWorkspacesApi) GetWorkspaceExecute(arg1 openapi.ApiGetWorkspaceRequest) (*openapi.GetWorkspaceResponse, *http.Response, error) {
	fake.getWorkspaceExecuteMutex.Lock()
	ret, specificReturn := fake.getWorkspaceExecuteReturnsOnCall[len(fake.getWorkspaceExecuteArgsForCall)]
	fake.getWorkspaceExecuteArgsForCall = append(fake.getWorkspaceExecuteArgsForCall, struct {
		arg1 openapi.ApiGetWorkspaceRequest
	}{arg1})
	stub := fake.GetWorkspaceExecuteStub
	fakeReturns := fake.getWorkspaceExecuteReturns
	fake.recordInvocation("GetWorkspaceExecute", []interface{}{arg1})
	fake.getWorkspaceExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeWorkspacesApi) GetWorkspaceExecuteCallCount() int {
	fake.getWorkspaceExecuteMutex.RLock()
	defer fake.getWorkspaceExecuteMutex.RUnlock()
	return len(fake.getWorkspaceExecuteArgsForCall)
}

func (fake *FakeWorkspacesApi) GetWorkspaceExecuteCalls(stub func(openapi.ApiGetWorkspaceRequest) (*openapi.GetWorkspaceResponse, *http.Response, error)) {
	fake.getWorkspaceExecuteMutex.Lock()
	defer fake.getWorkspaceExecuteMutex.Unlock()
	fake.GetWorkspaceExecuteStub = stub
}

func (fake *FakeWorkspacesApi) GetWorkspaceExecuteArgsForCall(i int) openapi.ApiGetWorkspaceRequest {
	fake.getWorkspaceExecuteMutex.RLock()
	defer fake.getWorkspaceExecuteMutex.RUnlock()
	argsForCall := fake.getWorkspaceExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWorkspacesApi) GetWorkspaceExecuteReturns(result1 *openapi.GetWorkspaceResponse, result2 *http.Response, result3 error) {
	fake.getWorkspaceExecuteMutex.Lock()
	defer fake.getWorkspaceExecuteMutex.Unlock()
	fake.GetWorkspaceExecuteStub = nil
	fake.getWorkspaceExecuteReturns = struct {
		result1 *openapi.GetWorkspaceResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorkspacesApi) GetWorkspaceExecuteReturnsOnCall(i int, result1 *openapi.GetWorkspaceResponse, result2 *http.Response, result3 error) {
	fake.getWorkspaceExecuteMutex.Lock()
	defer fake.getWorkspaceExecuteMutex.Unlock()
	fake.GetWorkspaceExecuteStub = nil
	if fake.getWorkspaceExecuteReturnsOnCall == nil {
		fake.getWorkspaceExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.GetWorkspaceResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.getWorkspaceExecuteReturnsOnCall[i] = struct {
		result1 *openapi.GetWorkspaceResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorkspacesApi) ListWorkspaces(arg1 context.Context) openapi.ApiListWorkspacesRequest {
	fake.listWorkspacesMutex.Lock()
	ret, specificReturn := fake.listWorkspacesReturnsOnCall[len(fake.listWorkspacesArgsForCall)]
	fake.listWorkspacesArgsForCall = append(fake.listWorkspacesArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ListWorkspacesStub
	fakeReturns := fake.listWorkspacesReturns
	fake.recordInvocation("ListWorkspaces", []interface{}{arg1})
	fake.listWorkspacesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorkspacesApi) ListWorkspacesCallCount() int {
	fake.listWorkspacesMutex.RLock()
	defer fake.listWorkspacesMutex.RUnlock()
	return len(fake.listWorkspacesArgsForCall)
}

func (fake *FakeWorkspacesApi) ListWorkspacesCalls(stub func(context.Context) openapi.ApiListWorkspacesRequest) {
	fake.listWorkspacesMutex.Lock()
	defer fake.listWorkspacesMutex.Unlock()
	fake.ListWorkspacesStub = stub
}

func (fake *FakeWorkspacesApi) ListWorkspacesArgsForCall(i int) context.Context {
	fake.listWorkspacesMutex.RLock()
	defer fake.listWorkspacesMutex.RUnlock()
	argsForCall := fake.listWorkspacesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWorkspacesApi) ListWorkspacesReturns(result1 openapi.ApiListWorkspacesRequest) {
	fake.listWorkspacesMutex.Lock()
	defer fake.listWorkspacesMutex.Unlock()
	fake.ListWorkspacesStub = nil
	fake.listWorkspacesReturns = struct {
		result1 openapi.ApiListWorkspacesRequest
	}{result1}
}

func (fake *FakeWorkspacesApi) ListWorkspacesReturnsOnCall(i int, result1 openapi.ApiListWorkspacesRequest) {
	fake.listWorkspacesMutex.Lock()
	defer fake.listWorkspacesMutex.Unlock()
	fake.ListWorkspacesStub = nil
	if fake.listWorkspacesReturnsOnCall == nil {
		fake.listWorkspacesReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiListWorkspacesRequest
		})
	}
	fake.listWorkspacesReturnsOnCall[i] = struct {
		result1 openapi.ApiListWorkspacesRequest
	}{result1}
}

func (fake *FakeWorkspacesApi) ListWorkspacesExecute(arg1 openapi.ApiListWorkspacesRequest) (*openapi.ListWorkspacesResponse, *http.Response, error) {
	fake.listWorkspacesExecuteMutex.Lock()
	ret, specificReturn := fake.listWorkspacesExecuteReturnsOnCall[len(fake.listWorkspacesExecuteArgsForCall)]
	fake.listWorkspacesExecuteArgsForCall = append(fake.listWorkspacesExecuteArgsForCall, struct {
		arg1 openapi.ApiListWorkspacesRequest
	}{arg1})
	stub := fake.ListWorkspacesExecuteStub
	fakeReturns := fake.listWorkspacesExecuteReturns
	fake.recordInvocation("ListWorkspacesExecute", []interface{}{arg1})
	fake.listWorkspacesExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeWorkspacesApi) ListWorkspacesExecuteCallCount() int {
	fake.listWorkspacesExecuteMutex.RLock()
	defer fake.listWorkspacesExecuteMutex.RUnlock()
	return len(fake.listWorkspacesExecuteArgsForCall)
}

func (fake *FakeWorkspacesApi) ListWorkspacesExecuteCalls(stub func(openapi.ApiListWorkspacesRequest) (*openapi.ListWorkspacesResponse, *http.Response, error)) {
	fake.listWorkspacesExecuteMutex.Lock()
	defer fake.listWorkspacesExecuteMutex.Unlock()
	fake.ListWorkspacesExecuteStub = stub
}

func (fake *FakeWorkspacesApi) ListWorkspacesExecuteArgsForCall(i int) openapi.ApiListWorkspacesRequest {
	fake.listWorkspacesExecuteMutex.RLock()
	defer fake.listWorkspacesExecuteMutex.RUnlock()
	argsForCall := fake.listWorkspacesExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWorkspacesApi) ListWorkspacesExecuteReturns(result1 *openapi.ListWorkspacesResponse, result2 *http.Response, result3 error) {
	fake.listWorkspacesExecuteMutex.Lock()
	defer fake.listWorkspacesExecuteMutex.Unlock()
	fake.ListWorkspacesExecuteStub = nil
	fake.listWorkspacesExecuteReturns = struct {
		result1 *openapi.ListWorkspacesResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorkspacesApi) ListWorkspacesExecuteReturnsOnCall(i int, result1 *openapi.ListWorkspacesResponse, result2 *http.Response, result3 error) {
	fake.listWorkspacesExecuteMutex.Lock()
	defer fake.listWorkspacesExecuteMutex.Unlock()
	fake.ListWorkspacesExecuteStub = nil
	if fake.listWorkspacesExecuteReturnsOnCall == nil {
		fake.listWorkspacesExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.ListWorkspacesResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.listWorkspacesExecuteReturnsOnCall[i] = struct {
		result1 *openapi.ListWorkspacesResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorkspacesApi) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createWorkspaceMutex.RLock()
	defer fake.createWorkspaceMutex.RUnlock()
	fake.createWorkspaceExecuteMutex.RLock()
	defer fake.createWorkspaceExecuteMutex.RUnlock()
	fake.deleteWorkspaceMutex.RLock()
	defer fake.deleteWorkspaceMutex.RUnlock()
	fake.deleteWorkspaceExecuteMutex.RLock()
	defer fake.deleteWorkspaceExecuteMutex.RUnlock()
	fake.getWorkspaceMutex.RLock()
	defer fake.getWorkspaceMutex.RUnlock()
	fake.getWorkspaceExecuteMutex.RLock()
	defer fake.getWorkspaceExecuteMutex.RUnlock()
	fake.listWorkspacesMutex.RLock()
	defer fake.listWorkspacesMutex.RUnlock()
	fake.listWorkspacesExecuteMutex.RLock()
	defer fake.listWorkspacesExecuteMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeWorkspacesApi) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ openapi.WorkspacesApi = new(FakeWorkspacesApi)
