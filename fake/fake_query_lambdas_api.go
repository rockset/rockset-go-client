// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"context"
	"net/http"
	"sync"

	"github.com/rockset/rockset-go-client/openapi"
)

type FakeQueryLambdasApi struct {
	CreateQueryLambdaStub        func(context.Context, string) openapi.ApiCreateQueryLambdaRequest
	createQueryLambdaMutex       sync.RWMutex
	createQueryLambdaArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	createQueryLambdaReturns struct {
		result1 openapi.ApiCreateQueryLambdaRequest
	}
	createQueryLambdaReturnsOnCall map[int]struct {
		result1 openapi.ApiCreateQueryLambdaRequest
	}
	CreateQueryLambdaExecuteStub        func(openapi.ApiCreateQueryLambdaRequest) (*openapi.QueryLambdaVersionResponse, *http.Response, error)
	createQueryLambdaExecuteMutex       sync.RWMutex
	createQueryLambdaExecuteArgsForCall []struct {
		arg1 openapi.ApiCreateQueryLambdaRequest
	}
	createQueryLambdaExecuteReturns struct {
		result1 *openapi.QueryLambdaVersionResponse
		result2 *http.Response
		result3 error
	}
	createQueryLambdaExecuteReturnsOnCall map[int]struct {
		result1 *openapi.QueryLambdaVersionResponse
		result2 *http.Response
		result3 error
	}
	CreateQueryLambdaTagStub        func(context.Context, string, string) openapi.ApiCreateQueryLambdaTagRequest
	createQueryLambdaTagMutex       sync.RWMutex
	createQueryLambdaTagArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	createQueryLambdaTagReturns struct {
		result1 openapi.ApiCreateQueryLambdaTagRequest
	}
	createQueryLambdaTagReturnsOnCall map[int]struct {
		result1 openapi.ApiCreateQueryLambdaTagRequest
	}
	CreateQueryLambdaTagExecuteStub        func(openapi.ApiCreateQueryLambdaTagRequest) (*openapi.QueryLambdaTagResponse, *http.Response, error)
	createQueryLambdaTagExecuteMutex       sync.RWMutex
	createQueryLambdaTagExecuteArgsForCall []struct {
		arg1 openapi.ApiCreateQueryLambdaTagRequest
	}
	createQueryLambdaTagExecuteReturns struct {
		result1 *openapi.QueryLambdaTagResponse
		result2 *http.Response
		result3 error
	}
	createQueryLambdaTagExecuteReturnsOnCall map[int]struct {
		result1 *openapi.QueryLambdaTagResponse
		result2 *http.Response
		result3 error
	}
	DeleteQueryLambdaStub        func(context.Context, string, string) openapi.ApiDeleteQueryLambdaRequest
	deleteQueryLambdaMutex       sync.RWMutex
	deleteQueryLambdaArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	deleteQueryLambdaReturns struct {
		result1 openapi.ApiDeleteQueryLambdaRequest
	}
	deleteQueryLambdaReturnsOnCall map[int]struct {
		result1 openapi.ApiDeleteQueryLambdaRequest
	}
	DeleteQueryLambdaExecuteStub        func(openapi.ApiDeleteQueryLambdaRequest) (*openapi.DeleteQueryLambdaResponse, *http.Response, error)
	deleteQueryLambdaExecuteMutex       sync.RWMutex
	deleteQueryLambdaExecuteArgsForCall []struct {
		arg1 openapi.ApiDeleteQueryLambdaRequest
	}
	deleteQueryLambdaExecuteReturns struct {
		result1 *openapi.DeleteQueryLambdaResponse
		result2 *http.Response
		result3 error
	}
	deleteQueryLambdaExecuteReturnsOnCall map[int]struct {
		result1 *openapi.DeleteQueryLambdaResponse
		result2 *http.Response
		result3 error
	}
	DeleteQueryLambdaTagStub        func(context.Context, string, string, string) openapi.ApiDeleteQueryLambdaTagRequest
	deleteQueryLambdaTagMutex       sync.RWMutex
	deleteQueryLambdaTagArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	deleteQueryLambdaTagReturns struct {
		result1 openapi.ApiDeleteQueryLambdaTagRequest
	}
	deleteQueryLambdaTagReturnsOnCall map[int]struct {
		result1 openapi.ApiDeleteQueryLambdaTagRequest
	}
	DeleteQueryLambdaTagExecuteStub        func(openapi.ApiDeleteQueryLambdaTagRequest) (*openapi.QueryLambdaTagResponse, *http.Response, error)
	deleteQueryLambdaTagExecuteMutex       sync.RWMutex
	deleteQueryLambdaTagExecuteArgsForCall []struct {
		arg1 openapi.ApiDeleteQueryLambdaTagRequest
	}
	deleteQueryLambdaTagExecuteReturns struct {
		result1 *openapi.QueryLambdaTagResponse
		result2 *http.Response
		result3 error
	}
	deleteQueryLambdaTagExecuteReturnsOnCall map[int]struct {
		result1 *openapi.QueryLambdaTagResponse
		result2 *http.Response
		result3 error
	}
	DeleteQueryLambdaVersionStub        func(context.Context, string, string, string) openapi.ApiDeleteQueryLambdaVersionRequest
	deleteQueryLambdaVersionMutex       sync.RWMutex
	deleteQueryLambdaVersionArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	deleteQueryLambdaVersionReturns struct {
		result1 openapi.ApiDeleteQueryLambdaVersionRequest
	}
	deleteQueryLambdaVersionReturnsOnCall map[int]struct {
		result1 openapi.ApiDeleteQueryLambdaVersionRequest
	}
	DeleteQueryLambdaVersionExecuteStub        func(openapi.ApiDeleteQueryLambdaVersionRequest) (*openapi.QueryLambdaVersionResponse, *http.Response, error)
	deleteQueryLambdaVersionExecuteMutex       sync.RWMutex
	deleteQueryLambdaVersionExecuteArgsForCall []struct {
		arg1 openapi.ApiDeleteQueryLambdaVersionRequest
	}
	deleteQueryLambdaVersionExecuteReturns struct {
		result1 *openapi.QueryLambdaVersionResponse
		result2 *http.Response
		result3 error
	}
	deleteQueryLambdaVersionExecuteReturnsOnCall map[int]struct {
		result1 *openapi.QueryLambdaVersionResponse
		result2 *http.Response
		result3 error
	}
	ExecuteQueryLambdaStub        func(context.Context, string, string, string) openapi.ApiExecuteQueryLambdaRequest
	executeQueryLambdaMutex       sync.RWMutex
	executeQueryLambdaArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	executeQueryLambdaReturns struct {
		result1 openapi.ApiExecuteQueryLambdaRequest
	}
	executeQueryLambdaReturnsOnCall map[int]struct {
		result1 openapi.ApiExecuteQueryLambdaRequest
	}
	ExecuteQueryLambdaByTagStub        func(context.Context, string, string, string) openapi.ApiExecuteQueryLambdaByTagRequest
	executeQueryLambdaByTagMutex       sync.RWMutex
	executeQueryLambdaByTagArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	executeQueryLambdaByTagReturns struct {
		result1 openapi.ApiExecuteQueryLambdaByTagRequest
	}
	executeQueryLambdaByTagReturnsOnCall map[int]struct {
		result1 openapi.ApiExecuteQueryLambdaByTagRequest
	}
	ExecuteQueryLambdaByTagExecuteStub        func(openapi.ApiExecuteQueryLambdaByTagRequest) (*openapi.QueryResponse, *http.Response, error)
	executeQueryLambdaByTagExecuteMutex       sync.RWMutex
	executeQueryLambdaByTagExecuteArgsForCall []struct {
		arg1 openapi.ApiExecuteQueryLambdaByTagRequest
	}
	executeQueryLambdaByTagExecuteReturns struct {
		result1 *openapi.QueryResponse
		result2 *http.Response
		result3 error
	}
	executeQueryLambdaByTagExecuteReturnsOnCall map[int]struct {
		result1 *openapi.QueryResponse
		result2 *http.Response
		result3 error
	}
	ExecuteQueryLambdaExecuteStub        func(openapi.ApiExecuteQueryLambdaRequest) (*openapi.QueryResponse, *http.Response, error)
	executeQueryLambdaExecuteMutex       sync.RWMutex
	executeQueryLambdaExecuteArgsForCall []struct {
		arg1 openapi.ApiExecuteQueryLambdaRequest
	}
	executeQueryLambdaExecuteReturns struct {
		result1 *openapi.QueryResponse
		result2 *http.Response
		result3 error
	}
	executeQueryLambdaExecuteReturnsOnCall map[int]struct {
		result1 *openapi.QueryResponse
		result2 *http.Response
		result3 error
	}
	GetQueryLambdaTagVersionStub        func(context.Context, string, string, string) openapi.ApiGetQueryLambdaTagVersionRequest
	getQueryLambdaTagVersionMutex       sync.RWMutex
	getQueryLambdaTagVersionArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	getQueryLambdaTagVersionReturns struct {
		result1 openapi.ApiGetQueryLambdaTagVersionRequest
	}
	getQueryLambdaTagVersionReturnsOnCall map[int]struct {
		result1 openapi.ApiGetQueryLambdaTagVersionRequest
	}
	GetQueryLambdaTagVersionExecuteStub        func(openapi.ApiGetQueryLambdaTagVersionRequest) (*openapi.QueryLambdaTagResponse, *http.Response, error)
	getQueryLambdaTagVersionExecuteMutex       sync.RWMutex
	getQueryLambdaTagVersionExecuteArgsForCall []struct {
		arg1 openapi.ApiGetQueryLambdaTagVersionRequest
	}
	getQueryLambdaTagVersionExecuteReturns struct {
		result1 *openapi.QueryLambdaTagResponse
		result2 *http.Response
		result3 error
	}
	getQueryLambdaTagVersionExecuteReturnsOnCall map[int]struct {
		result1 *openapi.QueryLambdaTagResponse
		result2 *http.Response
		result3 error
	}
	GetQueryLambdaVersionStub        func(context.Context, string, string, string) openapi.ApiGetQueryLambdaVersionRequest
	getQueryLambdaVersionMutex       sync.RWMutex
	getQueryLambdaVersionArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	getQueryLambdaVersionReturns struct {
		result1 openapi.ApiGetQueryLambdaVersionRequest
	}
	getQueryLambdaVersionReturnsOnCall map[int]struct {
		result1 openapi.ApiGetQueryLambdaVersionRequest
	}
	GetQueryLambdaVersionExecuteStub        func(openapi.ApiGetQueryLambdaVersionRequest) (*openapi.QueryLambdaVersionResponse, *http.Response, error)
	getQueryLambdaVersionExecuteMutex       sync.RWMutex
	getQueryLambdaVersionExecuteArgsForCall []struct {
		arg1 openapi.ApiGetQueryLambdaVersionRequest
	}
	getQueryLambdaVersionExecuteReturns struct {
		result1 *openapi.QueryLambdaVersionResponse
		result2 *http.Response
		result3 error
	}
	getQueryLambdaVersionExecuteReturnsOnCall map[int]struct {
		result1 *openapi.QueryLambdaVersionResponse
		result2 *http.Response
		result3 error
	}
	ListAllQueryLambdasStub        func(context.Context) openapi.ApiListAllQueryLambdasRequest
	listAllQueryLambdasMutex       sync.RWMutex
	listAllQueryLambdasArgsForCall []struct {
		arg1 context.Context
	}
	listAllQueryLambdasReturns struct {
		result1 openapi.ApiListAllQueryLambdasRequest
	}
	listAllQueryLambdasReturnsOnCall map[int]struct {
		result1 openapi.ApiListAllQueryLambdasRequest
	}
	ListAllQueryLambdasExecuteStub        func(openapi.ApiListAllQueryLambdasRequest) (*openapi.ListQueryLambdasResponse, *http.Response, error)
	listAllQueryLambdasExecuteMutex       sync.RWMutex
	listAllQueryLambdasExecuteArgsForCall []struct {
		arg1 openapi.ApiListAllQueryLambdasRequest
	}
	listAllQueryLambdasExecuteReturns struct {
		result1 *openapi.ListQueryLambdasResponse
		result2 *http.Response
		result3 error
	}
	listAllQueryLambdasExecuteReturnsOnCall map[int]struct {
		result1 *openapi.ListQueryLambdasResponse
		result2 *http.Response
		result3 error
	}
	ListQueryLambdaTagsStub        func(context.Context, string, string) openapi.ApiListQueryLambdaTagsRequest
	listQueryLambdaTagsMutex       sync.RWMutex
	listQueryLambdaTagsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	listQueryLambdaTagsReturns struct {
		result1 openapi.ApiListQueryLambdaTagsRequest
	}
	listQueryLambdaTagsReturnsOnCall map[int]struct {
		result1 openapi.ApiListQueryLambdaTagsRequest
	}
	ListQueryLambdaTagsExecuteStub        func(openapi.ApiListQueryLambdaTagsRequest) (*openapi.ListQueryLambdaTagsResponse, *http.Response, error)
	listQueryLambdaTagsExecuteMutex       sync.RWMutex
	listQueryLambdaTagsExecuteArgsForCall []struct {
		arg1 openapi.ApiListQueryLambdaTagsRequest
	}
	listQueryLambdaTagsExecuteReturns struct {
		result1 *openapi.ListQueryLambdaTagsResponse
		result2 *http.Response
		result3 error
	}
	listQueryLambdaTagsExecuteReturnsOnCall map[int]struct {
		result1 *openapi.ListQueryLambdaTagsResponse
		result2 *http.Response
		result3 error
	}
	ListQueryLambdaVersionsStub        func(context.Context, string, string) openapi.ApiListQueryLambdaVersionsRequest
	listQueryLambdaVersionsMutex       sync.RWMutex
	listQueryLambdaVersionsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	listQueryLambdaVersionsReturns struct {
		result1 openapi.ApiListQueryLambdaVersionsRequest
	}
	listQueryLambdaVersionsReturnsOnCall map[int]struct {
		result1 openapi.ApiListQueryLambdaVersionsRequest
	}
	ListQueryLambdaVersionsExecuteStub        func(openapi.ApiListQueryLambdaVersionsRequest) (*openapi.ListQueryLambdaVersionsResponse, *http.Response, error)
	listQueryLambdaVersionsExecuteMutex       sync.RWMutex
	listQueryLambdaVersionsExecuteArgsForCall []struct {
		arg1 openapi.ApiListQueryLambdaVersionsRequest
	}
	listQueryLambdaVersionsExecuteReturns struct {
		result1 *openapi.ListQueryLambdaVersionsResponse
		result2 *http.Response
		result3 error
	}
	listQueryLambdaVersionsExecuteReturnsOnCall map[int]struct {
		result1 *openapi.ListQueryLambdaVersionsResponse
		result2 *http.Response
		result3 error
	}
	ListQueryLambdasInWorkspaceStub        func(context.Context, string) openapi.ApiListQueryLambdasInWorkspaceRequest
	listQueryLambdasInWorkspaceMutex       sync.RWMutex
	listQueryLambdasInWorkspaceArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	listQueryLambdasInWorkspaceReturns struct {
		result1 openapi.ApiListQueryLambdasInWorkspaceRequest
	}
	listQueryLambdasInWorkspaceReturnsOnCall map[int]struct {
		result1 openapi.ApiListQueryLambdasInWorkspaceRequest
	}
	ListQueryLambdasInWorkspaceExecuteStub        func(openapi.ApiListQueryLambdasInWorkspaceRequest) (*openapi.ListQueryLambdasResponse, *http.Response, error)
	listQueryLambdasInWorkspaceExecuteMutex       sync.RWMutex
	listQueryLambdasInWorkspaceExecuteArgsForCall []struct {
		arg1 openapi.ApiListQueryLambdasInWorkspaceRequest
	}
	listQueryLambdasInWorkspaceExecuteReturns struct {
		result1 *openapi.ListQueryLambdasResponse
		result2 *http.Response
		result3 error
	}
	listQueryLambdasInWorkspaceExecuteReturnsOnCall map[int]struct {
		result1 *openapi.ListQueryLambdasResponse
		result2 *http.Response
		result3 error
	}
	UpdateQueryLambdaStub        func(context.Context, string, string) openapi.ApiUpdateQueryLambdaRequest
	updateQueryLambdaMutex       sync.RWMutex
	updateQueryLambdaArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	updateQueryLambdaReturns struct {
		result1 openapi.ApiUpdateQueryLambdaRequest
	}
	updateQueryLambdaReturnsOnCall map[int]struct {
		result1 openapi.ApiUpdateQueryLambdaRequest
	}
	UpdateQueryLambdaExecuteStub        func(openapi.ApiUpdateQueryLambdaRequest) (*openapi.QueryLambdaVersionResponse, *http.Response, error)
	updateQueryLambdaExecuteMutex       sync.RWMutex
	updateQueryLambdaExecuteArgsForCall []struct {
		arg1 openapi.ApiUpdateQueryLambdaRequest
	}
	updateQueryLambdaExecuteReturns struct {
		result1 *openapi.QueryLambdaVersionResponse
		result2 *http.Response
		result3 error
	}
	updateQueryLambdaExecuteReturnsOnCall map[int]struct {
		result1 *openapi.QueryLambdaVersionResponse
		result2 *http.Response
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeQueryLambdasApi) CreateQueryLambda(arg1 context.Context, arg2 string) openapi.ApiCreateQueryLambdaRequest {
	fake.createQueryLambdaMutex.Lock()
	ret, specificReturn := fake.createQueryLambdaReturnsOnCall[len(fake.createQueryLambdaArgsForCall)]
	fake.createQueryLambdaArgsForCall = append(fake.createQueryLambdaArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.CreateQueryLambdaStub
	fakeReturns := fake.createQueryLambdaReturns
	fake.recordInvocation("CreateQueryLambda", []interface{}{arg1, arg2})
	fake.createQueryLambdaMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQueryLambdasApi) CreateQueryLambdaCallCount() int {
	fake.createQueryLambdaMutex.RLock()
	defer fake.createQueryLambdaMutex.RUnlock()
	return len(fake.createQueryLambdaArgsForCall)
}

func (fake *FakeQueryLambdasApi) CreateQueryLambdaCalls(stub func(context.Context, string) openapi.ApiCreateQueryLambdaRequest) {
	fake.createQueryLambdaMutex.Lock()
	defer fake.createQueryLambdaMutex.Unlock()
	fake.CreateQueryLambdaStub = stub
}

func (fake *FakeQueryLambdasApi) CreateQueryLambdaArgsForCall(i int) (context.Context, string) {
	fake.createQueryLambdaMutex.RLock()
	defer fake.createQueryLambdaMutex.RUnlock()
	argsForCall := fake.createQueryLambdaArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQueryLambdasApi) CreateQueryLambdaReturns(result1 openapi.ApiCreateQueryLambdaRequest) {
	fake.createQueryLambdaMutex.Lock()
	defer fake.createQueryLambdaMutex.Unlock()
	fake.CreateQueryLambdaStub = nil
	fake.createQueryLambdaReturns = struct {
		result1 openapi.ApiCreateQueryLambdaRequest
	}{result1}
}

func (fake *FakeQueryLambdasApi) CreateQueryLambdaReturnsOnCall(i int, result1 openapi.ApiCreateQueryLambdaRequest) {
	fake.createQueryLambdaMutex.Lock()
	defer fake.createQueryLambdaMutex.Unlock()
	fake.CreateQueryLambdaStub = nil
	if fake.createQueryLambdaReturnsOnCall == nil {
		fake.createQueryLambdaReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiCreateQueryLambdaRequest
		})
	}
	fake.createQueryLambdaReturnsOnCall[i] = struct {
		result1 openapi.ApiCreateQueryLambdaRequest
	}{result1}
}

func (fake *FakeQueryLambdasApi) CreateQueryLambdaExecute(arg1 openapi.ApiCreateQueryLambdaRequest) (*openapi.QueryLambdaVersionResponse, *http.Response, error) {
	fake.createQueryLambdaExecuteMutex.Lock()
	ret, specificReturn := fake.createQueryLambdaExecuteReturnsOnCall[len(fake.createQueryLambdaExecuteArgsForCall)]
	fake.createQueryLambdaExecuteArgsForCall = append(fake.createQueryLambdaExecuteArgsForCall, struct {
		arg1 openapi.ApiCreateQueryLambdaRequest
	}{arg1})
	stub := fake.CreateQueryLambdaExecuteStub
	fakeReturns := fake.createQueryLambdaExecuteReturns
	fake.recordInvocation("CreateQueryLambdaExecute", []interface{}{arg1})
	fake.createQueryLambdaExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeQueryLambdasApi) CreateQueryLambdaExecuteCallCount() int {
	fake.createQueryLambdaExecuteMutex.RLock()
	defer fake.createQueryLambdaExecuteMutex.RUnlock()
	return len(fake.createQueryLambdaExecuteArgsForCall)
}

func (fake *FakeQueryLambdasApi) CreateQueryLambdaExecuteCalls(stub func(openapi.ApiCreateQueryLambdaRequest) (*openapi.QueryLambdaVersionResponse, *http.Response, error)) {
	fake.createQueryLambdaExecuteMutex.Lock()
	defer fake.createQueryLambdaExecuteMutex.Unlock()
	fake.CreateQueryLambdaExecuteStub = stub
}

func (fake *FakeQueryLambdasApi) CreateQueryLambdaExecuteArgsForCall(i int) openapi.ApiCreateQueryLambdaRequest {
	fake.createQueryLambdaExecuteMutex.RLock()
	defer fake.createQueryLambdaExecuteMutex.RUnlock()
	argsForCall := fake.createQueryLambdaExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQueryLambdasApi) CreateQueryLambdaExecuteReturns(result1 *openapi.QueryLambdaVersionResponse, result2 *http.Response, result3 error) {
	fake.createQueryLambdaExecuteMutex.Lock()
	defer fake.createQueryLambdaExecuteMutex.Unlock()
	fake.CreateQueryLambdaExecuteStub = nil
	fake.createQueryLambdaExecuteReturns = struct {
		result1 *openapi.QueryLambdaVersionResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueryLambdasApi) CreateQueryLambdaExecuteReturnsOnCall(i int, result1 *openapi.QueryLambdaVersionResponse, result2 *http.Response, result3 error) {
	fake.createQueryLambdaExecuteMutex.Lock()
	defer fake.createQueryLambdaExecuteMutex.Unlock()
	fake.CreateQueryLambdaExecuteStub = nil
	if fake.createQueryLambdaExecuteReturnsOnCall == nil {
		fake.createQueryLambdaExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.QueryLambdaVersionResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.createQueryLambdaExecuteReturnsOnCall[i] = struct {
		result1 *openapi.QueryLambdaVersionResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueryLambdasApi) CreateQueryLambdaTag(arg1 context.Context, arg2 string, arg3 string) openapi.ApiCreateQueryLambdaTagRequest {
	fake.createQueryLambdaTagMutex.Lock()
	ret, specificReturn := fake.createQueryLambdaTagReturnsOnCall[len(fake.createQueryLambdaTagArgsForCall)]
	fake.createQueryLambdaTagArgsForCall = append(fake.createQueryLambdaTagArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.CreateQueryLambdaTagStub
	fakeReturns := fake.createQueryLambdaTagReturns
	fake.recordInvocation("CreateQueryLambdaTag", []interface{}{arg1, arg2, arg3})
	fake.createQueryLambdaTagMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQueryLambdasApi) CreateQueryLambdaTagCallCount() int {
	fake.createQueryLambdaTagMutex.RLock()
	defer fake.createQueryLambdaTagMutex.RUnlock()
	return len(fake.createQueryLambdaTagArgsForCall)
}

func (fake *FakeQueryLambdasApi) CreateQueryLambdaTagCalls(stub func(context.Context, string, string) openapi.ApiCreateQueryLambdaTagRequest) {
	fake.createQueryLambdaTagMutex.Lock()
	defer fake.createQueryLambdaTagMutex.Unlock()
	fake.CreateQueryLambdaTagStub = stub
}

func (fake *FakeQueryLambdasApi) CreateQueryLambdaTagArgsForCall(i int) (context.Context, string, string) {
	fake.createQueryLambdaTagMutex.RLock()
	defer fake.createQueryLambdaTagMutex.RUnlock()
	argsForCall := fake.createQueryLambdaTagArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeQueryLambdasApi) CreateQueryLambdaTagReturns(result1 openapi.ApiCreateQueryLambdaTagRequest) {
	fake.createQueryLambdaTagMutex.Lock()
	defer fake.createQueryLambdaTagMutex.Unlock()
	fake.CreateQueryLambdaTagStub = nil
	fake.createQueryLambdaTagReturns = struct {
		result1 openapi.ApiCreateQueryLambdaTagRequest
	}{result1}
}

func (fake *FakeQueryLambdasApi) CreateQueryLambdaTagReturnsOnCall(i int, result1 openapi.ApiCreateQueryLambdaTagRequest) {
	fake.createQueryLambdaTagMutex.Lock()
	defer fake.createQueryLambdaTagMutex.Unlock()
	fake.CreateQueryLambdaTagStub = nil
	if fake.createQueryLambdaTagReturnsOnCall == nil {
		fake.createQueryLambdaTagReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiCreateQueryLambdaTagRequest
		})
	}
	fake.createQueryLambdaTagReturnsOnCall[i] = struct {
		result1 openapi.ApiCreateQueryLambdaTagRequest
	}{result1}
}

func (fake *FakeQueryLambdasApi) CreateQueryLambdaTagExecute(arg1 openapi.ApiCreateQueryLambdaTagRequest) (*openapi.QueryLambdaTagResponse, *http.Response, error) {
	fake.createQueryLambdaTagExecuteMutex.Lock()
	ret, specificReturn := fake.createQueryLambdaTagExecuteReturnsOnCall[len(fake.createQueryLambdaTagExecuteArgsForCall)]
	fake.createQueryLambdaTagExecuteArgsForCall = append(fake.createQueryLambdaTagExecuteArgsForCall, struct {
		arg1 openapi.ApiCreateQueryLambdaTagRequest
	}{arg1})
	stub := fake.CreateQueryLambdaTagExecuteStub
	fakeReturns := fake.createQueryLambdaTagExecuteReturns
	fake.recordInvocation("CreateQueryLambdaTagExecute", []interface{}{arg1})
	fake.createQueryLambdaTagExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeQueryLambdasApi) CreateQueryLambdaTagExecuteCallCount() int {
	fake.createQueryLambdaTagExecuteMutex.RLock()
	defer fake.createQueryLambdaTagExecuteMutex.RUnlock()
	return len(fake.createQueryLambdaTagExecuteArgsForCall)
}

func (fake *FakeQueryLambdasApi) CreateQueryLambdaTagExecuteCalls(stub func(openapi.ApiCreateQueryLambdaTagRequest) (*openapi.QueryLambdaTagResponse, *http.Response, error)) {
	fake.createQueryLambdaTagExecuteMutex.Lock()
	defer fake.createQueryLambdaTagExecuteMutex.Unlock()
	fake.CreateQueryLambdaTagExecuteStub = stub
}

func (fake *FakeQueryLambdasApi) CreateQueryLambdaTagExecuteArgsForCall(i int) openapi.ApiCreateQueryLambdaTagRequest {
	fake.createQueryLambdaTagExecuteMutex.RLock()
	defer fake.createQueryLambdaTagExecuteMutex.RUnlock()
	argsForCall := fake.createQueryLambdaTagExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQueryLambdasApi) CreateQueryLambdaTagExecuteReturns(result1 *openapi.QueryLambdaTagResponse, result2 *http.Response, result3 error) {
	fake.createQueryLambdaTagExecuteMutex.Lock()
	defer fake.createQueryLambdaTagExecuteMutex.Unlock()
	fake.CreateQueryLambdaTagExecuteStub = nil
	fake.createQueryLambdaTagExecuteReturns = struct {
		result1 *openapi.QueryLambdaTagResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueryLambdasApi) CreateQueryLambdaTagExecuteReturnsOnCall(i int, result1 *openapi.QueryLambdaTagResponse, result2 *http.Response, result3 error) {
	fake.createQueryLambdaTagExecuteMutex.Lock()
	defer fake.createQueryLambdaTagExecuteMutex.Unlock()
	fake.CreateQueryLambdaTagExecuteStub = nil
	if fake.createQueryLambdaTagExecuteReturnsOnCall == nil {
		fake.createQueryLambdaTagExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.QueryLambdaTagResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.createQueryLambdaTagExecuteReturnsOnCall[i] = struct {
		result1 *openapi.QueryLambdaTagResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambda(arg1 context.Context, arg2 string, arg3 string) openapi.ApiDeleteQueryLambdaRequest {
	fake.deleteQueryLambdaMutex.Lock()
	ret, specificReturn := fake.deleteQueryLambdaReturnsOnCall[len(fake.deleteQueryLambdaArgsForCall)]
	fake.deleteQueryLambdaArgsForCall = append(fake.deleteQueryLambdaArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.DeleteQueryLambdaStub
	fakeReturns := fake.deleteQueryLambdaReturns
	fake.recordInvocation("DeleteQueryLambda", []interface{}{arg1, arg2, arg3})
	fake.deleteQueryLambdaMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaCallCount() int {
	fake.deleteQueryLambdaMutex.RLock()
	defer fake.deleteQueryLambdaMutex.RUnlock()
	return len(fake.deleteQueryLambdaArgsForCall)
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaCalls(stub func(context.Context, string, string) openapi.ApiDeleteQueryLambdaRequest) {
	fake.deleteQueryLambdaMutex.Lock()
	defer fake.deleteQueryLambdaMutex.Unlock()
	fake.DeleteQueryLambdaStub = stub
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaArgsForCall(i int) (context.Context, string, string) {
	fake.deleteQueryLambdaMutex.RLock()
	defer fake.deleteQueryLambdaMutex.RUnlock()
	argsForCall := fake.deleteQueryLambdaArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaReturns(result1 openapi.ApiDeleteQueryLambdaRequest) {
	fake.deleteQueryLambdaMutex.Lock()
	defer fake.deleteQueryLambdaMutex.Unlock()
	fake.DeleteQueryLambdaStub = nil
	fake.deleteQueryLambdaReturns = struct {
		result1 openapi.ApiDeleteQueryLambdaRequest
	}{result1}
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaReturnsOnCall(i int, result1 openapi.ApiDeleteQueryLambdaRequest) {
	fake.deleteQueryLambdaMutex.Lock()
	defer fake.deleteQueryLambdaMutex.Unlock()
	fake.DeleteQueryLambdaStub = nil
	if fake.deleteQueryLambdaReturnsOnCall == nil {
		fake.deleteQueryLambdaReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiDeleteQueryLambdaRequest
		})
	}
	fake.deleteQueryLambdaReturnsOnCall[i] = struct {
		result1 openapi.ApiDeleteQueryLambdaRequest
	}{result1}
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaExecute(arg1 openapi.ApiDeleteQueryLambdaRequest) (*openapi.DeleteQueryLambdaResponse, *http.Response, error) {
	fake.deleteQueryLambdaExecuteMutex.Lock()
	ret, specificReturn := fake.deleteQueryLambdaExecuteReturnsOnCall[len(fake.deleteQueryLambdaExecuteArgsForCall)]
	fake.deleteQueryLambdaExecuteArgsForCall = append(fake.deleteQueryLambdaExecuteArgsForCall, struct {
		arg1 openapi.ApiDeleteQueryLambdaRequest
	}{arg1})
	stub := fake.DeleteQueryLambdaExecuteStub
	fakeReturns := fake.deleteQueryLambdaExecuteReturns
	fake.recordInvocation("DeleteQueryLambdaExecute", []interface{}{arg1})
	fake.deleteQueryLambdaExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaExecuteCallCount() int {
	fake.deleteQueryLambdaExecuteMutex.RLock()
	defer fake.deleteQueryLambdaExecuteMutex.RUnlock()
	return len(fake.deleteQueryLambdaExecuteArgsForCall)
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaExecuteCalls(stub func(openapi.ApiDeleteQueryLambdaRequest) (*openapi.DeleteQueryLambdaResponse, *http.Response, error)) {
	fake.deleteQueryLambdaExecuteMutex.Lock()
	defer fake.deleteQueryLambdaExecuteMutex.Unlock()
	fake.DeleteQueryLambdaExecuteStub = stub
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaExecuteArgsForCall(i int) openapi.ApiDeleteQueryLambdaRequest {
	fake.deleteQueryLambdaExecuteMutex.RLock()
	defer fake.deleteQueryLambdaExecuteMutex.RUnlock()
	argsForCall := fake.deleteQueryLambdaExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaExecuteReturns(result1 *openapi.DeleteQueryLambdaResponse, result2 *http.Response, result3 error) {
	fake.deleteQueryLambdaExecuteMutex.Lock()
	defer fake.deleteQueryLambdaExecuteMutex.Unlock()
	fake.DeleteQueryLambdaExecuteStub = nil
	fake.deleteQueryLambdaExecuteReturns = struct {
		result1 *openapi.DeleteQueryLambdaResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaExecuteReturnsOnCall(i int, result1 *openapi.DeleteQueryLambdaResponse, result2 *http.Response, result3 error) {
	fake.deleteQueryLambdaExecuteMutex.Lock()
	defer fake.deleteQueryLambdaExecuteMutex.Unlock()
	fake.DeleteQueryLambdaExecuteStub = nil
	if fake.deleteQueryLambdaExecuteReturnsOnCall == nil {
		fake.deleteQueryLambdaExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.DeleteQueryLambdaResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.deleteQueryLambdaExecuteReturnsOnCall[i] = struct {
		result1 *openapi.DeleteQueryLambdaResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaTag(arg1 context.Context, arg2 string, arg3 string, arg4 string) openapi.ApiDeleteQueryLambdaTagRequest {
	fake.deleteQueryLambdaTagMutex.Lock()
	ret, specificReturn := fake.deleteQueryLambdaTagReturnsOnCall[len(fake.deleteQueryLambdaTagArgsForCall)]
	fake.deleteQueryLambdaTagArgsForCall = append(fake.deleteQueryLambdaTagArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.DeleteQueryLambdaTagStub
	fakeReturns := fake.deleteQueryLambdaTagReturns
	fake.recordInvocation("DeleteQueryLambdaTag", []interface{}{arg1, arg2, arg3, arg4})
	fake.deleteQueryLambdaTagMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaTagCallCount() int {
	fake.deleteQueryLambdaTagMutex.RLock()
	defer fake.deleteQueryLambdaTagMutex.RUnlock()
	return len(fake.deleteQueryLambdaTagArgsForCall)
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaTagCalls(stub func(context.Context, string, string, string) openapi.ApiDeleteQueryLambdaTagRequest) {
	fake.deleteQueryLambdaTagMutex.Lock()
	defer fake.deleteQueryLambdaTagMutex.Unlock()
	fake.DeleteQueryLambdaTagStub = stub
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaTagArgsForCall(i int) (context.Context, string, string, string) {
	fake.deleteQueryLambdaTagMutex.RLock()
	defer fake.deleteQueryLambdaTagMutex.RUnlock()
	argsForCall := fake.deleteQueryLambdaTagArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaTagReturns(result1 openapi.ApiDeleteQueryLambdaTagRequest) {
	fake.deleteQueryLambdaTagMutex.Lock()
	defer fake.deleteQueryLambdaTagMutex.Unlock()
	fake.DeleteQueryLambdaTagStub = nil
	fake.deleteQueryLambdaTagReturns = struct {
		result1 openapi.ApiDeleteQueryLambdaTagRequest
	}{result1}
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaTagReturnsOnCall(i int, result1 openapi.ApiDeleteQueryLambdaTagRequest) {
	fake.deleteQueryLambdaTagMutex.Lock()
	defer fake.deleteQueryLambdaTagMutex.Unlock()
	fake.DeleteQueryLambdaTagStub = nil
	if fake.deleteQueryLambdaTagReturnsOnCall == nil {
		fake.deleteQueryLambdaTagReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiDeleteQueryLambdaTagRequest
		})
	}
	fake.deleteQueryLambdaTagReturnsOnCall[i] = struct {
		result1 openapi.ApiDeleteQueryLambdaTagRequest
	}{result1}
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaTagExecute(arg1 openapi.ApiDeleteQueryLambdaTagRequest) (*openapi.QueryLambdaTagResponse, *http.Response, error) {
	fake.deleteQueryLambdaTagExecuteMutex.Lock()
	ret, specificReturn := fake.deleteQueryLambdaTagExecuteReturnsOnCall[len(fake.deleteQueryLambdaTagExecuteArgsForCall)]
	fake.deleteQueryLambdaTagExecuteArgsForCall = append(fake.deleteQueryLambdaTagExecuteArgsForCall, struct {
		arg1 openapi.ApiDeleteQueryLambdaTagRequest
	}{arg1})
	stub := fake.DeleteQueryLambdaTagExecuteStub
	fakeReturns := fake.deleteQueryLambdaTagExecuteReturns
	fake.recordInvocation("DeleteQueryLambdaTagExecute", []interface{}{arg1})
	fake.deleteQueryLambdaTagExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaTagExecuteCallCount() int {
	fake.deleteQueryLambdaTagExecuteMutex.RLock()
	defer fake.deleteQueryLambdaTagExecuteMutex.RUnlock()
	return len(fake.deleteQueryLambdaTagExecuteArgsForCall)
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaTagExecuteCalls(stub func(openapi.ApiDeleteQueryLambdaTagRequest) (*openapi.QueryLambdaTagResponse, *http.Response, error)) {
	fake.deleteQueryLambdaTagExecuteMutex.Lock()
	defer fake.deleteQueryLambdaTagExecuteMutex.Unlock()
	fake.DeleteQueryLambdaTagExecuteStub = stub
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaTagExecuteArgsForCall(i int) openapi.ApiDeleteQueryLambdaTagRequest {
	fake.deleteQueryLambdaTagExecuteMutex.RLock()
	defer fake.deleteQueryLambdaTagExecuteMutex.RUnlock()
	argsForCall := fake.deleteQueryLambdaTagExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaTagExecuteReturns(result1 *openapi.QueryLambdaTagResponse, result2 *http.Response, result3 error) {
	fake.deleteQueryLambdaTagExecuteMutex.Lock()
	defer fake.deleteQueryLambdaTagExecuteMutex.Unlock()
	fake.DeleteQueryLambdaTagExecuteStub = nil
	fake.deleteQueryLambdaTagExecuteReturns = struct {
		result1 *openapi.QueryLambdaTagResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaTagExecuteReturnsOnCall(i int, result1 *openapi.QueryLambdaTagResponse, result2 *http.Response, result3 error) {
	fake.deleteQueryLambdaTagExecuteMutex.Lock()
	defer fake.deleteQueryLambdaTagExecuteMutex.Unlock()
	fake.DeleteQueryLambdaTagExecuteStub = nil
	if fake.deleteQueryLambdaTagExecuteReturnsOnCall == nil {
		fake.deleteQueryLambdaTagExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.QueryLambdaTagResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.deleteQueryLambdaTagExecuteReturnsOnCall[i] = struct {
		result1 *openapi.QueryLambdaTagResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaVersion(arg1 context.Context, arg2 string, arg3 string, arg4 string) openapi.ApiDeleteQueryLambdaVersionRequest {
	fake.deleteQueryLambdaVersionMutex.Lock()
	ret, specificReturn := fake.deleteQueryLambdaVersionReturnsOnCall[len(fake.deleteQueryLambdaVersionArgsForCall)]
	fake.deleteQueryLambdaVersionArgsForCall = append(fake.deleteQueryLambdaVersionArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.DeleteQueryLambdaVersionStub
	fakeReturns := fake.deleteQueryLambdaVersionReturns
	fake.recordInvocation("DeleteQueryLambdaVersion", []interface{}{arg1, arg2, arg3, arg4})
	fake.deleteQueryLambdaVersionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaVersionCallCount() int {
	fake.deleteQueryLambdaVersionMutex.RLock()
	defer fake.deleteQueryLambdaVersionMutex.RUnlock()
	return len(fake.deleteQueryLambdaVersionArgsForCall)
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaVersionCalls(stub func(context.Context, string, string, string) openapi.ApiDeleteQueryLambdaVersionRequest) {
	fake.deleteQueryLambdaVersionMutex.Lock()
	defer fake.deleteQueryLambdaVersionMutex.Unlock()
	fake.DeleteQueryLambdaVersionStub = stub
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaVersionArgsForCall(i int) (context.Context, string, string, string) {
	fake.deleteQueryLambdaVersionMutex.RLock()
	defer fake.deleteQueryLambdaVersionMutex.RUnlock()
	argsForCall := fake.deleteQueryLambdaVersionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaVersionReturns(result1 openapi.ApiDeleteQueryLambdaVersionRequest) {
	fake.deleteQueryLambdaVersionMutex.Lock()
	defer fake.deleteQueryLambdaVersionMutex.Unlock()
	fake.DeleteQueryLambdaVersionStub = nil
	fake.deleteQueryLambdaVersionReturns = struct {
		result1 openapi.ApiDeleteQueryLambdaVersionRequest
	}{result1}
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaVersionReturnsOnCall(i int, result1 openapi.ApiDeleteQueryLambdaVersionRequest) {
	fake.deleteQueryLambdaVersionMutex.Lock()
	defer fake.deleteQueryLambdaVersionMutex.Unlock()
	fake.DeleteQueryLambdaVersionStub = nil
	if fake.deleteQueryLambdaVersionReturnsOnCall == nil {
		fake.deleteQueryLambdaVersionReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiDeleteQueryLambdaVersionRequest
		})
	}
	fake.deleteQueryLambdaVersionReturnsOnCall[i] = struct {
		result1 openapi.ApiDeleteQueryLambdaVersionRequest
	}{result1}
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaVersionExecute(arg1 openapi.ApiDeleteQueryLambdaVersionRequest) (*openapi.QueryLambdaVersionResponse, *http.Response, error) {
	fake.deleteQueryLambdaVersionExecuteMutex.Lock()
	ret, specificReturn := fake.deleteQueryLambdaVersionExecuteReturnsOnCall[len(fake.deleteQueryLambdaVersionExecuteArgsForCall)]
	fake.deleteQueryLambdaVersionExecuteArgsForCall = append(fake.deleteQueryLambdaVersionExecuteArgsForCall, struct {
		arg1 openapi.ApiDeleteQueryLambdaVersionRequest
	}{arg1})
	stub := fake.DeleteQueryLambdaVersionExecuteStub
	fakeReturns := fake.deleteQueryLambdaVersionExecuteReturns
	fake.recordInvocation("DeleteQueryLambdaVersionExecute", []interface{}{arg1})
	fake.deleteQueryLambdaVersionExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaVersionExecuteCallCount() int {
	fake.deleteQueryLambdaVersionExecuteMutex.RLock()
	defer fake.deleteQueryLambdaVersionExecuteMutex.RUnlock()
	return len(fake.deleteQueryLambdaVersionExecuteArgsForCall)
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaVersionExecuteCalls(stub func(openapi.ApiDeleteQueryLambdaVersionRequest) (*openapi.QueryLambdaVersionResponse, *http.Response, error)) {
	fake.deleteQueryLambdaVersionExecuteMutex.Lock()
	defer fake.deleteQueryLambdaVersionExecuteMutex.Unlock()
	fake.DeleteQueryLambdaVersionExecuteStub = stub
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaVersionExecuteArgsForCall(i int) openapi.ApiDeleteQueryLambdaVersionRequest {
	fake.deleteQueryLambdaVersionExecuteMutex.RLock()
	defer fake.deleteQueryLambdaVersionExecuteMutex.RUnlock()
	argsForCall := fake.deleteQueryLambdaVersionExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaVersionExecuteReturns(result1 *openapi.QueryLambdaVersionResponse, result2 *http.Response, result3 error) {
	fake.deleteQueryLambdaVersionExecuteMutex.Lock()
	defer fake.deleteQueryLambdaVersionExecuteMutex.Unlock()
	fake.DeleteQueryLambdaVersionExecuteStub = nil
	fake.deleteQueryLambdaVersionExecuteReturns = struct {
		result1 *openapi.QueryLambdaVersionResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueryLambdasApi) DeleteQueryLambdaVersionExecuteReturnsOnCall(i int, result1 *openapi.QueryLambdaVersionResponse, result2 *http.Response, result3 error) {
	fake.deleteQueryLambdaVersionExecuteMutex.Lock()
	defer fake.deleteQueryLambdaVersionExecuteMutex.Unlock()
	fake.DeleteQueryLambdaVersionExecuteStub = nil
	if fake.deleteQueryLambdaVersionExecuteReturnsOnCall == nil {
		fake.deleteQueryLambdaVersionExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.QueryLambdaVersionResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.deleteQueryLambdaVersionExecuteReturnsOnCall[i] = struct {
		result1 *openapi.QueryLambdaVersionResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueryLambdasApi) ExecuteQueryLambda(arg1 context.Context, arg2 string, arg3 string, arg4 string) openapi.ApiExecuteQueryLambdaRequest {
	fake.executeQueryLambdaMutex.Lock()
	ret, specificReturn := fake.executeQueryLambdaReturnsOnCall[len(fake.executeQueryLambdaArgsForCall)]
	fake.executeQueryLambdaArgsForCall = append(fake.executeQueryLambdaArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.ExecuteQueryLambdaStub
	fakeReturns := fake.executeQueryLambdaReturns
	fake.recordInvocation("ExecuteQueryLambda", []interface{}{arg1, arg2, arg3, arg4})
	fake.executeQueryLambdaMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQueryLambdasApi) ExecuteQueryLambdaCallCount() int {
	fake.executeQueryLambdaMutex.RLock()
	defer fake.executeQueryLambdaMutex.RUnlock()
	return len(fake.executeQueryLambdaArgsForCall)
}

func (fake *FakeQueryLambdasApi) ExecuteQueryLambdaCalls(stub func(context.Context, string, string, string) openapi.ApiExecuteQueryLambdaRequest) {
	fake.executeQueryLambdaMutex.Lock()
	defer fake.executeQueryLambdaMutex.Unlock()
	fake.ExecuteQueryLambdaStub = stub
}

func (fake *FakeQueryLambdasApi) ExecuteQueryLambdaArgsForCall(i int) (context.Context, string, string, string) {
	fake.executeQueryLambdaMutex.RLock()
	defer fake.executeQueryLambdaMutex.RUnlock()
	argsForCall := fake.executeQueryLambdaArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeQueryLambdasApi) ExecuteQueryLambdaReturns(result1 openapi.ApiExecuteQueryLambdaRequest) {
	fake.executeQueryLambdaMutex.Lock()
	defer fake.executeQueryLambdaMutex.Unlock()
	fake.ExecuteQueryLambdaStub = nil
	fake.executeQueryLambdaReturns = struct {
		result1 openapi.ApiExecuteQueryLambdaRequest
	}{result1}
}

func (fake *FakeQueryLambdasApi) ExecuteQueryLambdaReturnsOnCall(i int, result1 openapi.ApiExecuteQueryLambdaRequest) {
	fake.executeQueryLambdaMutex.Lock()
	defer fake.executeQueryLambdaMutex.Unlock()
	fake.ExecuteQueryLambdaStub = nil
	if fake.executeQueryLambdaReturnsOnCall == nil {
		fake.executeQueryLambdaReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiExecuteQueryLambdaRequest
		})
	}
	fake.executeQueryLambdaReturnsOnCall[i] = struct {
		result1 openapi.ApiExecuteQueryLambdaRequest
	}{result1}
}

func (fake *FakeQueryLambdasApi) ExecuteQueryLambdaByTag(arg1 context.Context, arg2 string, arg3 string, arg4 string) openapi.ApiExecuteQueryLambdaByTagRequest {
	fake.executeQueryLambdaByTagMutex.Lock()
	ret, specificReturn := fake.executeQueryLambdaByTagReturnsOnCall[len(fake.executeQueryLambdaByTagArgsForCall)]
	fake.executeQueryLambdaByTagArgsForCall = append(fake.executeQueryLambdaByTagArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.ExecuteQueryLambdaByTagStub
	fakeReturns := fake.executeQueryLambdaByTagReturns
	fake.recordInvocation("ExecuteQueryLambdaByTag", []interface{}{arg1, arg2, arg3, arg4})
	fake.executeQueryLambdaByTagMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQueryLambdasApi) ExecuteQueryLambdaByTagCallCount() int {
	fake.executeQueryLambdaByTagMutex.RLock()
	defer fake.executeQueryLambdaByTagMutex.RUnlock()
	return len(fake.executeQueryLambdaByTagArgsForCall)
}

func (fake *FakeQueryLambdasApi) ExecuteQueryLambdaByTagCalls(stub func(context.Context, string, string, string) openapi.ApiExecuteQueryLambdaByTagRequest) {
	fake.executeQueryLambdaByTagMutex.Lock()
	defer fake.executeQueryLambdaByTagMutex.Unlock()
	fake.ExecuteQueryLambdaByTagStub = stub
}

func (fake *FakeQueryLambdasApi) ExecuteQueryLambdaByTagArgsForCall(i int) (context.Context, string, string, string) {
	fake.executeQueryLambdaByTagMutex.RLock()
	defer fake.executeQueryLambdaByTagMutex.RUnlock()
	argsForCall := fake.executeQueryLambdaByTagArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeQueryLambdasApi) ExecuteQueryLambdaByTagReturns(result1 openapi.ApiExecuteQueryLambdaByTagRequest) {
	fake.executeQueryLambdaByTagMutex.Lock()
	defer fake.executeQueryLambdaByTagMutex.Unlock()
	fake.ExecuteQueryLambdaByTagStub = nil
	fake.executeQueryLambdaByTagReturns = struct {
		result1 openapi.ApiExecuteQueryLambdaByTagRequest
	}{result1}
}

func (fake *FakeQueryLambdasApi) ExecuteQueryLambdaByTagReturnsOnCall(i int, result1 openapi.ApiExecuteQueryLambdaByTagRequest) {
	fake.executeQueryLambdaByTagMutex.Lock()
	defer fake.executeQueryLambdaByTagMutex.Unlock()
	fake.ExecuteQueryLambdaByTagStub = nil
	if fake.executeQueryLambdaByTagReturnsOnCall == nil {
		fake.executeQueryLambdaByTagReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiExecuteQueryLambdaByTagRequest
		})
	}
	fake.executeQueryLambdaByTagReturnsOnCall[i] = struct {
		result1 openapi.ApiExecuteQueryLambdaByTagRequest
	}{result1}
}

func (fake *FakeQueryLambdasApi) ExecuteQueryLambdaByTagExecute(arg1 openapi.ApiExecuteQueryLambdaByTagRequest) (*openapi.QueryResponse, *http.Response, error) {
	fake.executeQueryLambdaByTagExecuteMutex.Lock()
	ret, specificReturn := fake.executeQueryLambdaByTagExecuteReturnsOnCall[len(fake.executeQueryLambdaByTagExecuteArgsForCall)]
	fake.executeQueryLambdaByTagExecuteArgsForCall = append(fake.executeQueryLambdaByTagExecuteArgsForCall, struct {
		arg1 openapi.ApiExecuteQueryLambdaByTagRequest
	}{arg1})
	stub := fake.ExecuteQueryLambdaByTagExecuteStub
	fakeReturns := fake.executeQueryLambdaByTagExecuteReturns
	fake.recordInvocation("ExecuteQueryLambdaByTagExecute", []interface{}{arg1})
	fake.executeQueryLambdaByTagExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeQueryLambdasApi) ExecuteQueryLambdaByTagExecuteCallCount() int {
	fake.executeQueryLambdaByTagExecuteMutex.RLock()
	defer fake.executeQueryLambdaByTagExecuteMutex.RUnlock()
	return len(fake.executeQueryLambdaByTagExecuteArgsForCall)
}

func (fake *FakeQueryLambdasApi) ExecuteQueryLambdaByTagExecuteCalls(stub func(openapi.ApiExecuteQueryLambdaByTagRequest) (*openapi.QueryResponse, *http.Response, error)) {
	fake.executeQueryLambdaByTagExecuteMutex.Lock()
	defer fake.executeQueryLambdaByTagExecuteMutex.Unlock()
	fake.ExecuteQueryLambdaByTagExecuteStub = stub
}

func (fake *FakeQueryLambdasApi) ExecuteQueryLambdaByTagExecuteArgsForCall(i int) openapi.ApiExecuteQueryLambdaByTagRequest {
	fake.executeQueryLambdaByTagExecuteMutex.RLock()
	defer fake.executeQueryLambdaByTagExecuteMutex.RUnlock()
	argsForCall := fake.executeQueryLambdaByTagExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQueryLambdasApi) ExecuteQueryLambdaByTagExecuteReturns(result1 *openapi.QueryResponse, result2 *http.Response, result3 error) {
	fake.executeQueryLambdaByTagExecuteMutex.Lock()
	defer fake.executeQueryLambdaByTagExecuteMutex.Unlock()
	fake.ExecuteQueryLambdaByTagExecuteStub = nil
	fake.executeQueryLambdaByTagExecuteReturns = struct {
		result1 *openapi.QueryResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueryLambdasApi) ExecuteQueryLambdaByTagExecuteReturnsOnCall(i int, result1 *openapi.QueryResponse, result2 *http.Response, result3 error) {
	fake.executeQueryLambdaByTagExecuteMutex.Lock()
	defer fake.executeQueryLambdaByTagExecuteMutex.Unlock()
	fake.ExecuteQueryLambdaByTagExecuteStub = nil
	if fake.executeQueryLambdaByTagExecuteReturnsOnCall == nil {
		fake.executeQueryLambdaByTagExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.QueryResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.executeQueryLambdaByTagExecuteReturnsOnCall[i] = struct {
		result1 *openapi.QueryResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueryLambdasApi) ExecuteQueryLambdaExecute(arg1 openapi.ApiExecuteQueryLambdaRequest) (*openapi.QueryResponse, *http.Response, error) {
	fake.executeQueryLambdaExecuteMutex.Lock()
	ret, specificReturn := fake.executeQueryLambdaExecuteReturnsOnCall[len(fake.executeQueryLambdaExecuteArgsForCall)]
	fake.executeQueryLambdaExecuteArgsForCall = append(fake.executeQueryLambdaExecuteArgsForCall, struct {
		arg1 openapi.ApiExecuteQueryLambdaRequest
	}{arg1})
	stub := fake.ExecuteQueryLambdaExecuteStub
	fakeReturns := fake.executeQueryLambdaExecuteReturns
	fake.recordInvocation("ExecuteQueryLambdaExecute", []interface{}{arg1})
	fake.executeQueryLambdaExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeQueryLambdasApi) ExecuteQueryLambdaExecuteCallCount() int {
	fake.executeQueryLambdaExecuteMutex.RLock()
	defer fake.executeQueryLambdaExecuteMutex.RUnlock()
	return len(fake.executeQueryLambdaExecuteArgsForCall)
}

func (fake *FakeQueryLambdasApi) ExecuteQueryLambdaExecuteCalls(stub func(openapi.ApiExecuteQueryLambdaRequest) (*openapi.QueryResponse, *http.Response, error)) {
	fake.executeQueryLambdaExecuteMutex.Lock()
	defer fake.executeQueryLambdaExecuteMutex.Unlock()
	fake.ExecuteQueryLambdaExecuteStub = stub
}

func (fake *FakeQueryLambdasApi) ExecuteQueryLambdaExecuteArgsForCall(i int) openapi.ApiExecuteQueryLambdaRequest {
	fake.executeQueryLambdaExecuteMutex.RLock()
	defer fake.executeQueryLambdaExecuteMutex.RUnlock()
	argsForCall := fake.executeQueryLambdaExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQueryLambdasApi) ExecuteQueryLambdaExecuteReturns(result1 *openapi.QueryResponse, result2 *http.Response, result3 error) {
	fake.executeQueryLambdaExecuteMutex.Lock()
	defer fake.executeQueryLambdaExecuteMutex.Unlock()
	fake.ExecuteQueryLambdaExecuteStub = nil
	fake.executeQueryLambdaExecuteReturns = struct {
		result1 *openapi.QueryResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueryLambdasApi) ExecuteQueryLambdaExecuteReturnsOnCall(i int, result1 *openapi.QueryResponse, result2 *http.Response, result3 error) {
	fake.executeQueryLambdaExecuteMutex.Lock()
	defer fake.executeQueryLambdaExecuteMutex.Unlock()
	fake.ExecuteQueryLambdaExecuteStub = nil
	if fake.executeQueryLambdaExecuteReturnsOnCall == nil {
		fake.executeQueryLambdaExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.QueryResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.executeQueryLambdaExecuteReturnsOnCall[i] = struct {
		result1 *openapi.QueryResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueryLambdasApi) GetQueryLambdaTagVersion(arg1 context.Context, arg2 string, arg3 string, arg4 string) openapi.ApiGetQueryLambdaTagVersionRequest {
	fake.getQueryLambdaTagVersionMutex.Lock()
	ret, specificReturn := fake.getQueryLambdaTagVersionReturnsOnCall[len(fake.getQueryLambdaTagVersionArgsForCall)]
	fake.getQueryLambdaTagVersionArgsForCall = append(fake.getQueryLambdaTagVersionArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetQueryLambdaTagVersionStub
	fakeReturns := fake.getQueryLambdaTagVersionReturns
	fake.recordInvocation("GetQueryLambdaTagVersion", []interface{}{arg1, arg2, arg3, arg4})
	fake.getQueryLambdaTagVersionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQueryLambdasApi) GetQueryLambdaTagVersionCallCount() int {
	fake.getQueryLambdaTagVersionMutex.RLock()
	defer fake.getQueryLambdaTagVersionMutex.RUnlock()
	return len(fake.getQueryLambdaTagVersionArgsForCall)
}

func (fake *FakeQueryLambdasApi) GetQueryLambdaTagVersionCalls(stub func(context.Context, string, string, string) openapi.ApiGetQueryLambdaTagVersionRequest) {
	fake.getQueryLambdaTagVersionMutex.Lock()
	defer fake.getQueryLambdaTagVersionMutex.Unlock()
	fake.GetQueryLambdaTagVersionStub = stub
}

func (fake *FakeQueryLambdasApi) GetQueryLambdaTagVersionArgsForCall(i int) (context.Context, string, string, string) {
	fake.getQueryLambdaTagVersionMutex.RLock()
	defer fake.getQueryLambdaTagVersionMutex.RUnlock()
	argsForCall := fake.getQueryLambdaTagVersionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeQueryLambdasApi) GetQueryLambdaTagVersionReturns(result1 openapi.ApiGetQueryLambdaTagVersionRequest) {
	fake.getQueryLambdaTagVersionMutex.Lock()
	defer fake.getQueryLambdaTagVersionMutex.Unlock()
	fake.GetQueryLambdaTagVersionStub = nil
	fake.getQueryLambdaTagVersionReturns = struct {
		result1 openapi.ApiGetQueryLambdaTagVersionRequest
	}{result1}
}

func (fake *FakeQueryLambdasApi) GetQueryLambdaTagVersionReturnsOnCall(i int, result1 openapi.ApiGetQueryLambdaTagVersionRequest) {
	fake.getQueryLambdaTagVersionMutex.Lock()
	defer fake.getQueryLambdaTagVersionMutex.Unlock()
	fake.GetQueryLambdaTagVersionStub = nil
	if fake.getQueryLambdaTagVersionReturnsOnCall == nil {
		fake.getQueryLambdaTagVersionReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiGetQueryLambdaTagVersionRequest
		})
	}
	fake.getQueryLambdaTagVersionReturnsOnCall[i] = struct {
		result1 openapi.ApiGetQueryLambdaTagVersionRequest
	}{result1}
}

func (fake *FakeQueryLambdasApi) GetQueryLambdaTagVersionExecute(arg1 openapi.ApiGetQueryLambdaTagVersionRequest) (*openapi.QueryLambdaTagResponse, *http.Response, error) {
	fake.getQueryLambdaTagVersionExecuteMutex.Lock()
	ret, specificReturn := fake.getQueryLambdaTagVersionExecuteReturnsOnCall[len(fake.getQueryLambdaTagVersionExecuteArgsForCall)]
	fake.getQueryLambdaTagVersionExecuteArgsForCall = append(fake.getQueryLambdaTagVersionExecuteArgsForCall, struct {
		arg1 openapi.ApiGetQueryLambdaTagVersionRequest
	}{arg1})
	stub := fake.GetQueryLambdaTagVersionExecuteStub
	fakeReturns := fake.getQueryLambdaTagVersionExecuteReturns
	fake.recordInvocation("GetQueryLambdaTagVersionExecute", []interface{}{arg1})
	fake.getQueryLambdaTagVersionExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeQueryLambdasApi) GetQueryLambdaTagVersionExecuteCallCount() int {
	fake.getQueryLambdaTagVersionExecuteMutex.RLock()
	defer fake.getQueryLambdaTagVersionExecuteMutex.RUnlock()
	return len(fake.getQueryLambdaTagVersionExecuteArgsForCall)
}

func (fake *FakeQueryLambdasApi) GetQueryLambdaTagVersionExecuteCalls(stub func(openapi.ApiGetQueryLambdaTagVersionRequest) (*openapi.QueryLambdaTagResponse, *http.Response, error)) {
	fake.getQueryLambdaTagVersionExecuteMutex.Lock()
	defer fake.getQueryLambdaTagVersionExecuteMutex.Unlock()
	fake.GetQueryLambdaTagVersionExecuteStub = stub
}

func (fake *FakeQueryLambdasApi) GetQueryLambdaTagVersionExecuteArgsForCall(i int) openapi.ApiGetQueryLambdaTagVersionRequest {
	fake.getQueryLambdaTagVersionExecuteMutex.RLock()
	defer fake.getQueryLambdaTagVersionExecuteMutex.RUnlock()
	argsForCall := fake.getQueryLambdaTagVersionExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQueryLambdasApi) GetQueryLambdaTagVersionExecuteReturns(result1 *openapi.QueryLambdaTagResponse, result2 *http.Response, result3 error) {
	fake.getQueryLambdaTagVersionExecuteMutex.Lock()
	defer fake.getQueryLambdaTagVersionExecuteMutex.Unlock()
	fake.GetQueryLambdaTagVersionExecuteStub = nil
	fake.getQueryLambdaTagVersionExecuteReturns = struct {
		result1 *openapi.QueryLambdaTagResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueryLambdasApi) GetQueryLambdaTagVersionExecuteReturnsOnCall(i int, result1 *openapi.QueryLambdaTagResponse, result2 *http.Response, result3 error) {
	fake.getQueryLambdaTagVersionExecuteMutex.Lock()
	defer fake.getQueryLambdaTagVersionExecuteMutex.Unlock()
	fake.GetQueryLambdaTagVersionExecuteStub = nil
	if fake.getQueryLambdaTagVersionExecuteReturnsOnCall == nil {
		fake.getQueryLambdaTagVersionExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.QueryLambdaTagResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.getQueryLambdaTagVersionExecuteReturnsOnCall[i] = struct {
		result1 *openapi.QueryLambdaTagResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueryLambdasApi) GetQueryLambdaVersion(arg1 context.Context, arg2 string, arg3 string, arg4 string) openapi.ApiGetQueryLambdaVersionRequest {
	fake.getQueryLambdaVersionMutex.Lock()
	ret, specificReturn := fake.getQueryLambdaVersionReturnsOnCall[len(fake.getQueryLambdaVersionArgsForCall)]
	fake.getQueryLambdaVersionArgsForCall = append(fake.getQueryLambdaVersionArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetQueryLambdaVersionStub
	fakeReturns := fake.getQueryLambdaVersionReturns
	fake.recordInvocation("GetQueryLambdaVersion", []interface{}{arg1, arg2, arg3, arg4})
	fake.getQueryLambdaVersionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQueryLambdasApi) GetQueryLambdaVersionCallCount() int {
	fake.getQueryLambdaVersionMutex.RLock()
	defer fake.getQueryLambdaVersionMutex.RUnlock()
	return len(fake.getQueryLambdaVersionArgsForCall)
}

func (fake *FakeQueryLambdasApi) GetQueryLambdaVersionCalls(stub func(context.Context, string, string, string) openapi.ApiGetQueryLambdaVersionRequest) {
	fake.getQueryLambdaVersionMutex.Lock()
	defer fake.getQueryLambdaVersionMutex.Unlock()
	fake.GetQueryLambdaVersionStub = stub
}

func (fake *FakeQueryLambdasApi) GetQueryLambdaVersionArgsForCall(i int) (context.Context, string, string, string) {
	fake.getQueryLambdaVersionMutex.RLock()
	defer fake.getQueryLambdaVersionMutex.RUnlock()
	argsForCall := fake.getQueryLambdaVersionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeQueryLambdasApi) GetQueryLambdaVersionReturns(result1 openapi.ApiGetQueryLambdaVersionRequest) {
	fake.getQueryLambdaVersionMutex.Lock()
	defer fake.getQueryLambdaVersionMutex.Unlock()
	fake.GetQueryLambdaVersionStub = nil
	fake.getQueryLambdaVersionReturns = struct {
		result1 openapi.ApiGetQueryLambdaVersionRequest
	}{result1}
}

func (fake *FakeQueryLambdasApi) GetQueryLambdaVersionReturnsOnCall(i int, result1 openapi.ApiGetQueryLambdaVersionRequest) {
	fake.getQueryLambdaVersionMutex.Lock()
	defer fake.getQueryLambdaVersionMutex.Unlock()
	fake.GetQueryLambdaVersionStub = nil
	if fake.getQueryLambdaVersionReturnsOnCall == nil {
		fake.getQueryLambdaVersionReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiGetQueryLambdaVersionRequest
		})
	}
	fake.getQueryLambdaVersionReturnsOnCall[i] = struct {
		result1 openapi.ApiGetQueryLambdaVersionRequest
	}{result1}
}

func (fake *FakeQueryLambdasApi) GetQueryLambdaVersionExecute(arg1 openapi.ApiGetQueryLambdaVersionRequest) (*openapi.QueryLambdaVersionResponse, *http.Response, error) {
	fake.getQueryLambdaVersionExecuteMutex.Lock()
	ret, specificReturn := fake.getQueryLambdaVersionExecuteReturnsOnCall[len(fake.getQueryLambdaVersionExecuteArgsForCall)]
	fake.getQueryLambdaVersionExecuteArgsForCall = append(fake.getQueryLambdaVersionExecuteArgsForCall, struct {
		arg1 openapi.ApiGetQueryLambdaVersionRequest
	}{arg1})
	stub := fake.GetQueryLambdaVersionExecuteStub
	fakeReturns := fake.getQueryLambdaVersionExecuteReturns
	fake.recordInvocation("GetQueryLambdaVersionExecute", []interface{}{arg1})
	fake.getQueryLambdaVersionExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeQueryLambdasApi) GetQueryLambdaVersionExecuteCallCount() int {
	fake.getQueryLambdaVersionExecuteMutex.RLock()
	defer fake.getQueryLambdaVersionExecuteMutex.RUnlock()
	return len(fake.getQueryLambdaVersionExecuteArgsForCall)
}

func (fake *FakeQueryLambdasApi) GetQueryLambdaVersionExecuteCalls(stub func(openapi.ApiGetQueryLambdaVersionRequest) (*openapi.QueryLambdaVersionResponse, *http.Response, error)) {
	fake.getQueryLambdaVersionExecuteMutex.Lock()
	defer fake.getQueryLambdaVersionExecuteMutex.Unlock()
	fake.GetQueryLambdaVersionExecuteStub = stub
}

func (fake *FakeQueryLambdasApi) GetQueryLambdaVersionExecuteArgsForCall(i int) openapi.ApiGetQueryLambdaVersionRequest {
	fake.getQueryLambdaVersionExecuteMutex.RLock()
	defer fake.getQueryLambdaVersionExecuteMutex.RUnlock()
	argsForCall := fake.getQueryLambdaVersionExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQueryLambdasApi) GetQueryLambdaVersionExecuteReturns(result1 *openapi.QueryLambdaVersionResponse, result2 *http.Response, result3 error) {
	fake.getQueryLambdaVersionExecuteMutex.Lock()
	defer fake.getQueryLambdaVersionExecuteMutex.Unlock()
	fake.GetQueryLambdaVersionExecuteStub = nil
	fake.getQueryLambdaVersionExecuteReturns = struct {
		result1 *openapi.QueryLambdaVersionResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueryLambdasApi) GetQueryLambdaVersionExecuteReturnsOnCall(i int, result1 *openapi.QueryLambdaVersionResponse, result2 *http.Response, result3 error) {
	fake.getQueryLambdaVersionExecuteMutex.Lock()
	defer fake.getQueryLambdaVersionExecuteMutex.Unlock()
	fake.GetQueryLambdaVersionExecuteStub = nil
	if fake.getQueryLambdaVersionExecuteReturnsOnCall == nil {
		fake.getQueryLambdaVersionExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.QueryLambdaVersionResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.getQueryLambdaVersionExecuteReturnsOnCall[i] = struct {
		result1 *openapi.QueryLambdaVersionResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueryLambdasApi) ListAllQueryLambdas(arg1 context.Context) openapi.ApiListAllQueryLambdasRequest {
	fake.listAllQueryLambdasMutex.Lock()
	ret, specificReturn := fake.listAllQueryLambdasReturnsOnCall[len(fake.listAllQueryLambdasArgsForCall)]
	fake.listAllQueryLambdasArgsForCall = append(fake.listAllQueryLambdasArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ListAllQueryLambdasStub
	fakeReturns := fake.listAllQueryLambdasReturns
	fake.recordInvocation("ListAllQueryLambdas", []interface{}{arg1})
	fake.listAllQueryLambdasMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQueryLambdasApi) ListAllQueryLambdasCallCount() int {
	fake.listAllQueryLambdasMutex.RLock()
	defer fake.listAllQueryLambdasMutex.RUnlock()
	return len(fake.listAllQueryLambdasArgsForCall)
}

func (fake *FakeQueryLambdasApi) ListAllQueryLambdasCalls(stub func(context.Context) openapi.ApiListAllQueryLambdasRequest) {
	fake.listAllQueryLambdasMutex.Lock()
	defer fake.listAllQueryLambdasMutex.Unlock()
	fake.ListAllQueryLambdasStub = stub
}

func (fake *FakeQueryLambdasApi) ListAllQueryLambdasArgsForCall(i int) context.Context {
	fake.listAllQueryLambdasMutex.RLock()
	defer fake.listAllQueryLambdasMutex.RUnlock()
	argsForCall := fake.listAllQueryLambdasArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQueryLambdasApi) ListAllQueryLambdasReturns(result1 openapi.ApiListAllQueryLambdasRequest) {
	fake.listAllQueryLambdasMutex.Lock()
	defer fake.listAllQueryLambdasMutex.Unlock()
	fake.ListAllQueryLambdasStub = nil
	fake.listAllQueryLambdasReturns = struct {
		result1 openapi.ApiListAllQueryLambdasRequest
	}{result1}
}

func (fake *FakeQueryLambdasApi) ListAllQueryLambdasReturnsOnCall(i int, result1 openapi.ApiListAllQueryLambdasRequest) {
	fake.listAllQueryLambdasMutex.Lock()
	defer fake.listAllQueryLambdasMutex.Unlock()
	fake.ListAllQueryLambdasStub = nil
	if fake.listAllQueryLambdasReturnsOnCall == nil {
		fake.listAllQueryLambdasReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiListAllQueryLambdasRequest
		})
	}
	fake.listAllQueryLambdasReturnsOnCall[i] = struct {
		result1 openapi.ApiListAllQueryLambdasRequest
	}{result1}
}

func (fake *FakeQueryLambdasApi) ListAllQueryLambdasExecute(arg1 openapi.ApiListAllQueryLambdasRequest) (*openapi.ListQueryLambdasResponse, *http.Response, error) {
	fake.listAllQueryLambdasExecuteMutex.Lock()
	ret, specificReturn := fake.listAllQueryLambdasExecuteReturnsOnCall[len(fake.listAllQueryLambdasExecuteArgsForCall)]
	fake.listAllQueryLambdasExecuteArgsForCall = append(fake.listAllQueryLambdasExecuteArgsForCall, struct {
		arg1 openapi.ApiListAllQueryLambdasRequest
	}{arg1})
	stub := fake.ListAllQueryLambdasExecuteStub
	fakeReturns := fake.listAllQueryLambdasExecuteReturns
	fake.recordInvocation("ListAllQueryLambdasExecute", []interface{}{arg1})
	fake.listAllQueryLambdasExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeQueryLambdasApi) ListAllQueryLambdasExecuteCallCount() int {
	fake.listAllQueryLambdasExecuteMutex.RLock()
	defer fake.listAllQueryLambdasExecuteMutex.RUnlock()
	return len(fake.listAllQueryLambdasExecuteArgsForCall)
}

func (fake *FakeQueryLambdasApi) ListAllQueryLambdasExecuteCalls(stub func(openapi.ApiListAllQueryLambdasRequest) (*openapi.ListQueryLambdasResponse, *http.Response, error)) {
	fake.listAllQueryLambdasExecuteMutex.Lock()
	defer fake.listAllQueryLambdasExecuteMutex.Unlock()
	fake.ListAllQueryLambdasExecuteStub = stub
}

func (fake *FakeQueryLambdasApi) ListAllQueryLambdasExecuteArgsForCall(i int) openapi.ApiListAllQueryLambdasRequest {
	fake.listAllQueryLambdasExecuteMutex.RLock()
	defer fake.listAllQueryLambdasExecuteMutex.RUnlock()
	argsForCall := fake.listAllQueryLambdasExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQueryLambdasApi) ListAllQueryLambdasExecuteReturns(result1 *openapi.ListQueryLambdasResponse, result2 *http.Response, result3 error) {
	fake.listAllQueryLambdasExecuteMutex.Lock()
	defer fake.listAllQueryLambdasExecuteMutex.Unlock()
	fake.ListAllQueryLambdasExecuteStub = nil
	fake.listAllQueryLambdasExecuteReturns = struct {
		result1 *openapi.ListQueryLambdasResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueryLambdasApi) ListAllQueryLambdasExecuteReturnsOnCall(i int, result1 *openapi.ListQueryLambdasResponse, result2 *http.Response, result3 error) {
	fake.listAllQueryLambdasExecuteMutex.Lock()
	defer fake.listAllQueryLambdasExecuteMutex.Unlock()
	fake.ListAllQueryLambdasExecuteStub = nil
	if fake.listAllQueryLambdasExecuteReturnsOnCall == nil {
		fake.listAllQueryLambdasExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.ListQueryLambdasResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.listAllQueryLambdasExecuteReturnsOnCall[i] = struct {
		result1 *openapi.ListQueryLambdasResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueryLambdasApi) ListQueryLambdaTags(arg1 context.Context, arg2 string, arg3 string) openapi.ApiListQueryLambdaTagsRequest {
	fake.listQueryLambdaTagsMutex.Lock()
	ret, specificReturn := fake.listQueryLambdaTagsReturnsOnCall[len(fake.listQueryLambdaTagsArgsForCall)]
	fake.listQueryLambdaTagsArgsForCall = append(fake.listQueryLambdaTagsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ListQueryLambdaTagsStub
	fakeReturns := fake.listQueryLambdaTagsReturns
	fake.recordInvocation("ListQueryLambdaTags", []interface{}{arg1, arg2, arg3})
	fake.listQueryLambdaTagsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQueryLambdasApi) ListQueryLambdaTagsCallCount() int {
	fake.listQueryLambdaTagsMutex.RLock()
	defer fake.listQueryLambdaTagsMutex.RUnlock()
	return len(fake.listQueryLambdaTagsArgsForCall)
}

func (fake *FakeQueryLambdasApi) ListQueryLambdaTagsCalls(stub func(context.Context, string, string) openapi.ApiListQueryLambdaTagsRequest) {
	fake.listQueryLambdaTagsMutex.Lock()
	defer fake.listQueryLambdaTagsMutex.Unlock()
	fake.ListQueryLambdaTagsStub = stub
}

func (fake *FakeQueryLambdasApi) ListQueryLambdaTagsArgsForCall(i int) (context.Context, string, string) {
	fake.listQueryLambdaTagsMutex.RLock()
	defer fake.listQueryLambdaTagsMutex.RUnlock()
	argsForCall := fake.listQueryLambdaTagsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeQueryLambdasApi) ListQueryLambdaTagsReturns(result1 openapi.ApiListQueryLambdaTagsRequest) {
	fake.listQueryLambdaTagsMutex.Lock()
	defer fake.listQueryLambdaTagsMutex.Unlock()
	fake.ListQueryLambdaTagsStub = nil
	fake.listQueryLambdaTagsReturns = struct {
		result1 openapi.ApiListQueryLambdaTagsRequest
	}{result1}
}

func (fake *FakeQueryLambdasApi) ListQueryLambdaTagsReturnsOnCall(i int, result1 openapi.ApiListQueryLambdaTagsRequest) {
	fake.listQueryLambdaTagsMutex.Lock()
	defer fake.listQueryLambdaTagsMutex.Unlock()
	fake.ListQueryLambdaTagsStub = nil
	if fake.listQueryLambdaTagsReturnsOnCall == nil {
		fake.listQueryLambdaTagsReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiListQueryLambdaTagsRequest
		})
	}
	fake.listQueryLambdaTagsReturnsOnCall[i] = struct {
		result1 openapi.ApiListQueryLambdaTagsRequest
	}{result1}
}

func (fake *FakeQueryLambdasApi) ListQueryLambdaTagsExecute(arg1 openapi.ApiListQueryLambdaTagsRequest) (*openapi.ListQueryLambdaTagsResponse, *http.Response, error) {
	fake.listQueryLambdaTagsExecuteMutex.Lock()
	ret, specificReturn := fake.listQueryLambdaTagsExecuteReturnsOnCall[len(fake.listQueryLambdaTagsExecuteArgsForCall)]
	fake.listQueryLambdaTagsExecuteArgsForCall = append(fake.listQueryLambdaTagsExecuteArgsForCall, struct {
		arg1 openapi.ApiListQueryLambdaTagsRequest
	}{arg1})
	stub := fake.ListQueryLambdaTagsExecuteStub
	fakeReturns := fake.listQueryLambdaTagsExecuteReturns
	fake.recordInvocation("ListQueryLambdaTagsExecute", []interface{}{arg1})
	fake.listQueryLambdaTagsExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeQueryLambdasApi) ListQueryLambdaTagsExecuteCallCount() int {
	fake.listQueryLambdaTagsExecuteMutex.RLock()
	defer fake.listQueryLambdaTagsExecuteMutex.RUnlock()
	return len(fake.listQueryLambdaTagsExecuteArgsForCall)
}

func (fake *FakeQueryLambdasApi) ListQueryLambdaTagsExecuteCalls(stub func(openapi.ApiListQueryLambdaTagsRequest) (*openapi.ListQueryLambdaTagsResponse, *http.Response, error)) {
	fake.listQueryLambdaTagsExecuteMutex.Lock()
	defer fake.listQueryLambdaTagsExecuteMutex.Unlock()
	fake.ListQueryLambdaTagsExecuteStub = stub
}

func (fake *FakeQueryLambdasApi) ListQueryLambdaTagsExecuteArgsForCall(i int) openapi.ApiListQueryLambdaTagsRequest {
	fake.listQueryLambdaTagsExecuteMutex.RLock()
	defer fake.listQueryLambdaTagsExecuteMutex.RUnlock()
	argsForCall := fake.listQueryLambdaTagsExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQueryLambdasApi) ListQueryLambdaTagsExecuteReturns(result1 *openapi.ListQueryLambdaTagsResponse, result2 *http.Response, result3 error) {
	fake.listQueryLambdaTagsExecuteMutex.Lock()
	defer fake.listQueryLambdaTagsExecuteMutex.Unlock()
	fake.ListQueryLambdaTagsExecuteStub = nil
	fake.listQueryLambdaTagsExecuteReturns = struct {
		result1 *openapi.ListQueryLambdaTagsResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueryLambdasApi) ListQueryLambdaTagsExecuteReturnsOnCall(i int, result1 *openapi.ListQueryLambdaTagsResponse, result2 *http.Response, result3 error) {
	fake.listQueryLambdaTagsExecuteMutex.Lock()
	defer fake.listQueryLambdaTagsExecuteMutex.Unlock()
	fake.ListQueryLambdaTagsExecuteStub = nil
	if fake.listQueryLambdaTagsExecuteReturnsOnCall == nil {
		fake.listQueryLambdaTagsExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.ListQueryLambdaTagsResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.listQueryLambdaTagsExecuteReturnsOnCall[i] = struct {
		result1 *openapi.ListQueryLambdaTagsResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueryLambdasApi) ListQueryLambdaVersions(arg1 context.Context, arg2 string, arg3 string) openapi.ApiListQueryLambdaVersionsRequest {
	fake.listQueryLambdaVersionsMutex.Lock()
	ret, specificReturn := fake.listQueryLambdaVersionsReturnsOnCall[len(fake.listQueryLambdaVersionsArgsForCall)]
	fake.listQueryLambdaVersionsArgsForCall = append(fake.listQueryLambdaVersionsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ListQueryLambdaVersionsStub
	fakeReturns := fake.listQueryLambdaVersionsReturns
	fake.recordInvocation("ListQueryLambdaVersions", []interface{}{arg1, arg2, arg3})
	fake.listQueryLambdaVersionsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQueryLambdasApi) ListQueryLambdaVersionsCallCount() int {
	fake.listQueryLambdaVersionsMutex.RLock()
	defer fake.listQueryLambdaVersionsMutex.RUnlock()
	return len(fake.listQueryLambdaVersionsArgsForCall)
}

func (fake *FakeQueryLambdasApi) ListQueryLambdaVersionsCalls(stub func(context.Context, string, string) openapi.ApiListQueryLambdaVersionsRequest) {
	fake.listQueryLambdaVersionsMutex.Lock()
	defer fake.listQueryLambdaVersionsMutex.Unlock()
	fake.ListQueryLambdaVersionsStub = stub
}

func (fake *FakeQueryLambdasApi) ListQueryLambdaVersionsArgsForCall(i int) (context.Context, string, string) {
	fake.listQueryLambdaVersionsMutex.RLock()
	defer fake.listQueryLambdaVersionsMutex.RUnlock()
	argsForCall := fake.listQueryLambdaVersionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeQueryLambdasApi) ListQueryLambdaVersionsReturns(result1 openapi.ApiListQueryLambdaVersionsRequest) {
	fake.listQueryLambdaVersionsMutex.Lock()
	defer fake.listQueryLambdaVersionsMutex.Unlock()
	fake.ListQueryLambdaVersionsStub = nil
	fake.listQueryLambdaVersionsReturns = struct {
		result1 openapi.ApiListQueryLambdaVersionsRequest
	}{result1}
}

func (fake *FakeQueryLambdasApi) ListQueryLambdaVersionsReturnsOnCall(i int, result1 openapi.ApiListQueryLambdaVersionsRequest) {
	fake.listQueryLambdaVersionsMutex.Lock()
	defer fake.listQueryLambdaVersionsMutex.Unlock()
	fake.ListQueryLambdaVersionsStub = nil
	if fake.listQueryLambdaVersionsReturnsOnCall == nil {
		fake.listQueryLambdaVersionsReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiListQueryLambdaVersionsRequest
		})
	}
	fake.listQueryLambdaVersionsReturnsOnCall[i] = struct {
		result1 openapi.ApiListQueryLambdaVersionsRequest
	}{result1}
}

func (fake *FakeQueryLambdasApi) ListQueryLambdaVersionsExecute(arg1 openapi.ApiListQueryLambdaVersionsRequest) (*openapi.ListQueryLambdaVersionsResponse, *http.Response, error) {
	fake.listQueryLambdaVersionsExecuteMutex.Lock()
	ret, specificReturn := fake.listQueryLambdaVersionsExecuteReturnsOnCall[len(fake.listQueryLambdaVersionsExecuteArgsForCall)]
	fake.listQueryLambdaVersionsExecuteArgsForCall = append(fake.listQueryLambdaVersionsExecuteArgsForCall, struct {
		arg1 openapi.ApiListQueryLambdaVersionsRequest
	}{arg1})
	stub := fake.ListQueryLambdaVersionsExecuteStub
	fakeReturns := fake.listQueryLambdaVersionsExecuteReturns
	fake.recordInvocation("ListQueryLambdaVersionsExecute", []interface{}{arg1})
	fake.listQueryLambdaVersionsExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeQueryLambdasApi) ListQueryLambdaVersionsExecuteCallCount() int {
	fake.listQueryLambdaVersionsExecuteMutex.RLock()
	defer fake.listQueryLambdaVersionsExecuteMutex.RUnlock()
	return len(fake.listQueryLambdaVersionsExecuteArgsForCall)
}

func (fake *FakeQueryLambdasApi) ListQueryLambdaVersionsExecuteCalls(stub func(openapi.ApiListQueryLambdaVersionsRequest) (*openapi.ListQueryLambdaVersionsResponse, *http.Response, error)) {
	fake.listQueryLambdaVersionsExecuteMutex.Lock()
	defer fake.listQueryLambdaVersionsExecuteMutex.Unlock()
	fake.ListQueryLambdaVersionsExecuteStub = stub
}

func (fake *FakeQueryLambdasApi) ListQueryLambdaVersionsExecuteArgsForCall(i int) openapi.ApiListQueryLambdaVersionsRequest {
	fake.listQueryLambdaVersionsExecuteMutex.RLock()
	defer fake.listQueryLambdaVersionsExecuteMutex.RUnlock()
	argsForCall := fake.listQueryLambdaVersionsExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQueryLambdasApi) ListQueryLambdaVersionsExecuteReturns(result1 *openapi.ListQueryLambdaVersionsResponse, result2 *http.Response, result3 error) {
	fake.listQueryLambdaVersionsExecuteMutex.Lock()
	defer fake.listQueryLambdaVersionsExecuteMutex.Unlock()
	fake.ListQueryLambdaVersionsExecuteStub = nil
	fake.listQueryLambdaVersionsExecuteReturns = struct {
		result1 *openapi.ListQueryLambdaVersionsResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueryLambdasApi) ListQueryLambdaVersionsExecuteReturnsOnCall(i int, result1 *openapi.ListQueryLambdaVersionsResponse, result2 *http.Response, result3 error) {
	fake.listQueryLambdaVersionsExecuteMutex.Lock()
	defer fake.listQueryLambdaVersionsExecuteMutex.Unlock()
	fake.ListQueryLambdaVersionsExecuteStub = nil
	if fake.listQueryLambdaVersionsExecuteReturnsOnCall == nil {
		fake.listQueryLambdaVersionsExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.ListQueryLambdaVersionsResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.listQueryLambdaVersionsExecuteReturnsOnCall[i] = struct {
		result1 *openapi.ListQueryLambdaVersionsResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueryLambdasApi) ListQueryLambdasInWorkspace(arg1 context.Context, arg2 string) openapi.ApiListQueryLambdasInWorkspaceRequest {
	fake.listQueryLambdasInWorkspaceMutex.Lock()
	ret, specificReturn := fake.listQueryLambdasInWorkspaceReturnsOnCall[len(fake.listQueryLambdasInWorkspaceArgsForCall)]
	fake.listQueryLambdasInWorkspaceArgsForCall = append(fake.listQueryLambdasInWorkspaceArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ListQueryLambdasInWorkspaceStub
	fakeReturns := fake.listQueryLambdasInWorkspaceReturns
	fake.recordInvocation("ListQueryLambdasInWorkspace", []interface{}{arg1, arg2})
	fake.listQueryLambdasInWorkspaceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQueryLambdasApi) ListQueryLambdasInWorkspaceCallCount() int {
	fake.listQueryLambdasInWorkspaceMutex.RLock()
	defer fake.listQueryLambdasInWorkspaceMutex.RUnlock()
	return len(fake.listQueryLambdasInWorkspaceArgsForCall)
}

func (fake *FakeQueryLambdasApi) ListQueryLambdasInWorkspaceCalls(stub func(context.Context, string) openapi.ApiListQueryLambdasInWorkspaceRequest) {
	fake.listQueryLambdasInWorkspaceMutex.Lock()
	defer fake.listQueryLambdasInWorkspaceMutex.Unlock()
	fake.ListQueryLambdasInWorkspaceStub = stub
}

func (fake *FakeQueryLambdasApi) ListQueryLambdasInWorkspaceArgsForCall(i int) (context.Context, string) {
	fake.listQueryLambdasInWorkspaceMutex.RLock()
	defer fake.listQueryLambdasInWorkspaceMutex.RUnlock()
	argsForCall := fake.listQueryLambdasInWorkspaceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQueryLambdasApi) ListQueryLambdasInWorkspaceReturns(result1 openapi.ApiListQueryLambdasInWorkspaceRequest) {
	fake.listQueryLambdasInWorkspaceMutex.Lock()
	defer fake.listQueryLambdasInWorkspaceMutex.Unlock()
	fake.ListQueryLambdasInWorkspaceStub = nil
	fake.listQueryLambdasInWorkspaceReturns = struct {
		result1 openapi.ApiListQueryLambdasInWorkspaceRequest
	}{result1}
}

func (fake *FakeQueryLambdasApi) ListQueryLambdasInWorkspaceReturnsOnCall(i int, result1 openapi.ApiListQueryLambdasInWorkspaceRequest) {
	fake.listQueryLambdasInWorkspaceMutex.Lock()
	defer fake.listQueryLambdasInWorkspaceMutex.Unlock()
	fake.ListQueryLambdasInWorkspaceStub = nil
	if fake.listQueryLambdasInWorkspaceReturnsOnCall == nil {
		fake.listQueryLambdasInWorkspaceReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiListQueryLambdasInWorkspaceRequest
		})
	}
	fake.listQueryLambdasInWorkspaceReturnsOnCall[i] = struct {
		result1 openapi.ApiListQueryLambdasInWorkspaceRequest
	}{result1}
}

func (fake *FakeQueryLambdasApi) ListQueryLambdasInWorkspaceExecute(arg1 openapi.ApiListQueryLambdasInWorkspaceRequest) (*openapi.ListQueryLambdasResponse, *http.Response, error) {
	fake.listQueryLambdasInWorkspaceExecuteMutex.Lock()
	ret, specificReturn := fake.listQueryLambdasInWorkspaceExecuteReturnsOnCall[len(fake.listQueryLambdasInWorkspaceExecuteArgsForCall)]
	fake.listQueryLambdasInWorkspaceExecuteArgsForCall = append(fake.listQueryLambdasInWorkspaceExecuteArgsForCall, struct {
		arg1 openapi.ApiListQueryLambdasInWorkspaceRequest
	}{arg1})
	stub := fake.ListQueryLambdasInWorkspaceExecuteStub
	fakeReturns := fake.listQueryLambdasInWorkspaceExecuteReturns
	fake.recordInvocation("ListQueryLambdasInWorkspaceExecute", []interface{}{arg1})
	fake.listQueryLambdasInWorkspaceExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeQueryLambdasApi) ListQueryLambdasInWorkspaceExecuteCallCount() int {
	fake.listQueryLambdasInWorkspaceExecuteMutex.RLock()
	defer fake.listQueryLambdasInWorkspaceExecuteMutex.RUnlock()
	return len(fake.listQueryLambdasInWorkspaceExecuteArgsForCall)
}

func (fake *FakeQueryLambdasApi) ListQueryLambdasInWorkspaceExecuteCalls(stub func(openapi.ApiListQueryLambdasInWorkspaceRequest) (*openapi.ListQueryLambdasResponse, *http.Response, error)) {
	fake.listQueryLambdasInWorkspaceExecuteMutex.Lock()
	defer fake.listQueryLambdasInWorkspaceExecuteMutex.Unlock()
	fake.ListQueryLambdasInWorkspaceExecuteStub = stub
}

func (fake *FakeQueryLambdasApi) ListQueryLambdasInWorkspaceExecuteArgsForCall(i int) openapi.ApiListQueryLambdasInWorkspaceRequest {
	fake.listQueryLambdasInWorkspaceExecuteMutex.RLock()
	defer fake.listQueryLambdasInWorkspaceExecuteMutex.RUnlock()
	argsForCall := fake.listQueryLambdasInWorkspaceExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQueryLambdasApi) ListQueryLambdasInWorkspaceExecuteReturns(result1 *openapi.ListQueryLambdasResponse, result2 *http.Response, result3 error) {
	fake.listQueryLambdasInWorkspaceExecuteMutex.Lock()
	defer fake.listQueryLambdasInWorkspaceExecuteMutex.Unlock()
	fake.ListQueryLambdasInWorkspaceExecuteStub = nil
	fake.listQueryLambdasInWorkspaceExecuteReturns = struct {
		result1 *openapi.ListQueryLambdasResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueryLambdasApi) ListQueryLambdasInWorkspaceExecuteReturnsOnCall(i int, result1 *openapi.ListQueryLambdasResponse, result2 *http.Response, result3 error) {
	fake.listQueryLambdasInWorkspaceExecuteMutex.Lock()
	defer fake.listQueryLambdasInWorkspaceExecuteMutex.Unlock()
	fake.ListQueryLambdasInWorkspaceExecuteStub = nil
	if fake.listQueryLambdasInWorkspaceExecuteReturnsOnCall == nil {
		fake.listQueryLambdasInWorkspaceExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.ListQueryLambdasResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.listQueryLambdasInWorkspaceExecuteReturnsOnCall[i] = struct {
		result1 *openapi.ListQueryLambdasResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueryLambdasApi) UpdateQueryLambda(arg1 context.Context, arg2 string, arg3 string) openapi.ApiUpdateQueryLambdaRequest {
	fake.updateQueryLambdaMutex.Lock()
	ret, specificReturn := fake.updateQueryLambdaReturnsOnCall[len(fake.updateQueryLambdaArgsForCall)]
	fake.updateQueryLambdaArgsForCall = append(fake.updateQueryLambdaArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.UpdateQueryLambdaStub
	fakeReturns := fake.updateQueryLambdaReturns
	fake.recordInvocation("UpdateQueryLambda", []interface{}{arg1, arg2, arg3})
	fake.updateQueryLambdaMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQueryLambdasApi) UpdateQueryLambdaCallCount() int {
	fake.updateQueryLambdaMutex.RLock()
	defer fake.updateQueryLambdaMutex.RUnlock()
	return len(fake.updateQueryLambdaArgsForCall)
}

func (fake *FakeQueryLambdasApi) UpdateQueryLambdaCalls(stub func(context.Context, string, string) openapi.ApiUpdateQueryLambdaRequest) {
	fake.updateQueryLambdaMutex.Lock()
	defer fake.updateQueryLambdaMutex.Unlock()
	fake.UpdateQueryLambdaStub = stub
}

func (fake *FakeQueryLambdasApi) UpdateQueryLambdaArgsForCall(i int) (context.Context, string, string) {
	fake.updateQueryLambdaMutex.RLock()
	defer fake.updateQueryLambdaMutex.RUnlock()
	argsForCall := fake.updateQueryLambdaArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeQueryLambdasApi) UpdateQueryLambdaReturns(result1 openapi.ApiUpdateQueryLambdaRequest) {
	fake.updateQueryLambdaMutex.Lock()
	defer fake.updateQueryLambdaMutex.Unlock()
	fake.UpdateQueryLambdaStub = nil
	fake.updateQueryLambdaReturns = struct {
		result1 openapi.ApiUpdateQueryLambdaRequest
	}{result1}
}

func (fake *FakeQueryLambdasApi) UpdateQueryLambdaReturnsOnCall(i int, result1 openapi.ApiUpdateQueryLambdaRequest) {
	fake.updateQueryLambdaMutex.Lock()
	defer fake.updateQueryLambdaMutex.Unlock()
	fake.UpdateQueryLambdaStub = nil
	if fake.updateQueryLambdaReturnsOnCall == nil {
		fake.updateQueryLambdaReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiUpdateQueryLambdaRequest
		})
	}
	fake.updateQueryLambdaReturnsOnCall[i] = struct {
		result1 openapi.ApiUpdateQueryLambdaRequest
	}{result1}
}

func (fake *FakeQueryLambdasApi) UpdateQueryLambdaExecute(arg1 openapi.ApiUpdateQueryLambdaRequest) (*openapi.QueryLambdaVersionResponse, *http.Response, error) {
	fake.updateQueryLambdaExecuteMutex.Lock()
	ret, specificReturn := fake.updateQueryLambdaExecuteReturnsOnCall[len(fake.updateQueryLambdaExecuteArgsForCall)]
	fake.updateQueryLambdaExecuteArgsForCall = append(fake.updateQueryLambdaExecuteArgsForCall, struct {
		arg1 openapi.ApiUpdateQueryLambdaRequest
	}{arg1})
	stub := fake.UpdateQueryLambdaExecuteStub
	fakeReturns := fake.updateQueryLambdaExecuteReturns
	fake.recordInvocation("UpdateQueryLambdaExecute", []interface{}{arg1})
	fake.updateQueryLambdaExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeQueryLambdasApi) UpdateQueryLambdaExecuteCallCount() int {
	fake.updateQueryLambdaExecuteMutex.RLock()
	defer fake.updateQueryLambdaExecuteMutex.RUnlock()
	return len(fake.updateQueryLambdaExecuteArgsForCall)
}

func (fake *FakeQueryLambdasApi) UpdateQueryLambdaExecuteCalls(stub func(openapi.ApiUpdateQueryLambdaRequest) (*openapi.QueryLambdaVersionResponse, *http.Response, error)) {
	fake.updateQueryLambdaExecuteMutex.Lock()
	defer fake.updateQueryLambdaExecuteMutex.Unlock()
	fake.UpdateQueryLambdaExecuteStub = stub
}

func (fake *FakeQueryLambdasApi) UpdateQueryLambdaExecuteArgsForCall(i int) openapi.ApiUpdateQueryLambdaRequest {
	fake.updateQueryLambdaExecuteMutex.RLock()
	defer fake.updateQueryLambdaExecuteMutex.RUnlock()
	argsForCall := fake.updateQueryLambdaExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQueryLambdasApi) UpdateQueryLambdaExecuteReturns(result1 *openapi.QueryLambdaVersionResponse, result2 *http.Response, result3 error) {
	fake.updateQueryLambdaExecuteMutex.Lock()
	defer fake.updateQueryLambdaExecuteMutex.Unlock()
	fake.UpdateQueryLambdaExecuteStub = nil
	fake.updateQueryLambdaExecuteReturns = struct {
		result1 *openapi.QueryLambdaVersionResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueryLambdasApi) UpdateQueryLambdaExecuteReturnsOnCall(i int, result1 *openapi.QueryLambdaVersionResponse, result2 *http.Response, result3 error) {
	fake.updateQueryLambdaExecuteMutex.Lock()
	defer fake.updateQueryLambdaExecuteMutex.Unlock()
	fake.UpdateQueryLambdaExecuteStub = nil
	if fake.updateQueryLambdaExecuteReturnsOnCall == nil {
		fake.updateQueryLambdaExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.QueryLambdaVersionResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.updateQueryLambdaExecuteReturnsOnCall[i] = struct {
		result1 *openapi.QueryLambdaVersionResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueryLambdasApi) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createQueryLambdaMutex.RLock()
	defer fake.createQueryLambdaMutex.RUnlock()
	fake.createQueryLambdaExecuteMutex.RLock()
	defer fake.createQueryLambdaExecuteMutex.RUnlock()
	fake.createQueryLambdaTagMutex.RLock()
	defer fake.createQueryLambdaTagMutex.RUnlock()
	fake.createQueryLambdaTagExecuteMutex.RLock()
	defer fake.createQueryLambdaTagExecuteMutex.RUnlock()
	fake.deleteQueryLambdaMutex.RLock()
	defer fake.deleteQueryLambdaMutex.RUnlock()
	fake.deleteQueryLambdaExecuteMutex.RLock()
	defer fake.deleteQueryLambdaExecuteMutex.RUnlock()
	fake.deleteQueryLambdaTagMutex.RLock()
	defer fake.deleteQueryLambdaTagMutex.RUnlock()
	fake.deleteQueryLambdaTagExecuteMutex.RLock()
	defer fake.deleteQueryLambdaTagExecuteMutex.RUnlock()
	fake.deleteQueryLambdaVersionMutex.RLock()
	defer fake.deleteQueryLambdaVersionMutex.RUnlock()
	fake.deleteQueryLambdaVersionExecuteMutex.RLock()
	defer fake.deleteQueryLambdaVersionExecuteMutex.RUnlock()
	fake.executeQueryLambdaMutex.RLock()
	defer fake.executeQueryLambdaMutex.RUnlock()
	fake.executeQueryLambdaByTagMutex.RLock()
	defer fake.executeQueryLambdaByTagMutex.RUnlock()
	fake.executeQueryLambdaByTagExecuteMutex.RLock()
	defer fake.executeQueryLambdaByTagExecuteMutex.RUnlock()
	fake.executeQueryLambdaExecuteMutex.RLock()
	defer fake.executeQueryLambdaExecuteMutex.RUnlock()
	fake.getQueryLambdaTagVersionMutex.RLock()
	defer fake.getQueryLambdaTagVersionMutex.RUnlock()
	fake.getQueryLambdaTagVersionExecuteMutex.RLock()
	defer fake.getQueryLambdaTagVersionExecuteMutex.RUnlock()
	fake.getQueryLambdaVersionMutex.RLock()
	defer fake.getQueryLambdaVersionMutex.RUnlock()
	fake.getQueryLambdaVersionExecuteMutex.RLock()
	defer fake.getQueryLambdaVersionExecuteMutex.RUnlock()
	fake.listAllQueryLambdasMutex.RLock()
	defer fake.listAllQueryLambdasMutex.RUnlock()
	fake.listAllQueryLambdasExecuteMutex.RLock()
	defer fake.listAllQueryLambdasExecuteMutex.RUnlock()
	fake.listQueryLambdaTagsMutex.RLock()
	defer fake.listQueryLambdaTagsMutex.RUnlock()
	fake.listQueryLambdaTagsExecuteMutex.RLock()
	defer fake.listQueryLambdaTagsExecuteMutex.RUnlock()
	fake.listQueryLambdaVersionsMutex.RLock()
	defer fake.listQueryLambdaVersionsMutex.RUnlock()
	fake.listQueryLambdaVersionsExecuteMutex.RLock()
	defer fake.listQueryLambdaVersionsExecuteMutex.RUnlock()
	fake.listQueryLambdasInWorkspaceMutex.RLock()
	defer fake.listQueryLambdasInWorkspaceMutex.RUnlock()
	fake.listQueryLambdasInWorkspaceExecuteMutex.RLock()
	defer fake.listQueryLambdasInWorkspaceExecuteMutex.RUnlock()
	fake.updateQueryLambdaMutex.RLock()
	defer fake.updateQueryLambdaMutex.RUnlock()
	fake.updateQueryLambdaExecuteMutex.RLock()
	defer fake.updateQueryLambdaExecuteMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeQueryLambdasApi) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ openapi.QueryLambdasApi = new(FakeQueryLambdasApi)
