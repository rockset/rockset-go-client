// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"context"
	"net/http"
	"sync"

	"github.com/rockset/rockset-go-client/openapi"
)

type FakeCollectionsApi struct {
	CreateCollectionStub        func(context.Context, string) openapi.ApiCreateCollectionRequest
	createCollectionMutex       sync.RWMutex
	createCollectionArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	createCollectionReturns struct {
		result1 openapi.ApiCreateCollectionRequest
	}
	createCollectionReturnsOnCall map[int]struct {
		result1 openapi.ApiCreateCollectionRequest
	}
	CreateCollectionExecuteStub        func(openapi.ApiCreateCollectionRequest) (*openapi.CreateCollectionResponse, *http.Response, error)
	createCollectionExecuteMutex       sync.RWMutex
	createCollectionExecuteArgsForCall []struct {
		arg1 openapi.ApiCreateCollectionRequest
	}
	createCollectionExecuteReturns struct {
		result1 *openapi.CreateCollectionResponse
		result2 *http.Response
		result3 error
	}
	createCollectionExecuteReturnsOnCall map[int]struct {
		result1 *openapi.CreateCollectionResponse
		result2 *http.Response
		result3 error
	}
	DeleteCollectionStub        func(context.Context, string, string) openapi.ApiDeleteCollectionRequest
	deleteCollectionMutex       sync.RWMutex
	deleteCollectionArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	deleteCollectionReturns struct {
		result1 openapi.ApiDeleteCollectionRequest
	}
	deleteCollectionReturnsOnCall map[int]struct {
		result1 openapi.ApiDeleteCollectionRequest
	}
	DeleteCollectionExecuteStub        func(openapi.ApiDeleteCollectionRequest) (*openapi.DeleteCollectionResponse, *http.Response, error)
	deleteCollectionExecuteMutex       sync.RWMutex
	deleteCollectionExecuteArgsForCall []struct {
		arg1 openapi.ApiDeleteCollectionRequest
	}
	deleteCollectionExecuteReturns struct {
		result1 *openapi.DeleteCollectionResponse
		result2 *http.Response
		result3 error
	}
	deleteCollectionExecuteReturnsOnCall map[int]struct {
		result1 *openapi.DeleteCollectionResponse
		result2 *http.Response
		result3 error
	}
	GetCollectionStub        func(context.Context, string, string) openapi.ApiGetCollectionRequest
	getCollectionMutex       sync.RWMutex
	getCollectionArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	getCollectionReturns struct {
		result1 openapi.ApiGetCollectionRequest
	}
	getCollectionReturnsOnCall map[int]struct {
		result1 openapi.ApiGetCollectionRequest
	}
	GetCollectionExecuteStub        func(openapi.ApiGetCollectionRequest) (*openapi.GetCollectionResponse, *http.Response, error)
	getCollectionExecuteMutex       sync.RWMutex
	getCollectionExecuteArgsForCall []struct {
		arg1 openapi.ApiGetCollectionRequest
	}
	getCollectionExecuteReturns struct {
		result1 *openapi.GetCollectionResponse
		result2 *http.Response
		result3 error
	}
	getCollectionExecuteReturnsOnCall map[int]struct {
		result1 *openapi.GetCollectionResponse
		result2 *http.Response
		result3 error
	}
	GetCollectionOffsetsStub        func(context.Context, string, string) openapi.ApiGetCollectionOffsetsRequest
	getCollectionOffsetsMutex       sync.RWMutex
	getCollectionOffsetsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	getCollectionOffsetsReturns struct {
		result1 openapi.ApiGetCollectionOffsetsRequest
	}
	getCollectionOffsetsReturnsOnCall map[int]struct {
		result1 openapi.ApiGetCollectionOffsetsRequest
	}
	GetCollectionOffsetsExecuteStub        func(openapi.ApiGetCollectionOffsetsRequest) (*openapi.GetCollectionCommit, *http.Response, error)
	getCollectionOffsetsExecuteMutex       sync.RWMutex
	getCollectionOffsetsExecuteArgsForCall []struct {
		arg1 openapi.ApiGetCollectionOffsetsRequest
	}
	getCollectionOffsetsExecuteReturns struct {
		result1 *openapi.GetCollectionCommit
		result2 *http.Response
		result3 error
	}
	getCollectionOffsetsExecuteReturnsOnCall map[int]struct {
		result1 *openapi.GetCollectionCommit
		result2 *http.Response
		result3 error
	}
	ListCollectionsStub        func(context.Context) openapi.ApiListCollectionsRequest
	listCollectionsMutex       sync.RWMutex
	listCollectionsArgsForCall []struct {
		arg1 context.Context
	}
	listCollectionsReturns struct {
		result1 openapi.ApiListCollectionsRequest
	}
	listCollectionsReturnsOnCall map[int]struct {
		result1 openapi.ApiListCollectionsRequest
	}
	ListCollectionsExecuteStub        func(openapi.ApiListCollectionsRequest) (*openapi.ListCollectionsResponse, *http.Response, error)
	listCollectionsExecuteMutex       sync.RWMutex
	listCollectionsExecuteArgsForCall []struct {
		arg1 openapi.ApiListCollectionsRequest
	}
	listCollectionsExecuteReturns struct {
		result1 *openapi.ListCollectionsResponse
		result2 *http.Response
		result3 error
	}
	listCollectionsExecuteReturnsOnCall map[int]struct {
		result1 *openapi.ListCollectionsResponse
		result2 *http.Response
		result3 error
	}
	UpdateCollectionStub        func(context.Context, string, string) openapi.ApiUpdateCollectionRequest
	updateCollectionMutex       sync.RWMutex
	updateCollectionArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	updateCollectionReturns struct {
		result1 openapi.ApiUpdateCollectionRequest
	}
	updateCollectionReturnsOnCall map[int]struct {
		result1 openapi.ApiUpdateCollectionRequest
	}
	UpdateCollectionExecuteStub        func(openapi.ApiUpdateCollectionRequest) (*openapi.GetCollectionResponse, *http.Response, error)
	updateCollectionExecuteMutex       sync.RWMutex
	updateCollectionExecuteArgsForCall []struct {
		arg1 openapi.ApiUpdateCollectionRequest
	}
	updateCollectionExecuteReturns struct {
		result1 *openapi.GetCollectionResponse
		result2 *http.Response
		result3 error
	}
	updateCollectionExecuteReturnsOnCall map[int]struct {
		result1 *openapi.GetCollectionResponse
		result2 *http.Response
		result3 error
	}
	WorkspaceCollectionsStub        func(context.Context, string) openapi.ApiWorkspaceCollectionsRequest
	workspaceCollectionsMutex       sync.RWMutex
	workspaceCollectionsArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	workspaceCollectionsReturns struct {
		result1 openapi.ApiWorkspaceCollectionsRequest
	}
	workspaceCollectionsReturnsOnCall map[int]struct {
		result1 openapi.ApiWorkspaceCollectionsRequest
	}
	WorkspaceCollectionsExecuteStub        func(openapi.ApiWorkspaceCollectionsRequest) (*openapi.ListCollectionsResponse, *http.Response, error)
	workspaceCollectionsExecuteMutex       sync.RWMutex
	workspaceCollectionsExecuteArgsForCall []struct {
		arg1 openapi.ApiWorkspaceCollectionsRequest
	}
	workspaceCollectionsExecuteReturns struct {
		result1 *openapi.ListCollectionsResponse
		result2 *http.Response
		result3 error
	}
	workspaceCollectionsExecuteReturnsOnCall map[int]struct {
		result1 *openapi.ListCollectionsResponse
		result2 *http.Response
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeCollectionsApi) CreateCollection(arg1 context.Context, arg2 string) openapi.ApiCreateCollectionRequest {
	fake.createCollectionMutex.Lock()
	ret, specificReturn := fake.createCollectionReturnsOnCall[len(fake.createCollectionArgsForCall)]
	fake.createCollectionArgsForCall = append(fake.createCollectionArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.CreateCollectionStub
	fakeReturns := fake.createCollectionReturns
	fake.recordInvocation("CreateCollection", []interface{}{arg1, arg2})
	fake.createCollectionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCollectionsApi) CreateCollectionCallCount() int {
	fake.createCollectionMutex.RLock()
	defer fake.createCollectionMutex.RUnlock()
	return len(fake.createCollectionArgsForCall)
}

func (fake *FakeCollectionsApi) CreateCollectionCalls(stub func(context.Context, string) openapi.ApiCreateCollectionRequest) {
	fake.createCollectionMutex.Lock()
	defer fake.createCollectionMutex.Unlock()
	fake.CreateCollectionStub = stub
}

func (fake *FakeCollectionsApi) CreateCollectionArgsForCall(i int) (context.Context, string) {
	fake.createCollectionMutex.RLock()
	defer fake.createCollectionMutex.RUnlock()
	argsForCall := fake.createCollectionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeCollectionsApi) CreateCollectionReturns(result1 openapi.ApiCreateCollectionRequest) {
	fake.createCollectionMutex.Lock()
	defer fake.createCollectionMutex.Unlock()
	fake.CreateCollectionStub = nil
	fake.createCollectionReturns = struct {
		result1 openapi.ApiCreateCollectionRequest
	}{result1}
}

func (fake *FakeCollectionsApi) CreateCollectionReturnsOnCall(i int, result1 openapi.ApiCreateCollectionRequest) {
	fake.createCollectionMutex.Lock()
	defer fake.createCollectionMutex.Unlock()
	fake.CreateCollectionStub = nil
	if fake.createCollectionReturnsOnCall == nil {
		fake.createCollectionReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiCreateCollectionRequest
		})
	}
	fake.createCollectionReturnsOnCall[i] = struct {
		result1 openapi.ApiCreateCollectionRequest
	}{result1}
}

func (fake *FakeCollectionsApi) CreateCollectionExecute(arg1 openapi.ApiCreateCollectionRequest) (*openapi.CreateCollectionResponse, *http.Response, error) {
	fake.createCollectionExecuteMutex.Lock()
	ret, specificReturn := fake.createCollectionExecuteReturnsOnCall[len(fake.createCollectionExecuteArgsForCall)]
	fake.createCollectionExecuteArgsForCall = append(fake.createCollectionExecuteArgsForCall, struct {
		arg1 openapi.ApiCreateCollectionRequest
	}{arg1})
	stub := fake.CreateCollectionExecuteStub
	fakeReturns := fake.createCollectionExecuteReturns
	fake.recordInvocation("CreateCollectionExecute", []interface{}{arg1})
	fake.createCollectionExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeCollectionsApi) CreateCollectionExecuteCallCount() int {
	fake.createCollectionExecuteMutex.RLock()
	defer fake.createCollectionExecuteMutex.RUnlock()
	return len(fake.createCollectionExecuteArgsForCall)
}

func (fake *FakeCollectionsApi) CreateCollectionExecuteCalls(stub func(openapi.ApiCreateCollectionRequest) (*openapi.CreateCollectionResponse, *http.Response, error)) {
	fake.createCollectionExecuteMutex.Lock()
	defer fake.createCollectionExecuteMutex.Unlock()
	fake.CreateCollectionExecuteStub = stub
}

func (fake *FakeCollectionsApi) CreateCollectionExecuteArgsForCall(i int) openapi.ApiCreateCollectionRequest {
	fake.createCollectionExecuteMutex.RLock()
	defer fake.createCollectionExecuteMutex.RUnlock()
	argsForCall := fake.createCollectionExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCollectionsApi) CreateCollectionExecuteReturns(result1 *openapi.CreateCollectionResponse, result2 *http.Response, result3 error) {
	fake.createCollectionExecuteMutex.Lock()
	defer fake.createCollectionExecuteMutex.Unlock()
	fake.CreateCollectionExecuteStub = nil
	fake.createCollectionExecuteReturns = struct {
		result1 *openapi.CreateCollectionResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeCollectionsApi) CreateCollectionExecuteReturnsOnCall(i int, result1 *openapi.CreateCollectionResponse, result2 *http.Response, result3 error) {
	fake.createCollectionExecuteMutex.Lock()
	defer fake.createCollectionExecuteMutex.Unlock()
	fake.CreateCollectionExecuteStub = nil
	if fake.createCollectionExecuteReturnsOnCall == nil {
		fake.createCollectionExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.CreateCollectionResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.createCollectionExecuteReturnsOnCall[i] = struct {
		result1 *openapi.CreateCollectionResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeCollectionsApi) DeleteCollection(arg1 context.Context, arg2 string, arg3 string) openapi.ApiDeleteCollectionRequest {
	fake.deleteCollectionMutex.Lock()
	ret, specificReturn := fake.deleteCollectionReturnsOnCall[len(fake.deleteCollectionArgsForCall)]
	fake.deleteCollectionArgsForCall = append(fake.deleteCollectionArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.DeleteCollectionStub
	fakeReturns := fake.deleteCollectionReturns
	fake.recordInvocation("DeleteCollection", []interface{}{arg1, arg2, arg3})
	fake.deleteCollectionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCollectionsApi) DeleteCollectionCallCount() int {
	fake.deleteCollectionMutex.RLock()
	defer fake.deleteCollectionMutex.RUnlock()
	return len(fake.deleteCollectionArgsForCall)
}

func (fake *FakeCollectionsApi) DeleteCollectionCalls(stub func(context.Context, string, string) openapi.ApiDeleteCollectionRequest) {
	fake.deleteCollectionMutex.Lock()
	defer fake.deleteCollectionMutex.Unlock()
	fake.DeleteCollectionStub = stub
}

func (fake *FakeCollectionsApi) DeleteCollectionArgsForCall(i int) (context.Context, string, string) {
	fake.deleteCollectionMutex.RLock()
	defer fake.deleteCollectionMutex.RUnlock()
	argsForCall := fake.deleteCollectionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCollectionsApi) DeleteCollectionReturns(result1 openapi.ApiDeleteCollectionRequest) {
	fake.deleteCollectionMutex.Lock()
	defer fake.deleteCollectionMutex.Unlock()
	fake.DeleteCollectionStub = nil
	fake.deleteCollectionReturns = struct {
		result1 openapi.ApiDeleteCollectionRequest
	}{result1}
}

func (fake *FakeCollectionsApi) DeleteCollectionReturnsOnCall(i int, result1 openapi.ApiDeleteCollectionRequest) {
	fake.deleteCollectionMutex.Lock()
	defer fake.deleteCollectionMutex.Unlock()
	fake.DeleteCollectionStub = nil
	if fake.deleteCollectionReturnsOnCall == nil {
		fake.deleteCollectionReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiDeleteCollectionRequest
		})
	}
	fake.deleteCollectionReturnsOnCall[i] = struct {
		result1 openapi.ApiDeleteCollectionRequest
	}{result1}
}

func (fake *FakeCollectionsApi) DeleteCollectionExecute(arg1 openapi.ApiDeleteCollectionRequest) (*openapi.DeleteCollectionResponse, *http.Response, error) {
	fake.deleteCollectionExecuteMutex.Lock()
	ret, specificReturn := fake.deleteCollectionExecuteReturnsOnCall[len(fake.deleteCollectionExecuteArgsForCall)]
	fake.deleteCollectionExecuteArgsForCall = append(fake.deleteCollectionExecuteArgsForCall, struct {
		arg1 openapi.ApiDeleteCollectionRequest
	}{arg1})
	stub := fake.DeleteCollectionExecuteStub
	fakeReturns := fake.deleteCollectionExecuteReturns
	fake.recordInvocation("DeleteCollectionExecute", []interface{}{arg1})
	fake.deleteCollectionExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeCollectionsApi) DeleteCollectionExecuteCallCount() int {
	fake.deleteCollectionExecuteMutex.RLock()
	defer fake.deleteCollectionExecuteMutex.RUnlock()
	return len(fake.deleteCollectionExecuteArgsForCall)
}

func (fake *FakeCollectionsApi) DeleteCollectionExecuteCalls(stub func(openapi.ApiDeleteCollectionRequest) (*openapi.DeleteCollectionResponse, *http.Response, error)) {
	fake.deleteCollectionExecuteMutex.Lock()
	defer fake.deleteCollectionExecuteMutex.Unlock()
	fake.DeleteCollectionExecuteStub = stub
}

func (fake *FakeCollectionsApi) DeleteCollectionExecuteArgsForCall(i int) openapi.ApiDeleteCollectionRequest {
	fake.deleteCollectionExecuteMutex.RLock()
	defer fake.deleteCollectionExecuteMutex.RUnlock()
	argsForCall := fake.deleteCollectionExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCollectionsApi) DeleteCollectionExecuteReturns(result1 *openapi.DeleteCollectionResponse, result2 *http.Response, result3 error) {
	fake.deleteCollectionExecuteMutex.Lock()
	defer fake.deleteCollectionExecuteMutex.Unlock()
	fake.DeleteCollectionExecuteStub = nil
	fake.deleteCollectionExecuteReturns = struct {
		result1 *openapi.DeleteCollectionResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeCollectionsApi) DeleteCollectionExecuteReturnsOnCall(i int, result1 *openapi.DeleteCollectionResponse, result2 *http.Response, result3 error) {
	fake.deleteCollectionExecuteMutex.Lock()
	defer fake.deleteCollectionExecuteMutex.Unlock()
	fake.DeleteCollectionExecuteStub = nil
	if fake.deleteCollectionExecuteReturnsOnCall == nil {
		fake.deleteCollectionExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.DeleteCollectionResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.deleteCollectionExecuteReturnsOnCall[i] = struct {
		result1 *openapi.DeleteCollectionResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeCollectionsApi) GetCollection(arg1 context.Context, arg2 string, arg3 string) openapi.ApiGetCollectionRequest {
	fake.getCollectionMutex.Lock()
	ret, specificReturn := fake.getCollectionReturnsOnCall[len(fake.getCollectionArgsForCall)]
	fake.getCollectionArgsForCall = append(fake.getCollectionArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetCollectionStub
	fakeReturns := fake.getCollectionReturns
	fake.recordInvocation("GetCollection", []interface{}{arg1, arg2, arg3})
	fake.getCollectionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCollectionsApi) GetCollectionCallCount() int {
	fake.getCollectionMutex.RLock()
	defer fake.getCollectionMutex.RUnlock()
	return len(fake.getCollectionArgsForCall)
}

func (fake *FakeCollectionsApi) GetCollectionCalls(stub func(context.Context, string, string) openapi.ApiGetCollectionRequest) {
	fake.getCollectionMutex.Lock()
	defer fake.getCollectionMutex.Unlock()
	fake.GetCollectionStub = stub
}

func (fake *FakeCollectionsApi) GetCollectionArgsForCall(i int) (context.Context, string, string) {
	fake.getCollectionMutex.RLock()
	defer fake.getCollectionMutex.RUnlock()
	argsForCall := fake.getCollectionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCollectionsApi) GetCollectionReturns(result1 openapi.ApiGetCollectionRequest) {
	fake.getCollectionMutex.Lock()
	defer fake.getCollectionMutex.Unlock()
	fake.GetCollectionStub = nil
	fake.getCollectionReturns = struct {
		result1 openapi.ApiGetCollectionRequest
	}{result1}
}

func (fake *FakeCollectionsApi) GetCollectionReturnsOnCall(i int, result1 openapi.ApiGetCollectionRequest) {
	fake.getCollectionMutex.Lock()
	defer fake.getCollectionMutex.Unlock()
	fake.GetCollectionStub = nil
	if fake.getCollectionReturnsOnCall == nil {
		fake.getCollectionReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiGetCollectionRequest
		})
	}
	fake.getCollectionReturnsOnCall[i] = struct {
		result1 openapi.ApiGetCollectionRequest
	}{result1}
}

func (fake *FakeCollectionsApi) GetCollectionExecute(arg1 openapi.ApiGetCollectionRequest) (*openapi.GetCollectionResponse, *http.Response, error) {
	fake.getCollectionExecuteMutex.Lock()
	ret, specificReturn := fake.getCollectionExecuteReturnsOnCall[len(fake.getCollectionExecuteArgsForCall)]
	fake.getCollectionExecuteArgsForCall = append(fake.getCollectionExecuteArgsForCall, struct {
		arg1 openapi.ApiGetCollectionRequest
	}{arg1})
	stub := fake.GetCollectionExecuteStub
	fakeReturns := fake.getCollectionExecuteReturns
	fake.recordInvocation("GetCollectionExecute", []interface{}{arg1})
	fake.getCollectionExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeCollectionsApi) GetCollectionExecuteCallCount() int {
	fake.getCollectionExecuteMutex.RLock()
	defer fake.getCollectionExecuteMutex.RUnlock()
	return len(fake.getCollectionExecuteArgsForCall)
}

func (fake *FakeCollectionsApi) GetCollectionExecuteCalls(stub func(openapi.ApiGetCollectionRequest) (*openapi.GetCollectionResponse, *http.Response, error)) {
	fake.getCollectionExecuteMutex.Lock()
	defer fake.getCollectionExecuteMutex.Unlock()
	fake.GetCollectionExecuteStub = stub
}

func (fake *FakeCollectionsApi) GetCollectionExecuteArgsForCall(i int) openapi.ApiGetCollectionRequest {
	fake.getCollectionExecuteMutex.RLock()
	defer fake.getCollectionExecuteMutex.RUnlock()
	argsForCall := fake.getCollectionExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCollectionsApi) GetCollectionExecuteReturns(result1 *openapi.GetCollectionResponse, result2 *http.Response, result3 error) {
	fake.getCollectionExecuteMutex.Lock()
	defer fake.getCollectionExecuteMutex.Unlock()
	fake.GetCollectionExecuteStub = nil
	fake.getCollectionExecuteReturns = struct {
		result1 *openapi.GetCollectionResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeCollectionsApi) GetCollectionExecuteReturnsOnCall(i int, result1 *openapi.GetCollectionResponse, result2 *http.Response, result3 error) {
	fake.getCollectionExecuteMutex.Lock()
	defer fake.getCollectionExecuteMutex.Unlock()
	fake.GetCollectionExecuteStub = nil
	if fake.getCollectionExecuteReturnsOnCall == nil {
		fake.getCollectionExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.GetCollectionResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.getCollectionExecuteReturnsOnCall[i] = struct {
		result1 *openapi.GetCollectionResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeCollectionsApi) GetCollectionOffsets(arg1 context.Context, arg2 string, arg3 string) openapi.ApiGetCollectionOffsetsRequest {
	fake.getCollectionOffsetsMutex.Lock()
	ret, specificReturn := fake.getCollectionOffsetsReturnsOnCall[len(fake.getCollectionOffsetsArgsForCall)]
	fake.getCollectionOffsetsArgsForCall = append(fake.getCollectionOffsetsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetCollectionOffsetsStub
	fakeReturns := fake.getCollectionOffsetsReturns
	fake.recordInvocation("GetCollectionOffsets", []interface{}{arg1, arg2, arg3})
	fake.getCollectionOffsetsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCollectionsApi) GetCollectionOffsetsCallCount() int {
	fake.getCollectionOffsetsMutex.RLock()
	defer fake.getCollectionOffsetsMutex.RUnlock()
	return len(fake.getCollectionOffsetsArgsForCall)
}

func (fake *FakeCollectionsApi) GetCollectionOffsetsCalls(stub func(context.Context, string, string) openapi.ApiGetCollectionOffsetsRequest) {
	fake.getCollectionOffsetsMutex.Lock()
	defer fake.getCollectionOffsetsMutex.Unlock()
	fake.GetCollectionOffsetsStub = stub
}

func (fake *FakeCollectionsApi) GetCollectionOffsetsArgsForCall(i int) (context.Context, string, string) {
	fake.getCollectionOffsetsMutex.RLock()
	defer fake.getCollectionOffsetsMutex.RUnlock()
	argsForCall := fake.getCollectionOffsetsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCollectionsApi) GetCollectionOffsetsReturns(result1 openapi.ApiGetCollectionOffsetsRequest) {
	fake.getCollectionOffsetsMutex.Lock()
	defer fake.getCollectionOffsetsMutex.Unlock()
	fake.GetCollectionOffsetsStub = nil
	fake.getCollectionOffsetsReturns = struct {
		result1 openapi.ApiGetCollectionOffsetsRequest
	}{result1}
}

func (fake *FakeCollectionsApi) GetCollectionOffsetsReturnsOnCall(i int, result1 openapi.ApiGetCollectionOffsetsRequest) {
	fake.getCollectionOffsetsMutex.Lock()
	defer fake.getCollectionOffsetsMutex.Unlock()
	fake.GetCollectionOffsetsStub = nil
	if fake.getCollectionOffsetsReturnsOnCall == nil {
		fake.getCollectionOffsetsReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiGetCollectionOffsetsRequest
		})
	}
	fake.getCollectionOffsetsReturnsOnCall[i] = struct {
		result1 openapi.ApiGetCollectionOffsetsRequest
	}{result1}
}

func (fake *FakeCollectionsApi) GetCollectionOffsetsExecute(arg1 openapi.ApiGetCollectionOffsetsRequest) (*openapi.GetCollectionCommit, *http.Response, error) {
	fake.getCollectionOffsetsExecuteMutex.Lock()
	ret, specificReturn := fake.getCollectionOffsetsExecuteReturnsOnCall[len(fake.getCollectionOffsetsExecuteArgsForCall)]
	fake.getCollectionOffsetsExecuteArgsForCall = append(fake.getCollectionOffsetsExecuteArgsForCall, struct {
		arg1 openapi.ApiGetCollectionOffsetsRequest
	}{arg1})
	stub := fake.GetCollectionOffsetsExecuteStub
	fakeReturns := fake.getCollectionOffsetsExecuteReturns
	fake.recordInvocation("GetCollectionOffsetsExecute", []interface{}{arg1})
	fake.getCollectionOffsetsExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeCollectionsApi) GetCollectionOffsetsExecuteCallCount() int {
	fake.getCollectionOffsetsExecuteMutex.RLock()
	defer fake.getCollectionOffsetsExecuteMutex.RUnlock()
	return len(fake.getCollectionOffsetsExecuteArgsForCall)
}

func (fake *FakeCollectionsApi) GetCollectionOffsetsExecuteCalls(stub func(openapi.ApiGetCollectionOffsetsRequest) (*openapi.GetCollectionCommit, *http.Response, error)) {
	fake.getCollectionOffsetsExecuteMutex.Lock()
	defer fake.getCollectionOffsetsExecuteMutex.Unlock()
	fake.GetCollectionOffsetsExecuteStub = stub
}

func (fake *FakeCollectionsApi) GetCollectionOffsetsExecuteArgsForCall(i int) openapi.ApiGetCollectionOffsetsRequest {
	fake.getCollectionOffsetsExecuteMutex.RLock()
	defer fake.getCollectionOffsetsExecuteMutex.RUnlock()
	argsForCall := fake.getCollectionOffsetsExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCollectionsApi) GetCollectionOffsetsExecuteReturns(result1 *openapi.GetCollectionCommit, result2 *http.Response, result3 error) {
	fake.getCollectionOffsetsExecuteMutex.Lock()
	defer fake.getCollectionOffsetsExecuteMutex.Unlock()
	fake.GetCollectionOffsetsExecuteStub = nil
	fake.getCollectionOffsetsExecuteReturns = struct {
		result1 *openapi.GetCollectionCommit
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeCollectionsApi) GetCollectionOffsetsExecuteReturnsOnCall(i int, result1 *openapi.GetCollectionCommit, result2 *http.Response, result3 error) {
	fake.getCollectionOffsetsExecuteMutex.Lock()
	defer fake.getCollectionOffsetsExecuteMutex.Unlock()
	fake.GetCollectionOffsetsExecuteStub = nil
	if fake.getCollectionOffsetsExecuteReturnsOnCall == nil {
		fake.getCollectionOffsetsExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.GetCollectionCommit
			result2 *http.Response
			result3 error
		})
	}
	fake.getCollectionOffsetsExecuteReturnsOnCall[i] = struct {
		result1 *openapi.GetCollectionCommit
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeCollectionsApi) ListCollections(arg1 context.Context) openapi.ApiListCollectionsRequest {
	fake.listCollectionsMutex.Lock()
	ret, specificReturn := fake.listCollectionsReturnsOnCall[len(fake.listCollectionsArgsForCall)]
	fake.listCollectionsArgsForCall = append(fake.listCollectionsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ListCollectionsStub
	fakeReturns := fake.listCollectionsReturns
	fake.recordInvocation("ListCollections", []interface{}{arg1})
	fake.listCollectionsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCollectionsApi) ListCollectionsCallCount() int {
	fake.listCollectionsMutex.RLock()
	defer fake.listCollectionsMutex.RUnlock()
	return len(fake.listCollectionsArgsForCall)
}

func (fake *FakeCollectionsApi) ListCollectionsCalls(stub func(context.Context) openapi.ApiListCollectionsRequest) {
	fake.listCollectionsMutex.Lock()
	defer fake.listCollectionsMutex.Unlock()
	fake.ListCollectionsStub = stub
}

func (fake *FakeCollectionsApi) ListCollectionsArgsForCall(i int) context.Context {
	fake.listCollectionsMutex.RLock()
	defer fake.listCollectionsMutex.RUnlock()
	argsForCall := fake.listCollectionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCollectionsApi) ListCollectionsReturns(result1 openapi.ApiListCollectionsRequest) {
	fake.listCollectionsMutex.Lock()
	defer fake.listCollectionsMutex.Unlock()
	fake.ListCollectionsStub = nil
	fake.listCollectionsReturns = struct {
		result1 openapi.ApiListCollectionsRequest
	}{result1}
}

func (fake *FakeCollectionsApi) ListCollectionsReturnsOnCall(i int, result1 openapi.ApiListCollectionsRequest) {
	fake.listCollectionsMutex.Lock()
	defer fake.listCollectionsMutex.Unlock()
	fake.ListCollectionsStub = nil
	if fake.listCollectionsReturnsOnCall == nil {
		fake.listCollectionsReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiListCollectionsRequest
		})
	}
	fake.listCollectionsReturnsOnCall[i] = struct {
		result1 openapi.ApiListCollectionsRequest
	}{result1}
}

func (fake *FakeCollectionsApi) ListCollectionsExecute(arg1 openapi.ApiListCollectionsRequest) (*openapi.ListCollectionsResponse, *http.Response, error) {
	fake.listCollectionsExecuteMutex.Lock()
	ret, specificReturn := fake.listCollectionsExecuteReturnsOnCall[len(fake.listCollectionsExecuteArgsForCall)]
	fake.listCollectionsExecuteArgsForCall = append(fake.listCollectionsExecuteArgsForCall, struct {
		arg1 openapi.ApiListCollectionsRequest
	}{arg1})
	stub := fake.ListCollectionsExecuteStub
	fakeReturns := fake.listCollectionsExecuteReturns
	fake.recordInvocation("ListCollectionsExecute", []interface{}{arg1})
	fake.listCollectionsExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeCollectionsApi) ListCollectionsExecuteCallCount() int {
	fake.listCollectionsExecuteMutex.RLock()
	defer fake.listCollectionsExecuteMutex.RUnlock()
	return len(fake.listCollectionsExecuteArgsForCall)
}

func (fake *FakeCollectionsApi) ListCollectionsExecuteCalls(stub func(openapi.ApiListCollectionsRequest) (*openapi.ListCollectionsResponse, *http.Response, error)) {
	fake.listCollectionsExecuteMutex.Lock()
	defer fake.listCollectionsExecuteMutex.Unlock()
	fake.ListCollectionsExecuteStub = stub
}

func (fake *FakeCollectionsApi) ListCollectionsExecuteArgsForCall(i int) openapi.ApiListCollectionsRequest {
	fake.listCollectionsExecuteMutex.RLock()
	defer fake.listCollectionsExecuteMutex.RUnlock()
	argsForCall := fake.listCollectionsExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCollectionsApi) ListCollectionsExecuteReturns(result1 *openapi.ListCollectionsResponse, result2 *http.Response, result3 error) {
	fake.listCollectionsExecuteMutex.Lock()
	defer fake.listCollectionsExecuteMutex.Unlock()
	fake.ListCollectionsExecuteStub = nil
	fake.listCollectionsExecuteReturns = struct {
		result1 *openapi.ListCollectionsResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeCollectionsApi) ListCollectionsExecuteReturnsOnCall(i int, result1 *openapi.ListCollectionsResponse, result2 *http.Response, result3 error) {
	fake.listCollectionsExecuteMutex.Lock()
	defer fake.listCollectionsExecuteMutex.Unlock()
	fake.ListCollectionsExecuteStub = nil
	if fake.listCollectionsExecuteReturnsOnCall == nil {
		fake.listCollectionsExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.ListCollectionsResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.listCollectionsExecuteReturnsOnCall[i] = struct {
		result1 *openapi.ListCollectionsResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeCollectionsApi) UpdateCollection(arg1 context.Context, arg2 string, arg3 string) openapi.ApiUpdateCollectionRequest {
	fake.updateCollectionMutex.Lock()
	ret, specificReturn := fake.updateCollectionReturnsOnCall[len(fake.updateCollectionArgsForCall)]
	fake.updateCollectionArgsForCall = append(fake.updateCollectionArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.UpdateCollectionStub
	fakeReturns := fake.updateCollectionReturns
	fake.recordInvocation("UpdateCollection", []interface{}{arg1, arg2, arg3})
	fake.updateCollectionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCollectionsApi) UpdateCollectionCallCount() int {
	fake.updateCollectionMutex.RLock()
	defer fake.updateCollectionMutex.RUnlock()
	return len(fake.updateCollectionArgsForCall)
}

func (fake *FakeCollectionsApi) UpdateCollectionCalls(stub func(context.Context, string, string) openapi.ApiUpdateCollectionRequest) {
	fake.updateCollectionMutex.Lock()
	defer fake.updateCollectionMutex.Unlock()
	fake.UpdateCollectionStub = stub
}

func (fake *FakeCollectionsApi) UpdateCollectionArgsForCall(i int) (context.Context, string, string) {
	fake.updateCollectionMutex.RLock()
	defer fake.updateCollectionMutex.RUnlock()
	argsForCall := fake.updateCollectionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCollectionsApi) UpdateCollectionReturns(result1 openapi.ApiUpdateCollectionRequest) {
	fake.updateCollectionMutex.Lock()
	defer fake.updateCollectionMutex.Unlock()
	fake.UpdateCollectionStub = nil
	fake.updateCollectionReturns = struct {
		result1 openapi.ApiUpdateCollectionRequest
	}{result1}
}

func (fake *FakeCollectionsApi) UpdateCollectionReturnsOnCall(i int, result1 openapi.ApiUpdateCollectionRequest) {
	fake.updateCollectionMutex.Lock()
	defer fake.updateCollectionMutex.Unlock()
	fake.UpdateCollectionStub = nil
	if fake.updateCollectionReturnsOnCall == nil {
		fake.updateCollectionReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiUpdateCollectionRequest
		})
	}
	fake.updateCollectionReturnsOnCall[i] = struct {
		result1 openapi.ApiUpdateCollectionRequest
	}{result1}
}

func (fake *FakeCollectionsApi) UpdateCollectionExecute(arg1 openapi.ApiUpdateCollectionRequest) (*openapi.GetCollectionResponse, *http.Response, error) {
	fake.updateCollectionExecuteMutex.Lock()
	ret, specificReturn := fake.updateCollectionExecuteReturnsOnCall[len(fake.updateCollectionExecuteArgsForCall)]
	fake.updateCollectionExecuteArgsForCall = append(fake.updateCollectionExecuteArgsForCall, struct {
		arg1 openapi.ApiUpdateCollectionRequest
	}{arg1})
	stub := fake.UpdateCollectionExecuteStub
	fakeReturns := fake.updateCollectionExecuteReturns
	fake.recordInvocation("UpdateCollectionExecute", []interface{}{arg1})
	fake.updateCollectionExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeCollectionsApi) UpdateCollectionExecuteCallCount() int {
	fake.updateCollectionExecuteMutex.RLock()
	defer fake.updateCollectionExecuteMutex.RUnlock()
	return len(fake.updateCollectionExecuteArgsForCall)
}

func (fake *FakeCollectionsApi) UpdateCollectionExecuteCalls(stub func(openapi.ApiUpdateCollectionRequest) (*openapi.GetCollectionResponse, *http.Response, error)) {
	fake.updateCollectionExecuteMutex.Lock()
	defer fake.updateCollectionExecuteMutex.Unlock()
	fake.UpdateCollectionExecuteStub = stub
}

func (fake *FakeCollectionsApi) UpdateCollectionExecuteArgsForCall(i int) openapi.ApiUpdateCollectionRequest {
	fake.updateCollectionExecuteMutex.RLock()
	defer fake.updateCollectionExecuteMutex.RUnlock()
	argsForCall := fake.updateCollectionExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCollectionsApi) UpdateCollectionExecuteReturns(result1 *openapi.GetCollectionResponse, result2 *http.Response, result3 error) {
	fake.updateCollectionExecuteMutex.Lock()
	defer fake.updateCollectionExecuteMutex.Unlock()
	fake.UpdateCollectionExecuteStub = nil
	fake.updateCollectionExecuteReturns = struct {
		result1 *openapi.GetCollectionResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeCollectionsApi) UpdateCollectionExecuteReturnsOnCall(i int, result1 *openapi.GetCollectionResponse, result2 *http.Response, result3 error) {
	fake.updateCollectionExecuteMutex.Lock()
	defer fake.updateCollectionExecuteMutex.Unlock()
	fake.UpdateCollectionExecuteStub = nil
	if fake.updateCollectionExecuteReturnsOnCall == nil {
		fake.updateCollectionExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.GetCollectionResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.updateCollectionExecuteReturnsOnCall[i] = struct {
		result1 *openapi.GetCollectionResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeCollectionsApi) WorkspaceCollections(arg1 context.Context, arg2 string) openapi.ApiWorkspaceCollectionsRequest {
	fake.workspaceCollectionsMutex.Lock()
	ret, specificReturn := fake.workspaceCollectionsReturnsOnCall[len(fake.workspaceCollectionsArgsForCall)]
	fake.workspaceCollectionsArgsForCall = append(fake.workspaceCollectionsArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.WorkspaceCollectionsStub
	fakeReturns := fake.workspaceCollectionsReturns
	fake.recordInvocation("WorkspaceCollections", []interface{}{arg1, arg2})
	fake.workspaceCollectionsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCollectionsApi) WorkspaceCollectionsCallCount() int {
	fake.workspaceCollectionsMutex.RLock()
	defer fake.workspaceCollectionsMutex.RUnlock()
	return len(fake.workspaceCollectionsArgsForCall)
}

func (fake *FakeCollectionsApi) WorkspaceCollectionsCalls(stub func(context.Context, string) openapi.ApiWorkspaceCollectionsRequest) {
	fake.workspaceCollectionsMutex.Lock()
	defer fake.workspaceCollectionsMutex.Unlock()
	fake.WorkspaceCollectionsStub = stub
}

func (fake *FakeCollectionsApi) WorkspaceCollectionsArgsForCall(i int) (context.Context, string) {
	fake.workspaceCollectionsMutex.RLock()
	defer fake.workspaceCollectionsMutex.RUnlock()
	argsForCall := fake.workspaceCollectionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeCollectionsApi) WorkspaceCollectionsReturns(result1 openapi.ApiWorkspaceCollectionsRequest) {
	fake.workspaceCollectionsMutex.Lock()
	defer fake.workspaceCollectionsMutex.Unlock()
	fake.WorkspaceCollectionsStub = nil
	fake.workspaceCollectionsReturns = struct {
		result1 openapi.ApiWorkspaceCollectionsRequest
	}{result1}
}

func (fake *FakeCollectionsApi) WorkspaceCollectionsReturnsOnCall(i int, result1 openapi.ApiWorkspaceCollectionsRequest) {
	fake.workspaceCollectionsMutex.Lock()
	defer fake.workspaceCollectionsMutex.Unlock()
	fake.WorkspaceCollectionsStub = nil
	if fake.workspaceCollectionsReturnsOnCall == nil {
		fake.workspaceCollectionsReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiWorkspaceCollectionsRequest
		})
	}
	fake.workspaceCollectionsReturnsOnCall[i] = struct {
		result1 openapi.ApiWorkspaceCollectionsRequest
	}{result1}
}

func (fake *FakeCollectionsApi) WorkspaceCollectionsExecute(arg1 openapi.ApiWorkspaceCollectionsRequest) (*openapi.ListCollectionsResponse, *http.Response, error) {
	fake.workspaceCollectionsExecuteMutex.Lock()
	ret, specificReturn := fake.workspaceCollectionsExecuteReturnsOnCall[len(fake.workspaceCollectionsExecuteArgsForCall)]
	fake.workspaceCollectionsExecuteArgsForCall = append(fake.workspaceCollectionsExecuteArgsForCall, struct {
		arg1 openapi.ApiWorkspaceCollectionsRequest
	}{arg1})
	stub := fake.WorkspaceCollectionsExecuteStub
	fakeReturns := fake.workspaceCollectionsExecuteReturns
	fake.recordInvocation("WorkspaceCollectionsExecute", []interface{}{arg1})
	fake.workspaceCollectionsExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeCollectionsApi) WorkspaceCollectionsExecuteCallCount() int {
	fake.workspaceCollectionsExecuteMutex.RLock()
	defer fake.workspaceCollectionsExecuteMutex.RUnlock()
	return len(fake.workspaceCollectionsExecuteArgsForCall)
}

func (fake *FakeCollectionsApi) WorkspaceCollectionsExecuteCalls(stub func(openapi.ApiWorkspaceCollectionsRequest) (*openapi.ListCollectionsResponse, *http.Response, error)) {
	fake.workspaceCollectionsExecuteMutex.Lock()
	defer fake.workspaceCollectionsExecuteMutex.Unlock()
	fake.WorkspaceCollectionsExecuteStub = stub
}

func (fake *FakeCollectionsApi) WorkspaceCollectionsExecuteArgsForCall(i int) openapi.ApiWorkspaceCollectionsRequest {
	fake.workspaceCollectionsExecuteMutex.RLock()
	defer fake.workspaceCollectionsExecuteMutex.RUnlock()
	argsForCall := fake.workspaceCollectionsExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCollectionsApi) WorkspaceCollectionsExecuteReturns(result1 *openapi.ListCollectionsResponse, result2 *http.Response, result3 error) {
	fake.workspaceCollectionsExecuteMutex.Lock()
	defer fake.workspaceCollectionsExecuteMutex.Unlock()
	fake.WorkspaceCollectionsExecuteStub = nil
	fake.workspaceCollectionsExecuteReturns = struct {
		result1 *openapi.ListCollectionsResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeCollectionsApi) WorkspaceCollectionsExecuteReturnsOnCall(i int, result1 *openapi.ListCollectionsResponse, result2 *http.Response, result3 error) {
	fake.workspaceCollectionsExecuteMutex.Lock()
	defer fake.workspaceCollectionsExecuteMutex.Unlock()
	fake.WorkspaceCollectionsExecuteStub = nil
	if fake.workspaceCollectionsExecuteReturnsOnCall == nil {
		fake.workspaceCollectionsExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.ListCollectionsResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.workspaceCollectionsExecuteReturnsOnCall[i] = struct {
		result1 *openapi.ListCollectionsResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeCollectionsApi) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createCollectionMutex.RLock()
	defer fake.createCollectionMutex.RUnlock()
	fake.createCollectionExecuteMutex.RLock()
	defer fake.createCollectionExecuteMutex.RUnlock()
	fake.deleteCollectionMutex.RLock()
	defer fake.deleteCollectionMutex.RUnlock()
	fake.deleteCollectionExecuteMutex.RLock()
	defer fake.deleteCollectionExecuteMutex.RUnlock()
	fake.getCollectionMutex.RLock()
	defer fake.getCollectionMutex.RUnlock()
	fake.getCollectionExecuteMutex.RLock()
	defer fake.getCollectionExecuteMutex.RUnlock()
	fake.getCollectionOffsetsMutex.RLock()
	defer fake.getCollectionOffsetsMutex.RUnlock()
	fake.getCollectionOffsetsExecuteMutex.RLock()
	defer fake.getCollectionOffsetsExecuteMutex.RUnlock()
	fake.listCollectionsMutex.RLock()
	defer fake.listCollectionsMutex.RUnlock()
	fake.listCollectionsExecuteMutex.RLock()
	defer fake.listCollectionsExecuteMutex.RUnlock()
	fake.updateCollectionMutex.RLock()
	defer fake.updateCollectionMutex.RUnlock()
	fake.updateCollectionExecuteMutex.RLock()
	defer fake.updateCollectionExecuteMutex.RUnlock()
	fake.workspaceCollectionsMutex.RLock()
	defer fake.workspaceCollectionsMutex.RUnlock()
	fake.workspaceCollectionsExecuteMutex.RLock()
	defer fake.workspaceCollectionsExecuteMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeCollectionsApi) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ openapi.CollectionsApi = new(FakeCollectionsApi)
