// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"context"
	"net/http"
	"sync"

	"github.com/rockset/rockset-go-client/openapi"
)

type FakeAliasesApi struct {
	CreateAliasStub        func(context.Context, string) openapi.ApiCreateAliasRequest
	createAliasMutex       sync.RWMutex
	createAliasArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	createAliasReturns struct {
		result1 openapi.ApiCreateAliasRequest
	}
	createAliasReturnsOnCall map[int]struct {
		result1 openapi.ApiCreateAliasRequest
	}
	CreateAliasExecuteStub        func(openapi.ApiCreateAliasRequest) (*openapi.CreateAliasResponse, *http.Response, error)
	createAliasExecuteMutex       sync.RWMutex
	createAliasExecuteArgsForCall []struct {
		arg1 openapi.ApiCreateAliasRequest
	}
	createAliasExecuteReturns struct {
		result1 *openapi.CreateAliasResponse
		result2 *http.Response
		result3 error
	}
	createAliasExecuteReturnsOnCall map[int]struct {
		result1 *openapi.CreateAliasResponse
		result2 *http.Response
		result3 error
	}
	DeleteAliasStub        func(context.Context, string, string) openapi.ApiDeleteAliasRequest
	deleteAliasMutex       sync.RWMutex
	deleteAliasArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	deleteAliasReturns struct {
		result1 openapi.ApiDeleteAliasRequest
	}
	deleteAliasReturnsOnCall map[int]struct {
		result1 openapi.ApiDeleteAliasRequest
	}
	DeleteAliasExecuteStub        func(openapi.ApiDeleteAliasRequest) (*openapi.DeleteAliasResponse, *http.Response, error)
	deleteAliasExecuteMutex       sync.RWMutex
	deleteAliasExecuteArgsForCall []struct {
		arg1 openapi.ApiDeleteAliasRequest
	}
	deleteAliasExecuteReturns struct {
		result1 *openapi.DeleteAliasResponse
		result2 *http.Response
		result3 error
	}
	deleteAliasExecuteReturnsOnCall map[int]struct {
		result1 *openapi.DeleteAliasResponse
		result2 *http.Response
		result3 error
	}
	GetAliasStub        func(context.Context, string, string) openapi.ApiGetAliasRequest
	getAliasMutex       sync.RWMutex
	getAliasArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	getAliasReturns struct {
		result1 openapi.ApiGetAliasRequest
	}
	getAliasReturnsOnCall map[int]struct {
		result1 openapi.ApiGetAliasRequest
	}
	GetAliasExecuteStub        func(openapi.ApiGetAliasRequest) (*openapi.GetAliasResponse, *http.Response, error)
	getAliasExecuteMutex       sync.RWMutex
	getAliasExecuteArgsForCall []struct {
		arg1 openapi.ApiGetAliasRequest
	}
	getAliasExecuteReturns struct {
		result1 *openapi.GetAliasResponse
		result2 *http.Response
		result3 error
	}
	getAliasExecuteReturnsOnCall map[int]struct {
		result1 *openapi.GetAliasResponse
		result2 *http.Response
		result3 error
	}
	ListAliasesStub        func(context.Context) openapi.ApiListAliasesRequest
	listAliasesMutex       sync.RWMutex
	listAliasesArgsForCall []struct {
		arg1 context.Context
	}
	listAliasesReturns struct {
		result1 openapi.ApiListAliasesRequest
	}
	listAliasesReturnsOnCall map[int]struct {
		result1 openapi.ApiListAliasesRequest
	}
	ListAliasesExecuteStub        func(openapi.ApiListAliasesRequest) (*openapi.ListAliasesResponse, *http.Response, error)
	listAliasesExecuteMutex       sync.RWMutex
	listAliasesExecuteArgsForCall []struct {
		arg1 openapi.ApiListAliasesRequest
	}
	listAliasesExecuteReturns struct {
		result1 *openapi.ListAliasesResponse
		result2 *http.Response
		result3 error
	}
	listAliasesExecuteReturnsOnCall map[int]struct {
		result1 *openapi.ListAliasesResponse
		result2 *http.Response
		result3 error
	}
	UpdateAliasStub        func(context.Context, string, string) openapi.ApiUpdateAliasRequest
	updateAliasMutex       sync.RWMutex
	updateAliasArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	updateAliasReturns struct {
		result1 openapi.ApiUpdateAliasRequest
	}
	updateAliasReturnsOnCall map[int]struct {
		result1 openapi.ApiUpdateAliasRequest
	}
	UpdateAliasExecuteStub        func(openapi.ApiUpdateAliasRequest) (*openapi.GetAliasResponse, *http.Response, error)
	updateAliasExecuteMutex       sync.RWMutex
	updateAliasExecuteArgsForCall []struct {
		arg1 openapi.ApiUpdateAliasRequest
	}
	updateAliasExecuteReturns struct {
		result1 *openapi.GetAliasResponse
		result2 *http.Response
		result3 error
	}
	updateAliasExecuteReturnsOnCall map[int]struct {
		result1 *openapi.GetAliasResponse
		result2 *http.Response
		result3 error
	}
	WorkspaceAliasesStub        func(context.Context, string) openapi.ApiWorkspaceAliasesRequest
	workspaceAliasesMutex       sync.RWMutex
	workspaceAliasesArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	workspaceAliasesReturns struct {
		result1 openapi.ApiWorkspaceAliasesRequest
	}
	workspaceAliasesReturnsOnCall map[int]struct {
		result1 openapi.ApiWorkspaceAliasesRequest
	}
	WorkspaceAliasesExecuteStub        func(openapi.ApiWorkspaceAliasesRequest) (*openapi.ListAliasesResponse, *http.Response, error)
	workspaceAliasesExecuteMutex       sync.RWMutex
	workspaceAliasesExecuteArgsForCall []struct {
		arg1 openapi.ApiWorkspaceAliasesRequest
	}
	workspaceAliasesExecuteReturns struct {
		result1 *openapi.ListAliasesResponse
		result2 *http.Response
		result3 error
	}
	workspaceAliasesExecuteReturnsOnCall map[int]struct {
		result1 *openapi.ListAliasesResponse
		result2 *http.Response
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeAliasesApi) CreateAlias(arg1 context.Context, arg2 string) openapi.ApiCreateAliasRequest {
	fake.createAliasMutex.Lock()
	ret, specificReturn := fake.createAliasReturnsOnCall[len(fake.createAliasArgsForCall)]
	fake.createAliasArgsForCall = append(fake.createAliasArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.CreateAliasStub
	fakeReturns := fake.createAliasReturns
	fake.recordInvocation("CreateAlias", []interface{}{arg1, arg2})
	fake.createAliasMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAliasesApi) CreateAliasCallCount() int {
	fake.createAliasMutex.RLock()
	defer fake.createAliasMutex.RUnlock()
	return len(fake.createAliasArgsForCall)
}

func (fake *FakeAliasesApi) CreateAliasCalls(stub func(context.Context, string) openapi.ApiCreateAliasRequest) {
	fake.createAliasMutex.Lock()
	defer fake.createAliasMutex.Unlock()
	fake.CreateAliasStub = stub
}

func (fake *FakeAliasesApi) CreateAliasArgsForCall(i int) (context.Context, string) {
	fake.createAliasMutex.RLock()
	defer fake.createAliasMutex.RUnlock()
	argsForCall := fake.createAliasArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAliasesApi) CreateAliasReturns(result1 openapi.ApiCreateAliasRequest) {
	fake.createAliasMutex.Lock()
	defer fake.createAliasMutex.Unlock()
	fake.CreateAliasStub = nil
	fake.createAliasReturns = struct {
		result1 openapi.ApiCreateAliasRequest
	}{result1}
}

func (fake *FakeAliasesApi) CreateAliasReturnsOnCall(i int, result1 openapi.ApiCreateAliasRequest) {
	fake.createAliasMutex.Lock()
	defer fake.createAliasMutex.Unlock()
	fake.CreateAliasStub = nil
	if fake.createAliasReturnsOnCall == nil {
		fake.createAliasReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiCreateAliasRequest
		})
	}
	fake.createAliasReturnsOnCall[i] = struct {
		result1 openapi.ApiCreateAliasRequest
	}{result1}
}

func (fake *FakeAliasesApi) CreateAliasExecute(arg1 openapi.ApiCreateAliasRequest) (*openapi.CreateAliasResponse, *http.Response, error) {
	fake.createAliasExecuteMutex.Lock()
	ret, specificReturn := fake.createAliasExecuteReturnsOnCall[len(fake.createAliasExecuteArgsForCall)]
	fake.createAliasExecuteArgsForCall = append(fake.createAliasExecuteArgsForCall, struct {
		arg1 openapi.ApiCreateAliasRequest
	}{arg1})
	stub := fake.CreateAliasExecuteStub
	fakeReturns := fake.createAliasExecuteReturns
	fake.recordInvocation("CreateAliasExecute", []interface{}{arg1})
	fake.createAliasExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeAliasesApi) CreateAliasExecuteCallCount() int {
	fake.createAliasExecuteMutex.RLock()
	defer fake.createAliasExecuteMutex.RUnlock()
	return len(fake.createAliasExecuteArgsForCall)
}

func (fake *FakeAliasesApi) CreateAliasExecuteCalls(stub func(openapi.ApiCreateAliasRequest) (*openapi.CreateAliasResponse, *http.Response, error)) {
	fake.createAliasExecuteMutex.Lock()
	defer fake.createAliasExecuteMutex.Unlock()
	fake.CreateAliasExecuteStub = stub
}

func (fake *FakeAliasesApi) CreateAliasExecuteArgsForCall(i int) openapi.ApiCreateAliasRequest {
	fake.createAliasExecuteMutex.RLock()
	defer fake.createAliasExecuteMutex.RUnlock()
	argsForCall := fake.createAliasExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAliasesApi) CreateAliasExecuteReturns(result1 *openapi.CreateAliasResponse, result2 *http.Response, result3 error) {
	fake.createAliasExecuteMutex.Lock()
	defer fake.createAliasExecuteMutex.Unlock()
	fake.CreateAliasExecuteStub = nil
	fake.createAliasExecuteReturns = struct {
		result1 *openapi.CreateAliasResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAliasesApi) CreateAliasExecuteReturnsOnCall(i int, result1 *openapi.CreateAliasResponse, result2 *http.Response, result3 error) {
	fake.createAliasExecuteMutex.Lock()
	defer fake.createAliasExecuteMutex.Unlock()
	fake.CreateAliasExecuteStub = nil
	if fake.createAliasExecuteReturnsOnCall == nil {
		fake.createAliasExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.CreateAliasResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.createAliasExecuteReturnsOnCall[i] = struct {
		result1 *openapi.CreateAliasResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAliasesApi) DeleteAlias(arg1 context.Context, arg2 string, arg3 string) openapi.ApiDeleteAliasRequest {
	fake.deleteAliasMutex.Lock()
	ret, specificReturn := fake.deleteAliasReturnsOnCall[len(fake.deleteAliasArgsForCall)]
	fake.deleteAliasArgsForCall = append(fake.deleteAliasArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.DeleteAliasStub
	fakeReturns := fake.deleteAliasReturns
	fake.recordInvocation("DeleteAlias", []interface{}{arg1, arg2, arg3})
	fake.deleteAliasMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAliasesApi) DeleteAliasCallCount() int {
	fake.deleteAliasMutex.RLock()
	defer fake.deleteAliasMutex.RUnlock()
	return len(fake.deleteAliasArgsForCall)
}

func (fake *FakeAliasesApi) DeleteAliasCalls(stub func(context.Context, string, string) openapi.ApiDeleteAliasRequest) {
	fake.deleteAliasMutex.Lock()
	defer fake.deleteAliasMutex.Unlock()
	fake.DeleteAliasStub = stub
}

func (fake *FakeAliasesApi) DeleteAliasArgsForCall(i int) (context.Context, string, string) {
	fake.deleteAliasMutex.RLock()
	defer fake.deleteAliasMutex.RUnlock()
	argsForCall := fake.deleteAliasArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAliasesApi) DeleteAliasReturns(result1 openapi.ApiDeleteAliasRequest) {
	fake.deleteAliasMutex.Lock()
	defer fake.deleteAliasMutex.Unlock()
	fake.DeleteAliasStub = nil
	fake.deleteAliasReturns = struct {
		result1 openapi.ApiDeleteAliasRequest
	}{result1}
}

func (fake *FakeAliasesApi) DeleteAliasReturnsOnCall(i int, result1 openapi.ApiDeleteAliasRequest) {
	fake.deleteAliasMutex.Lock()
	defer fake.deleteAliasMutex.Unlock()
	fake.DeleteAliasStub = nil
	if fake.deleteAliasReturnsOnCall == nil {
		fake.deleteAliasReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiDeleteAliasRequest
		})
	}
	fake.deleteAliasReturnsOnCall[i] = struct {
		result1 openapi.ApiDeleteAliasRequest
	}{result1}
}

func (fake *FakeAliasesApi) DeleteAliasExecute(arg1 openapi.ApiDeleteAliasRequest) (*openapi.DeleteAliasResponse, *http.Response, error) {
	fake.deleteAliasExecuteMutex.Lock()
	ret, specificReturn := fake.deleteAliasExecuteReturnsOnCall[len(fake.deleteAliasExecuteArgsForCall)]
	fake.deleteAliasExecuteArgsForCall = append(fake.deleteAliasExecuteArgsForCall, struct {
		arg1 openapi.ApiDeleteAliasRequest
	}{arg1})
	stub := fake.DeleteAliasExecuteStub
	fakeReturns := fake.deleteAliasExecuteReturns
	fake.recordInvocation("DeleteAliasExecute", []interface{}{arg1})
	fake.deleteAliasExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeAliasesApi) DeleteAliasExecuteCallCount() int {
	fake.deleteAliasExecuteMutex.RLock()
	defer fake.deleteAliasExecuteMutex.RUnlock()
	return len(fake.deleteAliasExecuteArgsForCall)
}

func (fake *FakeAliasesApi) DeleteAliasExecuteCalls(stub func(openapi.ApiDeleteAliasRequest) (*openapi.DeleteAliasResponse, *http.Response, error)) {
	fake.deleteAliasExecuteMutex.Lock()
	defer fake.deleteAliasExecuteMutex.Unlock()
	fake.DeleteAliasExecuteStub = stub
}

func (fake *FakeAliasesApi) DeleteAliasExecuteArgsForCall(i int) openapi.ApiDeleteAliasRequest {
	fake.deleteAliasExecuteMutex.RLock()
	defer fake.deleteAliasExecuteMutex.RUnlock()
	argsForCall := fake.deleteAliasExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAliasesApi) DeleteAliasExecuteReturns(result1 *openapi.DeleteAliasResponse, result2 *http.Response, result3 error) {
	fake.deleteAliasExecuteMutex.Lock()
	defer fake.deleteAliasExecuteMutex.Unlock()
	fake.DeleteAliasExecuteStub = nil
	fake.deleteAliasExecuteReturns = struct {
		result1 *openapi.DeleteAliasResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAliasesApi) DeleteAliasExecuteReturnsOnCall(i int, result1 *openapi.DeleteAliasResponse, result2 *http.Response, result3 error) {
	fake.deleteAliasExecuteMutex.Lock()
	defer fake.deleteAliasExecuteMutex.Unlock()
	fake.DeleteAliasExecuteStub = nil
	if fake.deleteAliasExecuteReturnsOnCall == nil {
		fake.deleteAliasExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.DeleteAliasResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.deleteAliasExecuteReturnsOnCall[i] = struct {
		result1 *openapi.DeleteAliasResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAliasesApi) GetAlias(arg1 context.Context, arg2 string, arg3 string) openapi.ApiGetAliasRequest {
	fake.getAliasMutex.Lock()
	ret, specificReturn := fake.getAliasReturnsOnCall[len(fake.getAliasArgsForCall)]
	fake.getAliasArgsForCall = append(fake.getAliasArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetAliasStub
	fakeReturns := fake.getAliasReturns
	fake.recordInvocation("GetAlias", []interface{}{arg1, arg2, arg3})
	fake.getAliasMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAliasesApi) GetAliasCallCount() int {
	fake.getAliasMutex.RLock()
	defer fake.getAliasMutex.RUnlock()
	return len(fake.getAliasArgsForCall)
}

func (fake *FakeAliasesApi) GetAliasCalls(stub func(context.Context, string, string) openapi.ApiGetAliasRequest) {
	fake.getAliasMutex.Lock()
	defer fake.getAliasMutex.Unlock()
	fake.GetAliasStub = stub
}

func (fake *FakeAliasesApi) GetAliasArgsForCall(i int) (context.Context, string, string) {
	fake.getAliasMutex.RLock()
	defer fake.getAliasMutex.RUnlock()
	argsForCall := fake.getAliasArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAliasesApi) GetAliasReturns(result1 openapi.ApiGetAliasRequest) {
	fake.getAliasMutex.Lock()
	defer fake.getAliasMutex.Unlock()
	fake.GetAliasStub = nil
	fake.getAliasReturns = struct {
		result1 openapi.ApiGetAliasRequest
	}{result1}
}

func (fake *FakeAliasesApi) GetAliasReturnsOnCall(i int, result1 openapi.ApiGetAliasRequest) {
	fake.getAliasMutex.Lock()
	defer fake.getAliasMutex.Unlock()
	fake.GetAliasStub = nil
	if fake.getAliasReturnsOnCall == nil {
		fake.getAliasReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiGetAliasRequest
		})
	}
	fake.getAliasReturnsOnCall[i] = struct {
		result1 openapi.ApiGetAliasRequest
	}{result1}
}

func (fake *FakeAliasesApi) GetAliasExecute(arg1 openapi.ApiGetAliasRequest) (*openapi.GetAliasResponse, *http.Response, error) {
	fake.getAliasExecuteMutex.Lock()
	ret, specificReturn := fake.getAliasExecuteReturnsOnCall[len(fake.getAliasExecuteArgsForCall)]
	fake.getAliasExecuteArgsForCall = append(fake.getAliasExecuteArgsForCall, struct {
		arg1 openapi.ApiGetAliasRequest
	}{arg1})
	stub := fake.GetAliasExecuteStub
	fakeReturns := fake.getAliasExecuteReturns
	fake.recordInvocation("GetAliasExecute", []interface{}{arg1})
	fake.getAliasExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeAliasesApi) GetAliasExecuteCallCount() int {
	fake.getAliasExecuteMutex.RLock()
	defer fake.getAliasExecuteMutex.RUnlock()
	return len(fake.getAliasExecuteArgsForCall)
}

func (fake *FakeAliasesApi) GetAliasExecuteCalls(stub func(openapi.ApiGetAliasRequest) (*openapi.GetAliasResponse, *http.Response, error)) {
	fake.getAliasExecuteMutex.Lock()
	defer fake.getAliasExecuteMutex.Unlock()
	fake.GetAliasExecuteStub = stub
}

func (fake *FakeAliasesApi) GetAliasExecuteArgsForCall(i int) openapi.ApiGetAliasRequest {
	fake.getAliasExecuteMutex.RLock()
	defer fake.getAliasExecuteMutex.RUnlock()
	argsForCall := fake.getAliasExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAliasesApi) GetAliasExecuteReturns(result1 *openapi.GetAliasResponse, result2 *http.Response, result3 error) {
	fake.getAliasExecuteMutex.Lock()
	defer fake.getAliasExecuteMutex.Unlock()
	fake.GetAliasExecuteStub = nil
	fake.getAliasExecuteReturns = struct {
		result1 *openapi.GetAliasResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAliasesApi) GetAliasExecuteReturnsOnCall(i int, result1 *openapi.GetAliasResponse, result2 *http.Response, result3 error) {
	fake.getAliasExecuteMutex.Lock()
	defer fake.getAliasExecuteMutex.Unlock()
	fake.GetAliasExecuteStub = nil
	if fake.getAliasExecuteReturnsOnCall == nil {
		fake.getAliasExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.GetAliasResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.getAliasExecuteReturnsOnCall[i] = struct {
		result1 *openapi.GetAliasResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAliasesApi) ListAliases(arg1 context.Context) openapi.ApiListAliasesRequest {
	fake.listAliasesMutex.Lock()
	ret, specificReturn := fake.listAliasesReturnsOnCall[len(fake.listAliasesArgsForCall)]
	fake.listAliasesArgsForCall = append(fake.listAliasesArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ListAliasesStub
	fakeReturns := fake.listAliasesReturns
	fake.recordInvocation("ListAliases", []interface{}{arg1})
	fake.listAliasesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAliasesApi) ListAliasesCallCount() int {
	fake.listAliasesMutex.RLock()
	defer fake.listAliasesMutex.RUnlock()
	return len(fake.listAliasesArgsForCall)
}

func (fake *FakeAliasesApi) ListAliasesCalls(stub func(context.Context) openapi.ApiListAliasesRequest) {
	fake.listAliasesMutex.Lock()
	defer fake.listAliasesMutex.Unlock()
	fake.ListAliasesStub = stub
}

func (fake *FakeAliasesApi) ListAliasesArgsForCall(i int) context.Context {
	fake.listAliasesMutex.RLock()
	defer fake.listAliasesMutex.RUnlock()
	argsForCall := fake.listAliasesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAliasesApi) ListAliasesReturns(result1 openapi.ApiListAliasesRequest) {
	fake.listAliasesMutex.Lock()
	defer fake.listAliasesMutex.Unlock()
	fake.ListAliasesStub = nil
	fake.listAliasesReturns = struct {
		result1 openapi.ApiListAliasesRequest
	}{result1}
}

func (fake *FakeAliasesApi) ListAliasesReturnsOnCall(i int, result1 openapi.ApiListAliasesRequest) {
	fake.listAliasesMutex.Lock()
	defer fake.listAliasesMutex.Unlock()
	fake.ListAliasesStub = nil
	if fake.listAliasesReturnsOnCall == nil {
		fake.listAliasesReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiListAliasesRequest
		})
	}
	fake.listAliasesReturnsOnCall[i] = struct {
		result1 openapi.ApiListAliasesRequest
	}{result1}
}

func (fake *FakeAliasesApi) ListAliasesExecute(arg1 openapi.ApiListAliasesRequest) (*openapi.ListAliasesResponse, *http.Response, error) {
	fake.listAliasesExecuteMutex.Lock()
	ret, specificReturn := fake.listAliasesExecuteReturnsOnCall[len(fake.listAliasesExecuteArgsForCall)]
	fake.listAliasesExecuteArgsForCall = append(fake.listAliasesExecuteArgsForCall, struct {
		arg1 openapi.ApiListAliasesRequest
	}{arg1})
	stub := fake.ListAliasesExecuteStub
	fakeReturns := fake.listAliasesExecuteReturns
	fake.recordInvocation("ListAliasesExecute", []interface{}{arg1})
	fake.listAliasesExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeAliasesApi) ListAliasesExecuteCallCount() int {
	fake.listAliasesExecuteMutex.RLock()
	defer fake.listAliasesExecuteMutex.RUnlock()
	return len(fake.listAliasesExecuteArgsForCall)
}

func (fake *FakeAliasesApi) ListAliasesExecuteCalls(stub func(openapi.ApiListAliasesRequest) (*openapi.ListAliasesResponse, *http.Response, error)) {
	fake.listAliasesExecuteMutex.Lock()
	defer fake.listAliasesExecuteMutex.Unlock()
	fake.ListAliasesExecuteStub = stub
}

func (fake *FakeAliasesApi) ListAliasesExecuteArgsForCall(i int) openapi.ApiListAliasesRequest {
	fake.listAliasesExecuteMutex.RLock()
	defer fake.listAliasesExecuteMutex.RUnlock()
	argsForCall := fake.listAliasesExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAliasesApi) ListAliasesExecuteReturns(result1 *openapi.ListAliasesResponse, result2 *http.Response, result3 error) {
	fake.listAliasesExecuteMutex.Lock()
	defer fake.listAliasesExecuteMutex.Unlock()
	fake.ListAliasesExecuteStub = nil
	fake.listAliasesExecuteReturns = struct {
		result1 *openapi.ListAliasesResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAliasesApi) ListAliasesExecuteReturnsOnCall(i int, result1 *openapi.ListAliasesResponse, result2 *http.Response, result3 error) {
	fake.listAliasesExecuteMutex.Lock()
	defer fake.listAliasesExecuteMutex.Unlock()
	fake.ListAliasesExecuteStub = nil
	if fake.listAliasesExecuteReturnsOnCall == nil {
		fake.listAliasesExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.ListAliasesResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.listAliasesExecuteReturnsOnCall[i] = struct {
		result1 *openapi.ListAliasesResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAliasesApi) UpdateAlias(arg1 context.Context, arg2 string, arg3 string) openapi.ApiUpdateAliasRequest {
	fake.updateAliasMutex.Lock()
	ret, specificReturn := fake.updateAliasReturnsOnCall[len(fake.updateAliasArgsForCall)]
	fake.updateAliasArgsForCall = append(fake.updateAliasArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.UpdateAliasStub
	fakeReturns := fake.updateAliasReturns
	fake.recordInvocation("UpdateAlias", []interface{}{arg1, arg2, arg3})
	fake.updateAliasMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAliasesApi) UpdateAliasCallCount() int {
	fake.updateAliasMutex.RLock()
	defer fake.updateAliasMutex.RUnlock()
	return len(fake.updateAliasArgsForCall)
}

func (fake *FakeAliasesApi) UpdateAliasCalls(stub func(context.Context, string, string) openapi.ApiUpdateAliasRequest) {
	fake.updateAliasMutex.Lock()
	defer fake.updateAliasMutex.Unlock()
	fake.UpdateAliasStub = stub
}

func (fake *FakeAliasesApi) UpdateAliasArgsForCall(i int) (context.Context, string, string) {
	fake.updateAliasMutex.RLock()
	defer fake.updateAliasMutex.RUnlock()
	argsForCall := fake.updateAliasArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAliasesApi) UpdateAliasReturns(result1 openapi.ApiUpdateAliasRequest) {
	fake.updateAliasMutex.Lock()
	defer fake.updateAliasMutex.Unlock()
	fake.UpdateAliasStub = nil
	fake.updateAliasReturns = struct {
		result1 openapi.ApiUpdateAliasRequest
	}{result1}
}

func (fake *FakeAliasesApi) UpdateAliasReturnsOnCall(i int, result1 openapi.ApiUpdateAliasRequest) {
	fake.updateAliasMutex.Lock()
	defer fake.updateAliasMutex.Unlock()
	fake.UpdateAliasStub = nil
	if fake.updateAliasReturnsOnCall == nil {
		fake.updateAliasReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiUpdateAliasRequest
		})
	}
	fake.updateAliasReturnsOnCall[i] = struct {
		result1 openapi.ApiUpdateAliasRequest
	}{result1}
}

func (fake *FakeAliasesApi) UpdateAliasExecute(arg1 openapi.ApiUpdateAliasRequest) (*openapi.GetAliasResponse, *http.Response, error) {
	fake.updateAliasExecuteMutex.Lock()
	ret, specificReturn := fake.updateAliasExecuteReturnsOnCall[len(fake.updateAliasExecuteArgsForCall)]
	fake.updateAliasExecuteArgsForCall = append(fake.updateAliasExecuteArgsForCall, struct {
		arg1 openapi.ApiUpdateAliasRequest
	}{arg1})
	stub := fake.UpdateAliasExecuteStub
	fakeReturns := fake.updateAliasExecuteReturns
	fake.recordInvocation("UpdateAliasExecute", []interface{}{arg1})
	fake.updateAliasExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeAliasesApi) UpdateAliasExecuteCallCount() int {
	fake.updateAliasExecuteMutex.RLock()
	defer fake.updateAliasExecuteMutex.RUnlock()
	return len(fake.updateAliasExecuteArgsForCall)
}

func (fake *FakeAliasesApi) UpdateAliasExecuteCalls(stub func(openapi.ApiUpdateAliasRequest) (*openapi.GetAliasResponse, *http.Response, error)) {
	fake.updateAliasExecuteMutex.Lock()
	defer fake.updateAliasExecuteMutex.Unlock()
	fake.UpdateAliasExecuteStub = stub
}

func (fake *FakeAliasesApi) UpdateAliasExecuteArgsForCall(i int) openapi.ApiUpdateAliasRequest {
	fake.updateAliasExecuteMutex.RLock()
	defer fake.updateAliasExecuteMutex.RUnlock()
	argsForCall := fake.updateAliasExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAliasesApi) UpdateAliasExecuteReturns(result1 *openapi.GetAliasResponse, result2 *http.Response, result3 error) {
	fake.updateAliasExecuteMutex.Lock()
	defer fake.updateAliasExecuteMutex.Unlock()
	fake.UpdateAliasExecuteStub = nil
	fake.updateAliasExecuteReturns = struct {
		result1 *openapi.GetAliasResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAliasesApi) UpdateAliasExecuteReturnsOnCall(i int, result1 *openapi.GetAliasResponse, result2 *http.Response, result3 error) {
	fake.updateAliasExecuteMutex.Lock()
	defer fake.updateAliasExecuteMutex.Unlock()
	fake.UpdateAliasExecuteStub = nil
	if fake.updateAliasExecuteReturnsOnCall == nil {
		fake.updateAliasExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.GetAliasResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.updateAliasExecuteReturnsOnCall[i] = struct {
		result1 *openapi.GetAliasResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAliasesApi) WorkspaceAliases(arg1 context.Context, arg2 string) openapi.ApiWorkspaceAliasesRequest {
	fake.workspaceAliasesMutex.Lock()
	ret, specificReturn := fake.workspaceAliasesReturnsOnCall[len(fake.workspaceAliasesArgsForCall)]
	fake.workspaceAliasesArgsForCall = append(fake.workspaceAliasesArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.WorkspaceAliasesStub
	fakeReturns := fake.workspaceAliasesReturns
	fake.recordInvocation("WorkspaceAliases", []interface{}{arg1, arg2})
	fake.workspaceAliasesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAliasesApi) WorkspaceAliasesCallCount() int {
	fake.workspaceAliasesMutex.RLock()
	defer fake.workspaceAliasesMutex.RUnlock()
	return len(fake.workspaceAliasesArgsForCall)
}

func (fake *FakeAliasesApi) WorkspaceAliasesCalls(stub func(context.Context, string) openapi.ApiWorkspaceAliasesRequest) {
	fake.workspaceAliasesMutex.Lock()
	defer fake.workspaceAliasesMutex.Unlock()
	fake.WorkspaceAliasesStub = stub
}

func (fake *FakeAliasesApi) WorkspaceAliasesArgsForCall(i int) (context.Context, string) {
	fake.workspaceAliasesMutex.RLock()
	defer fake.workspaceAliasesMutex.RUnlock()
	argsForCall := fake.workspaceAliasesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAliasesApi) WorkspaceAliasesReturns(result1 openapi.ApiWorkspaceAliasesRequest) {
	fake.workspaceAliasesMutex.Lock()
	defer fake.workspaceAliasesMutex.Unlock()
	fake.WorkspaceAliasesStub = nil
	fake.workspaceAliasesReturns = struct {
		result1 openapi.ApiWorkspaceAliasesRequest
	}{result1}
}

func (fake *FakeAliasesApi) WorkspaceAliasesReturnsOnCall(i int, result1 openapi.ApiWorkspaceAliasesRequest) {
	fake.workspaceAliasesMutex.Lock()
	defer fake.workspaceAliasesMutex.Unlock()
	fake.WorkspaceAliasesStub = nil
	if fake.workspaceAliasesReturnsOnCall == nil {
		fake.workspaceAliasesReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiWorkspaceAliasesRequest
		})
	}
	fake.workspaceAliasesReturnsOnCall[i] = struct {
		result1 openapi.ApiWorkspaceAliasesRequest
	}{result1}
}

func (fake *FakeAliasesApi) WorkspaceAliasesExecute(arg1 openapi.ApiWorkspaceAliasesRequest) (*openapi.ListAliasesResponse, *http.Response, error) {
	fake.workspaceAliasesExecuteMutex.Lock()
	ret, specificReturn := fake.workspaceAliasesExecuteReturnsOnCall[len(fake.workspaceAliasesExecuteArgsForCall)]
	fake.workspaceAliasesExecuteArgsForCall = append(fake.workspaceAliasesExecuteArgsForCall, struct {
		arg1 openapi.ApiWorkspaceAliasesRequest
	}{arg1})
	stub := fake.WorkspaceAliasesExecuteStub
	fakeReturns := fake.workspaceAliasesExecuteReturns
	fake.recordInvocation("WorkspaceAliasesExecute", []interface{}{arg1})
	fake.workspaceAliasesExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeAliasesApi) WorkspaceAliasesExecuteCallCount() int {
	fake.workspaceAliasesExecuteMutex.RLock()
	defer fake.workspaceAliasesExecuteMutex.RUnlock()
	return len(fake.workspaceAliasesExecuteArgsForCall)
}

func (fake *FakeAliasesApi) WorkspaceAliasesExecuteCalls(stub func(openapi.ApiWorkspaceAliasesRequest) (*openapi.ListAliasesResponse, *http.Response, error)) {
	fake.workspaceAliasesExecuteMutex.Lock()
	defer fake.workspaceAliasesExecuteMutex.Unlock()
	fake.WorkspaceAliasesExecuteStub = stub
}

func (fake *FakeAliasesApi) WorkspaceAliasesExecuteArgsForCall(i int) openapi.ApiWorkspaceAliasesRequest {
	fake.workspaceAliasesExecuteMutex.RLock()
	defer fake.workspaceAliasesExecuteMutex.RUnlock()
	argsForCall := fake.workspaceAliasesExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAliasesApi) WorkspaceAliasesExecuteReturns(result1 *openapi.ListAliasesResponse, result2 *http.Response, result3 error) {
	fake.workspaceAliasesExecuteMutex.Lock()
	defer fake.workspaceAliasesExecuteMutex.Unlock()
	fake.WorkspaceAliasesExecuteStub = nil
	fake.workspaceAliasesExecuteReturns = struct {
		result1 *openapi.ListAliasesResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAliasesApi) WorkspaceAliasesExecuteReturnsOnCall(i int, result1 *openapi.ListAliasesResponse, result2 *http.Response, result3 error) {
	fake.workspaceAliasesExecuteMutex.Lock()
	defer fake.workspaceAliasesExecuteMutex.Unlock()
	fake.WorkspaceAliasesExecuteStub = nil
	if fake.workspaceAliasesExecuteReturnsOnCall == nil {
		fake.workspaceAliasesExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.ListAliasesResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.workspaceAliasesExecuteReturnsOnCall[i] = struct {
		result1 *openapi.ListAliasesResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAliasesApi) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createAliasMutex.RLock()
	defer fake.createAliasMutex.RUnlock()
	fake.createAliasExecuteMutex.RLock()
	defer fake.createAliasExecuteMutex.RUnlock()
	fake.deleteAliasMutex.RLock()
	defer fake.deleteAliasMutex.RUnlock()
	fake.deleteAliasExecuteMutex.RLock()
	defer fake.deleteAliasExecuteMutex.RUnlock()
	fake.getAliasMutex.RLock()
	defer fake.getAliasMutex.RUnlock()
	fake.getAliasExecuteMutex.RLock()
	defer fake.getAliasExecuteMutex.RUnlock()
	fake.listAliasesMutex.RLock()
	defer fake.listAliasesMutex.RUnlock()
	fake.listAliasesExecuteMutex.RLock()
	defer fake.listAliasesExecuteMutex.RUnlock()
	fake.updateAliasMutex.RLock()
	defer fake.updateAliasMutex.RUnlock()
	fake.updateAliasExecuteMutex.RLock()
	defer fake.updateAliasExecuteMutex.RUnlock()
	fake.workspaceAliasesMutex.RLock()
	defer fake.workspaceAliasesMutex.RUnlock()
	fake.workspaceAliasesExecuteMutex.RLock()
	defer fake.workspaceAliasesExecuteMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeAliasesApi) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ openapi.AliasesApi = new(FakeAliasesApi)
