// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"context"
	"net/http"
	"sync"

	"github.com/rockset/rockset-go-client/openapi"
)

type FakeDocumentsApi struct {
	AddDocumentsStub        func(context.Context, string, string) openapi.ApiAddDocumentsRequest
	addDocumentsMutex       sync.RWMutex
	addDocumentsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	addDocumentsReturns struct {
		result1 openapi.ApiAddDocumentsRequest
	}
	addDocumentsReturnsOnCall map[int]struct {
		result1 openapi.ApiAddDocumentsRequest
	}
	AddDocumentsExecuteStub        func(openapi.ApiAddDocumentsRequest) (*openapi.AddDocumentsResponse, *http.Response, error)
	addDocumentsExecuteMutex       sync.RWMutex
	addDocumentsExecuteArgsForCall []struct {
		arg1 openapi.ApiAddDocumentsRequest
	}
	addDocumentsExecuteReturns struct {
		result1 *openapi.AddDocumentsResponse
		result2 *http.Response
		result3 error
	}
	addDocumentsExecuteReturnsOnCall map[int]struct {
		result1 *openapi.AddDocumentsResponse
		result2 *http.Response
		result3 error
	}
	DeleteDocumentsStub        func(context.Context, string, string) openapi.ApiDeleteDocumentsRequest
	deleteDocumentsMutex       sync.RWMutex
	deleteDocumentsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	deleteDocumentsReturns struct {
		result1 openapi.ApiDeleteDocumentsRequest
	}
	deleteDocumentsReturnsOnCall map[int]struct {
		result1 openapi.ApiDeleteDocumentsRequest
	}
	DeleteDocumentsExecuteStub        func(openapi.ApiDeleteDocumentsRequest) (*openapi.DeleteDocumentsResponse, *http.Response, error)
	deleteDocumentsExecuteMutex       sync.RWMutex
	deleteDocumentsExecuteArgsForCall []struct {
		arg1 openapi.ApiDeleteDocumentsRequest
	}
	deleteDocumentsExecuteReturns struct {
		result1 *openapi.DeleteDocumentsResponse
		result2 *http.Response
		result3 error
	}
	deleteDocumentsExecuteReturnsOnCall map[int]struct {
		result1 *openapi.DeleteDocumentsResponse
		result2 *http.Response
		result3 error
	}
	PatchDocumentsStub        func(context.Context, string, string) openapi.ApiPatchDocumentsRequest
	patchDocumentsMutex       sync.RWMutex
	patchDocumentsArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	patchDocumentsReturns struct {
		result1 openapi.ApiPatchDocumentsRequest
	}
	patchDocumentsReturnsOnCall map[int]struct {
		result1 openapi.ApiPatchDocumentsRequest
	}
	PatchDocumentsExecuteStub        func(openapi.ApiPatchDocumentsRequest) (*openapi.PatchDocumentsResponse, *http.Response, error)
	patchDocumentsExecuteMutex       sync.RWMutex
	patchDocumentsExecuteArgsForCall []struct {
		arg1 openapi.ApiPatchDocumentsRequest
	}
	patchDocumentsExecuteReturns struct {
		result1 *openapi.PatchDocumentsResponse
		result2 *http.Response
		result3 error
	}
	patchDocumentsExecuteReturnsOnCall map[int]struct {
		result1 *openapi.PatchDocumentsResponse
		result2 *http.Response
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDocumentsApi) AddDocuments(arg1 context.Context, arg2 string, arg3 string) openapi.ApiAddDocumentsRequest {
	fake.addDocumentsMutex.Lock()
	ret, specificReturn := fake.addDocumentsReturnsOnCall[len(fake.addDocumentsArgsForCall)]
	fake.addDocumentsArgsForCall = append(fake.addDocumentsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.AddDocumentsStub
	fakeReturns := fake.addDocumentsReturns
	fake.recordInvocation("AddDocuments", []interface{}{arg1, arg2, arg3})
	fake.addDocumentsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDocumentsApi) AddDocumentsCallCount() int {
	fake.addDocumentsMutex.RLock()
	defer fake.addDocumentsMutex.RUnlock()
	return len(fake.addDocumentsArgsForCall)
}

func (fake *FakeDocumentsApi) AddDocumentsCalls(stub func(context.Context, string, string) openapi.ApiAddDocumentsRequest) {
	fake.addDocumentsMutex.Lock()
	defer fake.addDocumentsMutex.Unlock()
	fake.AddDocumentsStub = stub
}

func (fake *FakeDocumentsApi) AddDocumentsArgsForCall(i int) (context.Context, string, string) {
	fake.addDocumentsMutex.RLock()
	defer fake.addDocumentsMutex.RUnlock()
	argsForCall := fake.addDocumentsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDocumentsApi) AddDocumentsReturns(result1 openapi.ApiAddDocumentsRequest) {
	fake.addDocumentsMutex.Lock()
	defer fake.addDocumentsMutex.Unlock()
	fake.AddDocumentsStub = nil
	fake.addDocumentsReturns = struct {
		result1 openapi.ApiAddDocumentsRequest
	}{result1}
}

func (fake *FakeDocumentsApi) AddDocumentsReturnsOnCall(i int, result1 openapi.ApiAddDocumentsRequest) {
	fake.addDocumentsMutex.Lock()
	defer fake.addDocumentsMutex.Unlock()
	fake.AddDocumentsStub = nil
	if fake.addDocumentsReturnsOnCall == nil {
		fake.addDocumentsReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiAddDocumentsRequest
		})
	}
	fake.addDocumentsReturnsOnCall[i] = struct {
		result1 openapi.ApiAddDocumentsRequest
	}{result1}
}

func (fake *FakeDocumentsApi) AddDocumentsExecute(arg1 openapi.ApiAddDocumentsRequest) (*openapi.AddDocumentsResponse, *http.Response, error) {
	fake.addDocumentsExecuteMutex.Lock()
	ret, specificReturn := fake.addDocumentsExecuteReturnsOnCall[len(fake.addDocumentsExecuteArgsForCall)]
	fake.addDocumentsExecuteArgsForCall = append(fake.addDocumentsExecuteArgsForCall, struct {
		arg1 openapi.ApiAddDocumentsRequest
	}{arg1})
	stub := fake.AddDocumentsExecuteStub
	fakeReturns := fake.addDocumentsExecuteReturns
	fake.recordInvocation("AddDocumentsExecute", []interface{}{arg1})
	fake.addDocumentsExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeDocumentsApi) AddDocumentsExecuteCallCount() int {
	fake.addDocumentsExecuteMutex.RLock()
	defer fake.addDocumentsExecuteMutex.RUnlock()
	return len(fake.addDocumentsExecuteArgsForCall)
}

func (fake *FakeDocumentsApi) AddDocumentsExecuteCalls(stub func(openapi.ApiAddDocumentsRequest) (*openapi.AddDocumentsResponse, *http.Response, error)) {
	fake.addDocumentsExecuteMutex.Lock()
	defer fake.addDocumentsExecuteMutex.Unlock()
	fake.AddDocumentsExecuteStub = stub
}

func (fake *FakeDocumentsApi) AddDocumentsExecuteArgsForCall(i int) openapi.ApiAddDocumentsRequest {
	fake.addDocumentsExecuteMutex.RLock()
	defer fake.addDocumentsExecuteMutex.RUnlock()
	argsForCall := fake.addDocumentsExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDocumentsApi) AddDocumentsExecuteReturns(result1 *openapi.AddDocumentsResponse, result2 *http.Response, result3 error) {
	fake.addDocumentsExecuteMutex.Lock()
	defer fake.addDocumentsExecuteMutex.Unlock()
	fake.AddDocumentsExecuteStub = nil
	fake.addDocumentsExecuteReturns = struct {
		result1 *openapi.AddDocumentsResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDocumentsApi) AddDocumentsExecuteReturnsOnCall(i int, result1 *openapi.AddDocumentsResponse, result2 *http.Response, result3 error) {
	fake.addDocumentsExecuteMutex.Lock()
	defer fake.addDocumentsExecuteMutex.Unlock()
	fake.AddDocumentsExecuteStub = nil
	if fake.addDocumentsExecuteReturnsOnCall == nil {
		fake.addDocumentsExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.AddDocumentsResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.addDocumentsExecuteReturnsOnCall[i] = struct {
		result1 *openapi.AddDocumentsResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDocumentsApi) DeleteDocuments(arg1 context.Context, arg2 string, arg3 string) openapi.ApiDeleteDocumentsRequest {
	fake.deleteDocumentsMutex.Lock()
	ret, specificReturn := fake.deleteDocumentsReturnsOnCall[len(fake.deleteDocumentsArgsForCall)]
	fake.deleteDocumentsArgsForCall = append(fake.deleteDocumentsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.DeleteDocumentsStub
	fakeReturns := fake.deleteDocumentsReturns
	fake.recordInvocation("DeleteDocuments", []interface{}{arg1, arg2, arg3})
	fake.deleteDocumentsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDocumentsApi) DeleteDocumentsCallCount() int {
	fake.deleteDocumentsMutex.RLock()
	defer fake.deleteDocumentsMutex.RUnlock()
	return len(fake.deleteDocumentsArgsForCall)
}

func (fake *FakeDocumentsApi) DeleteDocumentsCalls(stub func(context.Context, string, string) openapi.ApiDeleteDocumentsRequest) {
	fake.deleteDocumentsMutex.Lock()
	defer fake.deleteDocumentsMutex.Unlock()
	fake.DeleteDocumentsStub = stub
}

func (fake *FakeDocumentsApi) DeleteDocumentsArgsForCall(i int) (context.Context, string, string) {
	fake.deleteDocumentsMutex.RLock()
	defer fake.deleteDocumentsMutex.RUnlock()
	argsForCall := fake.deleteDocumentsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDocumentsApi) DeleteDocumentsReturns(result1 openapi.ApiDeleteDocumentsRequest) {
	fake.deleteDocumentsMutex.Lock()
	defer fake.deleteDocumentsMutex.Unlock()
	fake.DeleteDocumentsStub = nil
	fake.deleteDocumentsReturns = struct {
		result1 openapi.ApiDeleteDocumentsRequest
	}{result1}
}

func (fake *FakeDocumentsApi) DeleteDocumentsReturnsOnCall(i int, result1 openapi.ApiDeleteDocumentsRequest) {
	fake.deleteDocumentsMutex.Lock()
	defer fake.deleteDocumentsMutex.Unlock()
	fake.DeleteDocumentsStub = nil
	if fake.deleteDocumentsReturnsOnCall == nil {
		fake.deleteDocumentsReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiDeleteDocumentsRequest
		})
	}
	fake.deleteDocumentsReturnsOnCall[i] = struct {
		result1 openapi.ApiDeleteDocumentsRequest
	}{result1}
}

func (fake *FakeDocumentsApi) DeleteDocumentsExecute(arg1 openapi.ApiDeleteDocumentsRequest) (*openapi.DeleteDocumentsResponse, *http.Response, error) {
	fake.deleteDocumentsExecuteMutex.Lock()
	ret, specificReturn := fake.deleteDocumentsExecuteReturnsOnCall[len(fake.deleteDocumentsExecuteArgsForCall)]
	fake.deleteDocumentsExecuteArgsForCall = append(fake.deleteDocumentsExecuteArgsForCall, struct {
		arg1 openapi.ApiDeleteDocumentsRequest
	}{arg1})
	stub := fake.DeleteDocumentsExecuteStub
	fakeReturns := fake.deleteDocumentsExecuteReturns
	fake.recordInvocation("DeleteDocumentsExecute", []interface{}{arg1})
	fake.deleteDocumentsExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeDocumentsApi) DeleteDocumentsExecuteCallCount() int {
	fake.deleteDocumentsExecuteMutex.RLock()
	defer fake.deleteDocumentsExecuteMutex.RUnlock()
	return len(fake.deleteDocumentsExecuteArgsForCall)
}

func (fake *FakeDocumentsApi) DeleteDocumentsExecuteCalls(stub func(openapi.ApiDeleteDocumentsRequest) (*openapi.DeleteDocumentsResponse, *http.Response, error)) {
	fake.deleteDocumentsExecuteMutex.Lock()
	defer fake.deleteDocumentsExecuteMutex.Unlock()
	fake.DeleteDocumentsExecuteStub = stub
}

func (fake *FakeDocumentsApi) DeleteDocumentsExecuteArgsForCall(i int) openapi.ApiDeleteDocumentsRequest {
	fake.deleteDocumentsExecuteMutex.RLock()
	defer fake.deleteDocumentsExecuteMutex.RUnlock()
	argsForCall := fake.deleteDocumentsExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDocumentsApi) DeleteDocumentsExecuteReturns(result1 *openapi.DeleteDocumentsResponse, result2 *http.Response, result3 error) {
	fake.deleteDocumentsExecuteMutex.Lock()
	defer fake.deleteDocumentsExecuteMutex.Unlock()
	fake.DeleteDocumentsExecuteStub = nil
	fake.deleteDocumentsExecuteReturns = struct {
		result1 *openapi.DeleteDocumentsResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDocumentsApi) DeleteDocumentsExecuteReturnsOnCall(i int, result1 *openapi.DeleteDocumentsResponse, result2 *http.Response, result3 error) {
	fake.deleteDocumentsExecuteMutex.Lock()
	defer fake.deleteDocumentsExecuteMutex.Unlock()
	fake.DeleteDocumentsExecuteStub = nil
	if fake.deleteDocumentsExecuteReturnsOnCall == nil {
		fake.deleteDocumentsExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.DeleteDocumentsResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.deleteDocumentsExecuteReturnsOnCall[i] = struct {
		result1 *openapi.DeleteDocumentsResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDocumentsApi) PatchDocuments(arg1 context.Context, arg2 string, arg3 string) openapi.ApiPatchDocumentsRequest {
	fake.patchDocumentsMutex.Lock()
	ret, specificReturn := fake.patchDocumentsReturnsOnCall[len(fake.patchDocumentsArgsForCall)]
	fake.patchDocumentsArgsForCall = append(fake.patchDocumentsArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.PatchDocumentsStub
	fakeReturns := fake.patchDocumentsReturns
	fake.recordInvocation("PatchDocuments", []interface{}{arg1, arg2, arg3})
	fake.patchDocumentsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDocumentsApi) PatchDocumentsCallCount() int {
	fake.patchDocumentsMutex.RLock()
	defer fake.patchDocumentsMutex.RUnlock()
	return len(fake.patchDocumentsArgsForCall)
}

func (fake *FakeDocumentsApi) PatchDocumentsCalls(stub func(context.Context, string, string) openapi.ApiPatchDocumentsRequest) {
	fake.patchDocumentsMutex.Lock()
	defer fake.patchDocumentsMutex.Unlock()
	fake.PatchDocumentsStub = stub
}

func (fake *FakeDocumentsApi) PatchDocumentsArgsForCall(i int) (context.Context, string, string) {
	fake.patchDocumentsMutex.RLock()
	defer fake.patchDocumentsMutex.RUnlock()
	argsForCall := fake.patchDocumentsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDocumentsApi) PatchDocumentsReturns(result1 openapi.ApiPatchDocumentsRequest) {
	fake.patchDocumentsMutex.Lock()
	defer fake.patchDocumentsMutex.Unlock()
	fake.PatchDocumentsStub = nil
	fake.patchDocumentsReturns = struct {
		result1 openapi.ApiPatchDocumentsRequest
	}{result1}
}

func (fake *FakeDocumentsApi) PatchDocumentsReturnsOnCall(i int, result1 openapi.ApiPatchDocumentsRequest) {
	fake.patchDocumentsMutex.Lock()
	defer fake.patchDocumentsMutex.Unlock()
	fake.PatchDocumentsStub = nil
	if fake.patchDocumentsReturnsOnCall == nil {
		fake.patchDocumentsReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiPatchDocumentsRequest
		})
	}
	fake.patchDocumentsReturnsOnCall[i] = struct {
		result1 openapi.ApiPatchDocumentsRequest
	}{result1}
}

func (fake *FakeDocumentsApi) PatchDocumentsExecute(arg1 openapi.ApiPatchDocumentsRequest) (*openapi.PatchDocumentsResponse, *http.Response, error) {
	fake.patchDocumentsExecuteMutex.Lock()
	ret, specificReturn := fake.patchDocumentsExecuteReturnsOnCall[len(fake.patchDocumentsExecuteArgsForCall)]
	fake.patchDocumentsExecuteArgsForCall = append(fake.patchDocumentsExecuteArgsForCall, struct {
		arg1 openapi.ApiPatchDocumentsRequest
	}{arg1})
	stub := fake.PatchDocumentsExecuteStub
	fakeReturns := fake.patchDocumentsExecuteReturns
	fake.recordInvocation("PatchDocumentsExecute", []interface{}{arg1})
	fake.patchDocumentsExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeDocumentsApi) PatchDocumentsExecuteCallCount() int {
	fake.patchDocumentsExecuteMutex.RLock()
	defer fake.patchDocumentsExecuteMutex.RUnlock()
	return len(fake.patchDocumentsExecuteArgsForCall)
}

func (fake *FakeDocumentsApi) PatchDocumentsExecuteCalls(stub func(openapi.ApiPatchDocumentsRequest) (*openapi.PatchDocumentsResponse, *http.Response, error)) {
	fake.patchDocumentsExecuteMutex.Lock()
	defer fake.patchDocumentsExecuteMutex.Unlock()
	fake.PatchDocumentsExecuteStub = stub
}

func (fake *FakeDocumentsApi) PatchDocumentsExecuteArgsForCall(i int) openapi.ApiPatchDocumentsRequest {
	fake.patchDocumentsExecuteMutex.RLock()
	defer fake.patchDocumentsExecuteMutex.RUnlock()
	argsForCall := fake.patchDocumentsExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDocumentsApi) PatchDocumentsExecuteReturns(result1 *openapi.PatchDocumentsResponse, result2 *http.Response, result3 error) {
	fake.patchDocumentsExecuteMutex.Lock()
	defer fake.patchDocumentsExecuteMutex.Unlock()
	fake.PatchDocumentsExecuteStub = nil
	fake.patchDocumentsExecuteReturns = struct {
		result1 *openapi.PatchDocumentsResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDocumentsApi) PatchDocumentsExecuteReturnsOnCall(i int, result1 *openapi.PatchDocumentsResponse, result2 *http.Response, result3 error) {
	fake.patchDocumentsExecuteMutex.Lock()
	defer fake.patchDocumentsExecuteMutex.Unlock()
	fake.PatchDocumentsExecuteStub = nil
	if fake.patchDocumentsExecuteReturnsOnCall == nil {
		fake.patchDocumentsExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.PatchDocumentsResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.patchDocumentsExecuteReturnsOnCall[i] = struct {
		result1 *openapi.PatchDocumentsResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDocumentsApi) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addDocumentsMutex.RLock()
	defer fake.addDocumentsMutex.RUnlock()
	fake.addDocumentsExecuteMutex.RLock()
	defer fake.addDocumentsExecuteMutex.RUnlock()
	fake.deleteDocumentsMutex.RLock()
	defer fake.deleteDocumentsMutex.RUnlock()
	fake.deleteDocumentsExecuteMutex.RLock()
	defer fake.deleteDocumentsExecuteMutex.RUnlock()
	fake.patchDocumentsMutex.RLock()
	defer fake.patchDocumentsMutex.RUnlock()
	fake.patchDocumentsExecuteMutex.RLock()
	defer fake.patchDocumentsExecuteMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeDocumentsApi) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ openapi.DocumentsApi = new(FakeDocumentsApi)
