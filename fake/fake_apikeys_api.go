// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"context"
	"net/http"
	"sync"

	"github.com/rockset/rockset-go-client/openapi"
)

type FakeAPIKeysApi struct {
	CreateApiKeyStub        func(context.Context) openapi.ApiCreateApiKeyRequest
	createApiKeyMutex       sync.RWMutex
	createApiKeyArgsForCall []struct {
		arg1 context.Context
	}
	createApiKeyReturns struct {
		result1 openapi.ApiCreateApiKeyRequest
	}
	createApiKeyReturnsOnCall map[int]struct {
		result1 openapi.ApiCreateApiKeyRequest
	}
	CreateApiKeyExecuteStub        func(openapi.ApiCreateApiKeyRequest) (*openapi.CreateApiKeyResponse, *http.Response, error)
	createApiKeyExecuteMutex       sync.RWMutex
	createApiKeyExecuteArgsForCall []struct {
		arg1 openapi.ApiCreateApiKeyRequest
	}
	createApiKeyExecuteReturns struct {
		result1 *openapi.CreateApiKeyResponse
		result2 *http.Response
		result3 error
	}
	createApiKeyExecuteReturnsOnCall map[int]struct {
		result1 *openapi.CreateApiKeyResponse
		result2 *http.Response
		result3 error
	}
	DeleteApiKeyStub        func(context.Context, string, string) openapi.ApiDeleteApiKeyRequest
	deleteApiKeyMutex       sync.RWMutex
	deleteApiKeyArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	deleteApiKeyReturns struct {
		result1 openapi.ApiDeleteApiKeyRequest
	}
	deleteApiKeyReturnsOnCall map[int]struct {
		result1 openapi.ApiDeleteApiKeyRequest
	}
	DeleteApiKeyExecuteStub        func(openapi.ApiDeleteApiKeyRequest) (*openapi.DeleteApiKeyResponse, *http.Response, error)
	deleteApiKeyExecuteMutex       sync.RWMutex
	deleteApiKeyExecuteArgsForCall []struct {
		arg1 openapi.ApiDeleteApiKeyRequest
	}
	deleteApiKeyExecuteReturns struct {
		result1 *openapi.DeleteApiKeyResponse
		result2 *http.Response
		result3 error
	}
	deleteApiKeyExecuteReturnsOnCall map[int]struct {
		result1 *openapi.DeleteApiKeyResponse
		result2 *http.Response
		result3 error
	}
	GetApiKeyStub        func(context.Context, string, string) openapi.ApiGetApiKeyRequest
	getApiKeyMutex       sync.RWMutex
	getApiKeyArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	getApiKeyReturns struct {
		result1 openapi.ApiGetApiKeyRequest
	}
	getApiKeyReturnsOnCall map[int]struct {
		result1 openapi.ApiGetApiKeyRequest
	}
	GetApiKeyExecuteStub        func(openapi.ApiGetApiKeyRequest) (*openapi.GetApiKeyResponse, *http.Response, error)
	getApiKeyExecuteMutex       sync.RWMutex
	getApiKeyExecuteArgsForCall []struct {
		arg1 openapi.ApiGetApiKeyRequest
	}
	getApiKeyExecuteReturns struct {
		result1 *openapi.GetApiKeyResponse
		result2 *http.Response
		result3 error
	}
	getApiKeyExecuteReturnsOnCall map[int]struct {
		result1 *openapi.GetApiKeyResponse
		result2 *http.Response
		result3 error
	}
	ListApiKeysStub        func(context.Context, string) openapi.ApiListApiKeysRequest
	listApiKeysMutex       sync.RWMutex
	listApiKeysArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	listApiKeysReturns struct {
		result1 openapi.ApiListApiKeysRequest
	}
	listApiKeysReturnsOnCall map[int]struct {
		result1 openapi.ApiListApiKeysRequest
	}
	ListApiKeysExecuteStub        func(openapi.ApiListApiKeysRequest) (*openapi.ListApiKeysResponse, *http.Response, error)
	listApiKeysExecuteMutex       sync.RWMutex
	listApiKeysExecuteArgsForCall []struct {
		arg1 openapi.ApiListApiKeysRequest
	}
	listApiKeysExecuteReturns struct {
		result1 *openapi.ListApiKeysResponse
		result2 *http.Response
		result3 error
	}
	listApiKeysExecuteReturnsOnCall map[int]struct {
		result1 *openapi.ListApiKeysResponse
		result2 *http.Response
		result3 error
	}
	UpdateApiKeyStub        func(context.Context, string, string) openapi.ApiUpdateApiKeyRequest
	updateApiKeyMutex       sync.RWMutex
	updateApiKeyArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	updateApiKeyReturns struct {
		result1 openapi.ApiUpdateApiKeyRequest
	}
	updateApiKeyReturnsOnCall map[int]struct {
		result1 openapi.ApiUpdateApiKeyRequest
	}
	UpdateApiKeyExecuteStub        func(openapi.ApiUpdateApiKeyRequest) (*openapi.UpdateApiKeyResponse, *http.Response, error)
	updateApiKeyExecuteMutex       sync.RWMutex
	updateApiKeyExecuteArgsForCall []struct {
		arg1 openapi.ApiUpdateApiKeyRequest
	}
	updateApiKeyExecuteReturns struct {
		result1 *openapi.UpdateApiKeyResponse
		result2 *http.Response
		result3 error
	}
	updateApiKeyExecuteReturnsOnCall map[int]struct {
		result1 *openapi.UpdateApiKeyResponse
		result2 *http.Response
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeAPIKeysApi) CreateApiKey(arg1 context.Context) openapi.ApiCreateApiKeyRequest {
	fake.createApiKeyMutex.Lock()
	ret, specificReturn := fake.createApiKeyReturnsOnCall[len(fake.createApiKeyArgsForCall)]
	fake.createApiKeyArgsForCall = append(fake.createApiKeyArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.CreateApiKeyStub
	fakeReturns := fake.createApiKeyReturns
	fake.recordInvocation("CreateApiKey", []interface{}{arg1})
	fake.createApiKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPIKeysApi) CreateApiKeyCallCount() int {
	fake.createApiKeyMutex.RLock()
	defer fake.createApiKeyMutex.RUnlock()
	return len(fake.createApiKeyArgsForCall)
}

func (fake *FakeAPIKeysApi) CreateApiKeyCalls(stub func(context.Context) openapi.ApiCreateApiKeyRequest) {
	fake.createApiKeyMutex.Lock()
	defer fake.createApiKeyMutex.Unlock()
	fake.CreateApiKeyStub = stub
}

func (fake *FakeAPIKeysApi) CreateApiKeyArgsForCall(i int) context.Context {
	fake.createApiKeyMutex.RLock()
	defer fake.createApiKeyMutex.RUnlock()
	argsForCall := fake.createApiKeyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIKeysApi) CreateApiKeyReturns(result1 openapi.ApiCreateApiKeyRequest) {
	fake.createApiKeyMutex.Lock()
	defer fake.createApiKeyMutex.Unlock()
	fake.CreateApiKeyStub = nil
	fake.createApiKeyReturns = struct {
		result1 openapi.ApiCreateApiKeyRequest
	}{result1}
}

func (fake *FakeAPIKeysApi) CreateApiKeyReturnsOnCall(i int, result1 openapi.ApiCreateApiKeyRequest) {
	fake.createApiKeyMutex.Lock()
	defer fake.createApiKeyMutex.Unlock()
	fake.CreateApiKeyStub = nil
	if fake.createApiKeyReturnsOnCall == nil {
		fake.createApiKeyReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiCreateApiKeyRequest
		})
	}
	fake.createApiKeyReturnsOnCall[i] = struct {
		result1 openapi.ApiCreateApiKeyRequest
	}{result1}
}

func (fake *FakeAPIKeysApi) CreateApiKeyExecute(arg1 openapi.ApiCreateApiKeyRequest) (*openapi.CreateApiKeyResponse, *http.Response, error) {
	fake.createApiKeyExecuteMutex.Lock()
	ret, specificReturn := fake.createApiKeyExecuteReturnsOnCall[len(fake.createApiKeyExecuteArgsForCall)]
	fake.createApiKeyExecuteArgsForCall = append(fake.createApiKeyExecuteArgsForCall, struct {
		arg1 openapi.ApiCreateApiKeyRequest
	}{arg1})
	stub := fake.CreateApiKeyExecuteStub
	fakeReturns := fake.createApiKeyExecuteReturns
	fake.recordInvocation("CreateApiKeyExecute", []interface{}{arg1})
	fake.createApiKeyExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeAPIKeysApi) CreateApiKeyExecuteCallCount() int {
	fake.createApiKeyExecuteMutex.RLock()
	defer fake.createApiKeyExecuteMutex.RUnlock()
	return len(fake.createApiKeyExecuteArgsForCall)
}

func (fake *FakeAPIKeysApi) CreateApiKeyExecuteCalls(stub func(openapi.ApiCreateApiKeyRequest) (*openapi.CreateApiKeyResponse, *http.Response, error)) {
	fake.createApiKeyExecuteMutex.Lock()
	defer fake.createApiKeyExecuteMutex.Unlock()
	fake.CreateApiKeyExecuteStub = stub
}

func (fake *FakeAPIKeysApi) CreateApiKeyExecuteArgsForCall(i int) openapi.ApiCreateApiKeyRequest {
	fake.createApiKeyExecuteMutex.RLock()
	defer fake.createApiKeyExecuteMutex.RUnlock()
	argsForCall := fake.createApiKeyExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIKeysApi) CreateApiKeyExecuteReturns(result1 *openapi.CreateApiKeyResponse, result2 *http.Response, result3 error) {
	fake.createApiKeyExecuteMutex.Lock()
	defer fake.createApiKeyExecuteMutex.Unlock()
	fake.CreateApiKeyExecuteStub = nil
	fake.createApiKeyExecuteReturns = struct {
		result1 *openapi.CreateApiKeyResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAPIKeysApi) CreateApiKeyExecuteReturnsOnCall(i int, result1 *openapi.CreateApiKeyResponse, result2 *http.Response, result3 error) {
	fake.createApiKeyExecuteMutex.Lock()
	defer fake.createApiKeyExecuteMutex.Unlock()
	fake.CreateApiKeyExecuteStub = nil
	if fake.createApiKeyExecuteReturnsOnCall == nil {
		fake.createApiKeyExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.CreateApiKeyResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.createApiKeyExecuteReturnsOnCall[i] = struct {
		result1 *openapi.CreateApiKeyResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAPIKeysApi) DeleteApiKey(arg1 context.Context, arg2 string, arg3 string) openapi.ApiDeleteApiKeyRequest {
	fake.deleteApiKeyMutex.Lock()
	ret, specificReturn := fake.deleteApiKeyReturnsOnCall[len(fake.deleteApiKeyArgsForCall)]
	fake.deleteApiKeyArgsForCall = append(fake.deleteApiKeyArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.DeleteApiKeyStub
	fakeReturns := fake.deleteApiKeyReturns
	fake.recordInvocation("DeleteApiKey", []interface{}{arg1, arg2, arg3})
	fake.deleteApiKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPIKeysApi) DeleteApiKeyCallCount() int {
	fake.deleteApiKeyMutex.RLock()
	defer fake.deleteApiKeyMutex.RUnlock()
	return len(fake.deleteApiKeyArgsForCall)
}

func (fake *FakeAPIKeysApi) DeleteApiKeyCalls(stub func(context.Context, string, string) openapi.ApiDeleteApiKeyRequest) {
	fake.deleteApiKeyMutex.Lock()
	defer fake.deleteApiKeyMutex.Unlock()
	fake.DeleteApiKeyStub = stub
}

func (fake *FakeAPIKeysApi) DeleteApiKeyArgsForCall(i int) (context.Context, string, string) {
	fake.deleteApiKeyMutex.RLock()
	defer fake.deleteApiKeyMutex.RUnlock()
	argsForCall := fake.deleteApiKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAPIKeysApi) DeleteApiKeyReturns(result1 openapi.ApiDeleteApiKeyRequest) {
	fake.deleteApiKeyMutex.Lock()
	defer fake.deleteApiKeyMutex.Unlock()
	fake.DeleteApiKeyStub = nil
	fake.deleteApiKeyReturns = struct {
		result1 openapi.ApiDeleteApiKeyRequest
	}{result1}
}

func (fake *FakeAPIKeysApi) DeleteApiKeyReturnsOnCall(i int, result1 openapi.ApiDeleteApiKeyRequest) {
	fake.deleteApiKeyMutex.Lock()
	defer fake.deleteApiKeyMutex.Unlock()
	fake.DeleteApiKeyStub = nil
	if fake.deleteApiKeyReturnsOnCall == nil {
		fake.deleteApiKeyReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiDeleteApiKeyRequest
		})
	}
	fake.deleteApiKeyReturnsOnCall[i] = struct {
		result1 openapi.ApiDeleteApiKeyRequest
	}{result1}
}

func (fake *FakeAPIKeysApi) DeleteApiKeyExecute(arg1 openapi.ApiDeleteApiKeyRequest) (*openapi.DeleteApiKeyResponse, *http.Response, error) {
	fake.deleteApiKeyExecuteMutex.Lock()
	ret, specificReturn := fake.deleteApiKeyExecuteReturnsOnCall[len(fake.deleteApiKeyExecuteArgsForCall)]
	fake.deleteApiKeyExecuteArgsForCall = append(fake.deleteApiKeyExecuteArgsForCall, struct {
		arg1 openapi.ApiDeleteApiKeyRequest
	}{arg1})
	stub := fake.DeleteApiKeyExecuteStub
	fakeReturns := fake.deleteApiKeyExecuteReturns
	fake.recordInvocation("DeleteApiKeyExecute", []interface{}{arg1})
	fake.deleteApiKeyExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeAPIKeysApi) DeleteApiKeyExecuteCallCount() int {
	fake.deleteApiKeyExecuteMutex.RLock()
	defer fake.deleteApiKeyExecuteMutex.RUnlock()
	return len(fake.deleteApiKeyExecuteArgsForCall)
}

func (fake *FakeAPIKeysApi) DeleteApiKeyExecuteCalls(stub func(openapi.ApiDeleteApiKeyRequest) (*openapi.DeleteApiKeyResponse, *http.Response, error)) {
	fake.deleteApiKeyExecuteMutex.Lock()
	defer fake.deleteApiKeyExecuteMutex.Unlock()
	fake.DeleteApiKeyExecuteStub = stub
}

func (fake *FakeAPIKeysApi) DeleteApiKeyExecuteArgsForCall(i int) openapi.ApiDeleteApiKeyRequest {
	fake.deleteApiKeyExecuteMutex.RLock()
	defer fake.deleteApiKeyExecuteMutex.RUnlock()
	argsForCall := fake.deleteApiKeyExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIKeysApi) DeleteApiKeyExecuteReturns(result1 *openapi.DeleteApiKeyResponse, result2 *http.Response, result3 error) {
	fake.deleteApiKeyExecuteMutex.Lock()
	defer fake.deleteApiKeyExecuteMutex.Unlock()
	fake.DeleteApiKeyExecuteStub = nil
	fake.deleteApiKeyExecuteReturns = struct {
		result1 *openapi.DeleteApiKeyResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAPIKeysApi) DeleteApiKeyExecuteReturnsOnCall(i int, result1 *openapi.DeleteApiKeyResponse, result2 *http.Response, result3 error) {
	fake.deleteApiKeyExecuteMutex.Lock()
	defer fake.deleteApiKeyExecuteMutex.Unlock()
	fake.DeleteApiKeyExecuteStub = nil
	if fake.deleteApiKeyExecuteReturnsOnCall == nil {
		fake.deleteApiKeyExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.DeleteApiKeyResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.deleteApiKeyExecuteReturnsOnCall[i] = struct {
		result1 *openapi.DeleteApiKeyResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAPIKeysApi) GetApiKey(arg1 context.Context, arg2 string, arg3 string) openapi.ApiGetApiKeyRequest {
	fake.getApiKeyMutex.Lock()
	ret, specificReturn := fake.getApiKeyReturnsOnCall[len(fake.getApiKeyArgsForCall)]
	fake.getApiKeyArgsForCall = append(fake.getApiKeyArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetApiKeyStub
	fakeReturns := fake.getApiKeyReturns
	fake.recordInvocation("GetApiKey", []interface{}{arg1, arg2, arg3})
	fake.getApiKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPIKeysApi) GetApiKeyCallCount() int {
	fake.getApiKeyMutex.RLock()
	defer fake.getApiKeyMutex.RUnlock()
	return len(fake.getApiKeyArgsForCall)
}

func (fake *FakeAPIKeysApi) GetApiKeyCalls(stub func(context.Context, string, string) openapi.ApiGetApiKeyRequest) {
	fake.getApiKeyMutex.Lock()
	defer fake.getApiKeyMutex.Unlock()
	fake.GetApiKeyStub = stub
}

func (fake *FakeAPIKeysApi) GetApiKeyArgsForCall(i int) (context.Context, string, string) {
	fake.getApiKeyMutex.RLock()
	defer fake.getApiKeyMutex.RUnlock()
	argsForCall := fake.getApiKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAPIKeysApi) GetApiKeyReturns(result1 openapi.ApiGetApiKeyRequest) {
	fake.getApiKeyMutex.Lock()
	defer fake.getApiKeyMutex.Unlock()
	fake.GetApiKeyStub = nil
	fake.getApiKeyReturns = struct {
		result1 openapi.ApiGetApiKeyRequest
	}{result1}
}

func (fake *FakeAPIKeysApi) GetApiKeyReturnsOnCall(i int, result1 openapi.ApiGetApiKeyRequest) {
	fake.getApiKeyMutex.Lock()
	defer fake.getApiKeyMutex.Unlock()
	fake.GetApiKeyStub = nil
	if fake.getApiKeyReturnsOnCall == nil {
		fake.getApiKeyReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiGetApiKeyRequest
		})
	}
	fake.getApiKeyReturnsOnCall[i] = struct {
		result1 openapi.ApiGetApiKeyRequest
	}{result1}
}

func (fake *FakeAPIKeysApi) GetApiKeyExecute(arg1 openapi.ApiGetApiKeyRequest) (*openapi.GetApiKeyResponse, *http.Response, error) {
	fake.getApiKeyExecuteMutex.Lock()
	ret, specificReturn := fake.getApiKeyExecuteReturnsOnCall[len(fake.getApiKeyExecuteArgsForCall)]
	fake.getApiKeyExecuteArgsForCall = append(fake.getApiKeyExecuteArgsForCall, struct {
		arg1 openapi.ApiGetApiKeyRequest
	}{arg1})
	stub := fake.GetApiKeyExecuteStub
	fakeReturns := fake.getApiKeyExecuteReturns
	fake.recordInvocation("GetApiKeyExecute", []interface{}{arg1})
	fake.getApiKeyExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeAPIKeysApi) GetApiKeyExecuteCallCount() int {
	fake.getApiKeyExecuteMutex.RLock()
	defer fake.getApiKeyExecuteMutex.RUnlock()
	return len(fake.getApiKeyExecuteArgsForCall)
}

func (fake *FakeAPIKeysApi) GetApiKeyExecuteCalls(stub func(openapi.ApiGetApiKeyRequest) (*openapi.GetApiKeyResponse, *http.Response, error)) {
	fake.getApiKeyExecuteMutex.Lock()
	defer fake.getApiKeyExecuteMutex.Unlock()
	fake.GetApiKeyExecuteStub = stub
}

func (fake *FakeAPIKeysApi) GetApiKeyExecuteArgsForCall(i int) openapi.ApiGetApiKeyRequest {
	fake.getApiKeyExecuteMutex.RLock()
	defer fake.getApiKeyExecuteMutex.RUnlock()
	argsForCall := fake.getApiKeyExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIKeysApi) GetApiKeyExecuteReturns(result1 *openapi.GetApiKeyResponse, result2 *http.Response, result3 error) {
	fake.getApiKeyExecuteMutex.Lock()
	defer fake.getApiKeyExecuteMutex.Unlock()
	fake.GetApiKeyExecuteStub = nil
	fake.getApiKeyExecuteReturns = struct {
		result1 *openapi.GetApiKeyResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAPIKeysApi) GetApiKeyExecuteReturnsOnCall(i int, result1 *openapi.GetApiKeyResponse, result2 *http.Response, result3 error) {
	fake.getApiKeyExecuteMutex.Lock()
	defer fake.getApiKeyExecuteMutex.Unlock()
	fake.GetApiKeyExecuteStub = nil
	if fake.getApiKeyExecuteReturnsOnCall == nil {
		fake.getApiKeyExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.GetApiKeyResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.getApiKeyExecuteReturnsOnCall[i] = struct {
		result1 *openapi.GetApiKeyResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAPIKeysApi) ListApiKeys(arg1 context.Context, arg2 string) openapi.ApiListApiKeysRequest {
	fake.listApiKeysMutex.Lock()
	ret, specificReturn := fake.listApiKeysReturnsOnCall[len(fake.listApiKeysArgsForCall)]
	fake.listApiKeysArgsForCall = append(fake.listApiKeysArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ListApiKeysStub
	fakeReturns := fake.listApiKeysReturns
	fake.recordInvocation("ListApiKeys", []interface{}{arg1, arg2})
	fake.listApiKeysMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPIKeysApi) ListApiKeysCallCount() int {
	fake.listApiKeysMutex.RLock()
	defer fake.listApiKeysMutex.RUnlock()
	return len(fake.listApiKeysArgsForCall)
}

func (fake *FakeAPIKeysApi) ListApiKeysCalls(stub func(context.Context, string) openapi.ApiListApiKeysRequest) {
	fake.listApiKeysMutex.Lock()
	defer fake.listApiKeysMutex.Unlock()
	fake.ListApiKeysStub = stub
}

func (fake *FakeAPIKeysApi) ListApiKeysArgsForCall(i int) (context.Context, string) {
	fake.listApiKeysMutex.RLock()
	defer fake.listApiKeysMutex.RUnlock()
	argsForCall := fake.listApiKeysArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAPIKeysApi) ListApiKeysReturns(result1 openapi.ApiListApiKeysRequest) {
	fake.listApiKeysMutex.Lock()
	defer fake.listApiKeysMutex.Unlock()
	fake.ListApiKeysStub = nil
	fake.listApiKeysReturns = struct {
		result1 openapi.ApiListApiKeysRequest
	}{result1}
}

func (fake *FakeAPIKeysApi) ListApiKeysReturnsOnCall(i int, result1 openapi.ApiListApiKeysRequest) {
	fake.listApiKeysMutex.Lock()
	defer fake.listApiKeysMutex.Unlock()
	fake.ListApiKeysStub = nil
	if fake.listApiKeysReturnsOnCall == nil {
		fake.listApiKeysReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiListApiKeysRequest
		})
	}
	fake.listApiKeysReturnsOnCall[i] = struct {
		result1 openapi.ApiListApiKeysRequest
	}{result1}
}

func (fake *FakeAPIKeysApi) ListApiKeysExecute(arg1 openapi.ApiListApiKeysRequest) (*openapi.ListApiKeysResponse, *http.Response, error) {
	fake.listApiKeysExecuteMutex.Lock()
	ret, specificReturn := fake.listApiKeysExecuteReturnsOnCall[len(fake.listApiKeysExecuteArgsForCall)]
	fake.listApiKeysExecuteArgsForCall = append(fake.listApiKeysExecuteArgsForCall, struct {
		arg1 openapi.ApiListApiKeysRequest
	}{arg1})
	stub := fake.ListApiKeysExecuteStub
	fakeReturns := fake.listApiKeysExecuteReturns
	fake.recordInvocation("ListApiKeysExecute", []interface{}{arg1})
	fake.listApiKeysExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeAPIKeysApi) ListApiKeysExecuteCallCount() int {
	fake.listApiKeysExecuteMutex.RLock()
	defer fake.listApiKeysExecuteMutex.RUnlock()
	return len(fake.listApiKeysExecuteArgsForCall)
}

func (fake *FakeAPIKeysApi) ListApiKeysExecuteCalls(stub func(openapi.ApiListApiKeysRequest) (*openapi.ListApiKeysResponse, *http.Response, error)) {
	fake.listApiKeysExecuteMutex.Lock()
	defer fake.listApiKeysExecuteMutex.Unlock()
	fake.ListApiKeysExecuteStub = stub
}

func (fake *FakeAPIKeysApi) ListApiKeysExecuteArgsForCall(i int) openapi.ApiListApiKeysRequest {
	fake.listApiKeysExecuteMutex.RLock()
	defer fake.listApiKeysExecuteMutex.RUnlock()
	argsForCall := fake.listApiKeysExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIKeysApi) ListApiKeysExecuteReturns(result1 *openapi.ListApiKeysResponse, result2 *http.Response, result3 error) {
	fake.listApiKeysExecuteMutex.Lock()
	defer fake.listApiKeysExecuteMutex.Unlock()
	fake.ListApiKeysExecuteStub = nil
	fake.listApiKeysExecuteReturns = struct {
		result1 *openapi.ListApiKeysResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAPIKeysApi) ListApiKeysExecuteReturnsOnCall(i int, result1 *openapi.ListApiKeysResponse, result2 *http.Response, result3 error) {
	fake.listApiKeysExecuteMutex.Lock()
	defer fake.listApiKeysExecuteMutex.Unlock()
	fake.ListApiKeysExecuteStub = nil
	if fake.listApiKeysExecuteReturnsOnCall == nil {
		fake.listApiKeysExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.ListApiKeysResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.listApiKeysExecuteReturnsOnCall[i] = struct {
		result1 *openapi.ListApiKeysResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAPIKeysApi) UpdateApiKey(arg1 context.Context, arg2 string, arg3 string) openapi.ApiUpdateApiKeyRequest {
	fake.updateApiKeyMutex.Lock()
	ret, specificReturn := fake.updateApiKeyReturnsOnCall[len(fake.updateApiKeyArgsForCall)]
	fake.updateApiKeyArgsForCall = append(fake.updateApiKeyArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.UpdateApiKeyStub
	fakeReturns := fake.updateApiKeyReturns
	fake.recordInvocation("UpdateApiKey", []interface{}{arg1, arg2, arg3})
	fake.updateApiKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAPIKeysApi) UpdateApiKeyCallCount() int {
	fake.updateApiKeyMutex.RLock()
	defer fake.updateApiKeyMutex.RUnlock()
	return len(fake.updateApiKeyArgsForCall)
}

func (fake *FakeAPIKeysApi) UpdateApiKeyCalls(stub func(context.Context, string, string) openapi.ApiUpdateApiKeyRequest) {
	fake.updateApiKeyMutex.Lock()
	defer fake.updateApiKeyMutex.Unlock()
	fake.UpdateApiKeyStub = stub
}

func (fake *FakeAPIKeysApi) UpdateApiKeyArgsForCall(i int) (context.Context, string, string) {
	fake.updateApiKeyMutex.RLock()
	defer fake.updateApiKeyMutex.RUnlock()
	argsForCall := fake.updateApiKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAPIKeysApi) UpdateApiKeyReturns(result1 openapi.ApiUpdateApiKeyRequest) {
	fake.updateApiKeyMutex.Lock()
	defer fake.updateApiKeyMutex.Unlock()
	fake.UpdateApiKeyStub = nil
	fake.updateApiKeyReturns = struct {
		result1 openapi.ApiUpdateApiKeyRequest
	}{result1}
}

func (fake *FakeAPIKeysApi) UpdateApiKeyReturnsOnCall(i int, result1 openapi.ApiUpdateApiKeyRequest) {
	fake.updateApiKeyMutex.Lock()
	defer fake.updateApiKeyMutex.Unlock()
	fake.UpdateApiKeyStub = nil
	if fake.updateApiKeyReturnsOnCall == nil {
		fake.updateApiKeyReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiUpdateApiKeyRequest
		})
	}
	fake.updateApiKeyReturnsOnCall[i] = struct {
		result1 openapi.ApiUpdateApiKeyRequest
	}{result1}
}

func (fake *FakeAPIKeysApi) UpdateApiKeyExecute(arg1 openapi.ApiUpdateApiKeyRequest) (*openapi.UpdateApiKeyResponse, *http.Response, error) {
	fake.updateApiKeyExecuteMutex.Lock()
	ret, specificReturn := fake.updateApiKeyExecuteReturnsOnCall[len(fake.updateApiKeyExecuteArgsForCall)]
	fake.updateApiKeyExecuteArgsForCall = append(fake.updateApiKeyExecuteArgsForCall, struct {
		arg1 openapi.ApiUpdateApiKeyRequest
	}{arg1})
	stub := fake.UpdateApiKeyExecuteStub
	fakeReturns := fake.updateApiKeyExecuteReturns
	fake.recordInvocation("UpdateApiKeyExecute", []interface{}{arg1})
	fake.updateApiKeyExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeAPIKeysApi) UpdateApiKeyExecuteCallCount() int {
	fake.updateApiKeyExecuteMutex.RLock()
	defer fake.updateApiKeyExecuteMutex.RUnlock()
	return len(fake.updateApiKeyExecuteArgsForCall)
}

func (fake *FakeAPIKeysApi) UpdateApiKeyExecuteCalls(stub func(openapi.ApiUpdateApiKeyRequest) (*openapi.UpdateApiKeyResponse, *http.Response, error)) {
	fake.updateApiKeyExecuteMutex.Lock()
	defer fake.updateApiKeyExecuteMutex.Unlock()
	fake.UpdateApiKeyExecuteStub = stub
}

func (fake *FakeAPIKeysApi) UpdateApiKeyExecuteArgsForCall(i int) openapi.ApiUpdateApiKeyRequest {
	fake.updateApiKeyExecuteMutex.RLock()
	defer fake.updateApiKeyExecuteMutex.RUnlock()
	argsForCall := fake.updateApiKeyExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAPIKeysApi) UpdateApiKeyExecuteReturns(result1 *openapi.UpdateApiKeyResponse, result2 *http.Response, result3 error) {
	fake.updateApiKeyExecuteMutex.Lock()
	defer fake.updateApiKeyExecuteMutex.Unlock()
	fake.UpdateApiKeyExecuteStub = nil
	fake.updateApiKeyExecuteReturns = struct {
		result1 *openapi.UpdateApiKeyResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAPIKeysApi) UpdateApiKeyExecuteReturnsOnCall(i int, result1 *openapi.UpdateApiKeyResponse, result2 *http.Response, result3 error) {
	fake.updateApiKeyExecuteMutex.Lock()
	defer fake.updateApiKeyExecuteMutex.Unlock()
	fake.UpdateApiKeyExecuteStub = nil
	if fake.updateApiKeyExecuteReturnsOnCall == nil {
		fake.updateApiKeyExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.UpdateApiKeyResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.updateApiKeyExecuteReturnsOnCall[i] = struct {
		result1 *openapi.UpdateApiKeyResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeAPIKeysApi) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createApiKeyMutex.RLock()
	defer fake.createApiKeyMutex.RUnlock()
	fake.createApiKeyExecuteMutex.RLock()
	defer fake.createApiKeyExecuteMutex.RUnlock()
	fake.deleteApiKeyMutex.RLock()
	defer fake.deleteApiKeyMutex.RUnlock()
	fake.deleteApiKeyExecuteMutex.RLock()
	defer fake.deleteApiKeyExecuteMutex.RUnlock()
	fake.getApiKeyMutex.RLock()
	defer fake.getApiKeyMutex.RUnlock()
	fake.getApiKeyExecuteMutex.RLock()
	defer fake.getApiKeyExecuteMutex.RUnlock()
	fake.listApiKeysMutex.RLock()
	defer fake.listApiKeysMutex.RUnlock()
	fake.listApiKeysExecuteMutex.RLock()
	defer fake.listApiKeysExecuteMutex.RUnlock()
	fake.updateApiKeyMutex.RLock()
	defer fake.updateApiKeyMutex.RUnlock()
	fake.updateApiKeyExecuteMutex.RLock()
	defer fake.updateApiKeyExecuteMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeAPIKeysApi) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ openapi.APIKeysApi = new(FakeAPIKeysApi)
