// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"context"
	"net/http"
	"sync"

	"github.com/rockset/rockset-go-client/openapi"
)

type FakeQueriesApi struct {
	CancelQueryStub        func(context.Context, string) openapi.ApiCancelQueryRequest
	cancelQueryMutex       sync.RWMutex
	cancelQueryArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	cancelQueryReturns struct {
		result1 openapi.ApiCancelQueryRequest
	}
	cancelQueryReturnsOnCall map[int]struct {
		result1 openapi.ApiCancelQueryRequest
	}
	CancelQueryExecuteStub        func(openapi.ApiCancelQueryRequest) (*openapi.CancelQueryResponse, *http.Response, error)
	cancelQueryExecuteMutex       sync.RWMutex
	cancelQueryExecuteArgsForCall []struct {
		arg1 openapi.ApiCancelQueryRequest
	}
	cancelQueryExecuteReturns struct {
		result1 *openapi.CancelQueryResponse
		result2 *http.Response
		result3 error
	}
	cancelQueryExecuteReturnsOnCall map[int]struct {
		result1 *openapi.CancelQueryResponse
		result2 *http.Response
		result3 error
	}
	GetQueryStub        func(context.Context, string) openapi.ApiGetQueryRequest
	getQueryMutex       sync.RWMutex
	getQueryArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getQueryReturns struct {
		result1 openapi.ApiGetQueryRequest
	}
	getQueryReturnsOnCall map[int]struct {
		result1 openapi.ApiGetQueryRequest
	}
	GetQueryExecuteStub        func(openapi.ApiGetQueryRequest) (*openapi.GetQueryResponse, *http.Response, error)
	getQueryExecuteMutex       sync.RWMutex
	getQueryExecuteArgsForCall []struct {
		arg1 openapi.ApiGetQueryRequest
	}
	getQueryExecuteReturns struct {
		result1 *openapi.GetQueryResponse
		result2 *http.Response
		result3 error
	}
	getQueryExecuteReturnsOnCall map[int]struct {
		result1 *openapi.GetQueryResponse
		result2 *http.Response
		result3 error
	}
	GetQueryResultsStub        func(context.Context, string) openapi.ApiGetQueryResultsRequest
	getQueryResultsMutex       sync.RWMutex
	getQueryResultsArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getQueryResultsReturns struct {
		result1 openapi.ApiGetQueryResultsRequest
	}
	getQueryResultsReturnsOnCall map[int]struct {
		result1 openapi.ApiGetQueryResultsRequest
	}
	GetQueryResultsExecuteStub        func(openapi.ApiGetQueryResultsRequest) (*openapi.QueryPaginationResponse, *http.Response, error)
	getQueryResultsExecuteMutex       sync.RWMutex
	getQueryResultsExecuteArgsForCall []struct {
		arg1 openapi.ApiGetQueryResultsRequest
	}
	getQueryResultsExecuteReturns struct {
		result1 *openapi.QueryPaginationResponse
		result2 *http.Response
		result3 error
	}
	getQueryResultsExecuteReturnsOnCall map[int]struct {
		result1 *openapi.QueryPaginationResponse
		result2 *http.Response
		result3 error
	}
	ListActiveQueriesStub        func(context.Context) openapi.ApiListActiveQueriesRequest
	listActiveQueriesMutex       sync.RWMutex
	listActiveQueriesArgsForCall []struct {
		arg1 context.Context
	}
	listActiveQueriesReturns struct {
		result1 openapi.ApiListActiveQueriesRequest
	}
	listActiveQueriesReturnsOnCall map[int]struct {
		result1 openapi.ApiListActiveQueriesRequest
	}
	ListActiveQueriesExecuteStub        func(openapi.ApiListActiveQueriesRequest) (*openapi.ListQueriesResponse, *http.Response, error)
	listActiveQueriesExecuteMutex       sync.RWMutex
	listActiveQueriesExecuteArgsForCall []struct {
		arg1 openapi.ApiListActiveQueriesRequest
	}
	listActiveQueriesExecuteReturns struct {
		result1 *openapi.ListQueriesResponse
		result2 *http.Response
		result3 error
	}
	listActiveQueriesExecuteReturnsOnCall map[int]struct {
		result1 *openapi.ListQueriesResponse
		result2 *http.Response
		result3 error
	}
	QueryStub        func(context.Context) openapi.ApiQueryRequest
	queryMutex       sync.RWMutex
	queryArgsForCall []struct {
		arg1 context.Context
	}
	queryReturns struct {
		result1 openapi.ApiQueryRequest
	}
	queryReturnsOnCall map[int]struct {
		result1 openapi.ApiQueryRequest
	}
	QueryExecuteStub        func(openapi.ApiQueryRequest) (*openapi.QueryResponse, *http.Response, error)
	queryExecuteMutex       sync.RWMutex
	queryExecuteArgsForCall []struct {
		arg1 openapi.ApiQueryRequest
	}
	queryExecuteReturns struct {
		result1 *openapi.QueryResponse
		result2 *http.Response
		result3 error
	}
	queryExecuteReturnsOnCall map[int]struct {
		result1 *openapi.QueryResponse
		result2 *http.Response
		result3 error
	}
	ValidateStub        func(context.Context) openapi.ApiValidateRequest
	validateMutex       sync.RWMutex
	validateArgsForCall []struct {
		arg1 context.Context
	}
	validateReturns struct {
		result1 openapi.ApiValidateRequest
	}
	validateReturnsOnCall map[int]struct {
		result1 openapi.ApiValidateRequest
	}
	ValidateExecuteStub        func(openapi.ApiValidateRequest) (*openapi.ValidateQueryResponse, *http.Response, error)
	validateExecuteMutex       sync.RWMutex
	validateExecuteArgsForCall []struct {
		arg1 openapi.ApiValidateRequest
	}
	validateExecuteReturns struct {
		result1 *openapi.ValidateQueryResponse
		result2 *http.Response
		result3 error
	}
	validateExecuteReturnsOnCall map[int]struct {
		result1 *openapi.ValidateQueryResponse
		result2 *http.Response
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeQueriesApi) CancelQuery(arg1 context.Context, arg2 string) openapi.ApiCancelQueryRequest {
	fake.cancelQueryMutex.Lock()
	ret, specificReturn := fake.cancelQueryReturnsOnCall[len(fake.cancelQueryArgsForCall)]
	fake.cancelQueryArgsForCall = append(fake.cancelQueryArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.CancelQueryStub
	fakeReturns := fake.cancelQueryReturns
	fake.recordInvocation("CancelQuery", []interface{}{arg1, arg2})
	fake.cancelQueryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQueriesApi) CancelQueryCallCount() int {
	fake.cancelQueryMutex.RLock()
	defer fake.cancelQueryMutex.RUnlock()
	return len(fake.cancelQueryArgsForCall)
}

func (fake *FakeQueriesApi) CancelQueryCalls(stub func(context.Context, string) openapi.ApiCancelQueryRequest) {
	fake.cancelQueryMutex.Lock()
	defer fake.cancelQueryMutex.Unlock()
	fake.CancelQueryStub = stub
}

func (fake *FakeQueriesApi) CancelQueryArgsForCall(i int) (context.Context, string) {
	fake.cancelQueryMutex.RLock()
	defer fake.cancelQueryMutex.RUnlock()
	argsForCall := fake.cancelQueryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQueriesApi) CancelQueryReturns(result1 openapi.ApiCancelQueryRequest) {
	fake.cancelQueryMutex.Lock()
	defer fake.cancelQueryMutex.Unlock()
	fake.CancelQueryStub = nil
	fake.cancelQueryReturns = struct {
		result1 openapi.ApiCancelQueryRequest
	}{result1}
}

func (fake *FakeQueriesApi) CancelQueryReturnsOnCall(i int, result1 openapi.ApiCancelQueryRequest) {
	fake.cancelQueryMutex.Lock()
	defer fake.cancelQueryMutex.Unlock()
	fake.CancelQueryStub = nil
	if fake.cancelQueryReturnsOnCall == nil {
		fake.cancelQueryReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiCancelQueryRequest
		})
	}
	fake.cancelQueryReturnsOnCall[i] = struct {
		result1 openapi.ApiCancelQueryRequest
	}{result1}
}

func (fake *FakeQueriesApi) CancelQueryExecute(arg1 openapi.ApiCancelQueryRequest) (*openapi.CancelQueryResponse, *http.Response, error) {
	fake.cancelQueryExecuteMutex.Lock()
	ret, specificReturn := fake.cancelQueryExecuteReturnsOnCall[len(fake.cancelQueryExecuteArgsForCall)]
	fake.cancelQueryExecuteArgsForCall = append(fake.cancelQueryExecuteArgsForCall, struct {
		arg1 openapi.ApiCancelQueryRequest
	}{arg1})
	stub := fake.CancelQueryExecuteStub
	fakeReturns := fake.cancelQueryExecuteReturns
	fake.recordInvocation("CancelQueryExecute", []interface{}{arg1})
	fake.cancelQueryExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeQueriesApi) CancelQueryExecuteCallCount() int {
	fake.cancelQueryExecuteMutex.RLock()
	defer fake.cancelQueryExecuteMutex.RUnlock()
	return len(fake.cancelQueryExecuteArgsForCall)
}

func (fake *FakeQueriesApi) CancelQueryExecuteCalls(stub func(openapi.ApiCancelQueryRequest) (*openapi.CancelQueryResponse, *http.Response, error)) {
	fake.cancelQueryExecuteMutex.Lock()
	defer fake.cancelQueryExecuteMutex.Unlock()
	fake.CancelQueryExecuteStub = stub
}

func (fake *FakeQueriesApi) CancelQueryExecuteArgsForCall(i int) openapi.ApiCancelQueryRequest {
	fake.cancelQueryExecuteMutex.RLock()
	defer fake.cancelQueryExecuteMutex.RUnlock()
	argsForCall := fake.cancelQueryExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQueriesApi) CancelQueryExecuteReturns(result1 *openapi.CancelQueryResponse, result2 *http.Response, result3 error) {
	fake.cancelQueryExecuteMutex.Lock()
	defer fake.cancelQueryExecuteMutex.Unlock()
	fake.CancelQueryExecuteStub = nil
	fake.cancelQueryExecuteReturns = struct {
		result1 *openapi.CancelQueryResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueriesApi) CancelQueryExecuteReturnsOnCall(i int, result1 *openapi.CancelQueryResponse, result2 *http.Response, result3 error) {
	fake.cancelQueryExecuteMutex.Lock()
	defer fake.cancelQueryExecuteMutex.Unlock()
	fake.CancelQueryExecuteStub = nil
	if fake.cancelQueryExecuteReturnsOnCall == nil {
		fake.cancelQueryExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.CancelQueryResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.cancelQueryExecuteReturnsOnCall[i] = struct {
		result1 *openapi.CancelQueryResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueriesApi) GetQuery(arg1 context.Context, arg2 string) openapi.ApiGetQueryRequest {
	fake.getQueryMutex.Lock()
	ret, specificReturn := fake.getQueryReturnsOnCall[len(fake.getQueryArgsForCall)]
	fake.getQueryArgsForCall = append(fake.getQueryArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetQueryStub
	fakeReturns := fake.getQueryReturns
	fake.recordInvocation("GetQuery", []interface{}{arg1, arg2})
	fake.getQueryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQueriesApi) GetQueryCallCount() int {
	fake.getQueryMutex.RLock()
	defer fake.getQueryMutex.RUnlock()
	return len(fake.getQueryArgsForCall)
}

func (fake *FakeQueriesApi) GetQueryCalls(stub func(context.Context, string) openapi.ApiGetQueryRequest) {
	fake.getQueryMutex.Lock()
	defer fake.getQueryMutex.Unlock()
	fake.GetQueryStub = stub
}

func (fake *FakeQueriesApi) GetQueryArgsForCall(i int) (context.Context, string) {
	fake.getQueryMutex.RLock()
	defer fake.getQueryMutex.RUnlock()
	argsForCall := fake.getQueryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQueriesApi) GetQueryReturns(result1 openapi.ApiGetQueryRequest) {
	fake.getQueryMutex.Lock()
	defer fake.getQueryMutex.Unlock()
	fake.GetQueryStub = nil
	fake.getQueryReturns = struct {
		result1 openapi.ApiGetQueryRequest
	}{result1}
}

func (fake *FakeQueriesApi) GetQueryReturnsOnCall(i int, result1 openapi.ApiGetQueryRequest) {
	fake.getQueryMutex.Lock()
	defer fake.getQueryMutex.Unlock()
	fake.GetQueryStub = nil
	if fake.getQueryReturnsOnCall == nil {
		fake.getQueryReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiGetQueryRequest
		})
	}
	fake.getQueryReturnsOnCall[i] = struct {
		result1 openapi.ApiGetQueryRequest
	}{result1}
}

func (fake *FakeQueriesApi) GetQueryExecute(arg1 openapi.ApiGetQueryRequest) (*openapi.GetQueryResponse, *http.Response, error) {
	fake.getQueryExecuteMutex.Lock()
	ret, specificReturn := fake.getQueryExecuteReturnsOnCall[len(fake.getQueryExecuteArgsForCall)]
	fake.getQueryExecuteArgsForCall = append(fake.getQueryExecuteArgsForCall, struct {
		arg1 openapi.ApiGetQueryRequest
	}{arg1})
	stub := fake.GetQueryExecuteStub
	fakeReturns := fake.getQueryExecuteReturns
	fake.recordInvocation("GetQueryExecute", []interface{}{arg1})
	fake.getQueryExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeQueriesApi) GetQueryExecuteCallCount() int {
	fake.getQueryExecuteMutex.RLock()
	defer fake.getQueryExecuteMutex.RUnlock()
	return len(fake.getQueryExecuteArgsForCall)
}

func (fake *FakeQueriesApi) GetQueryExecuteCalls(stub func(openapi.ApiGetQueryRequest) (*openapi.GetQueryResponse, *http.Response, error)) {
	fake.getQueryExecuteMutex.Lock()
	defer fake.getQueryExecuteMutex.Unlock()
	fake.GetQueryExecuteStub = stub
}

func (fake *FakeQueriesApi) GetQueryExecuteArgsForCall(i int) openapi.ApiGetQueryRequest {
	fake.getQueryExecuteMutex.RLock()
	defer fake.getQueryExecuteMutex.RUnlock()
	argsForCall := fake.getQueryExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQueriesApi) GetQueryExecuteReturns(result1 *openapi.GetQueryResponse, result2 *http.Response, result3 error) {
	fake.getQueryExecuteMutex.Lock()
	defer fake.getQueryExecuteMutex.Unlock()
	fake.GetQueryExecuteStub = nil
	fake.getQueryExecuteReturns = struct {
		result1 *openapi.GetQueryResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueriesApi) GetQueryExecuteReturnsOnCall(i int, result1 *openapi.GetQueryResponse, result2 *http.Response, result3 error) {
	fake.getQueryExecuteMutex.Lock()
	defer fake.getQueryExecuteMutex.Unlock()
	fake.GetQueryExecuteStub = nil
	if fake.getQueryExecuteReturnsOnCall == nil {
		fake.getQueryExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.GetQueryResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.getQueryExecuteReturnsOnCall[i] = struct {
		result1 *openapi.GetQueryResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueriesApi) GetQueryResults(arg1 context.Context, arg2 string) openapi.ApiGetQueryResultsRequest {
	fake.getQueryResultsMutex.Lock()
	ret, specificReturn := fake.getQueryResultsReturnsOnCall[len(fake.getQueryResultsArgsForCall)]
	fake.getQueryResultsArgsForCall = append(fake.getQueryResultsArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetQueryResultsStub
	fakeReturns := fake.getQueryResultsReturns
	fake.recordInvocation("GetQueryResults", []interface{}{arg1, arg2})
	fake.getQueryResultsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQueriesApi) GetQueryResultsCallCount() int {
	fake.getQueryResultsMutex.RLock()
	defer fake.getQueryResultsMutex.RUnlock()
	return len(fake.getQueryResultsArgsForCall)
}

func (fake *FakeQueriesApi) GetQueryResultsCalls(stub func(context.Context, string) openapi.ApiGetQueryResultsRequest) {
	fake.getQueryResultsMutex.Lock()
	defer fake.getQueryResultsMutex.Unlock()
	fake.GetQueryResultsStub = stub
}

func (fake *FakeQueriesApi) GetQueryResultsArgsForCall(i int) (context.Context, string) {
	fake.getQueryResultsMutex.RLock()
	defer fake.getQueryResultsMutex.RUnlock()
	argsForCall := fake.getQueryResultsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeQueriesApi) GetQueryResultsReturns(result1 openapi.ApiGetQueryResultsRequest) {
	fake.getQueryResultsMutex.Lock()
	defer fake.getQueryResultsMutex.Unlock()
	fake.GetQueryResultsStub = nil
	fake.getQueryResultsReturns = struct {
		result1 openapi.ApiGetQueryResultsRequest
	}{result1}
}

func (fake *FakeQueriesApi) GetQueryResultsReturnsOnCall(i int, result1 openapi.ApiGetQueryResultsRequest) {
	fake.getQueryResultsMutex.Lock()
	defer fake.getQueryResultsMutex.Unlock()
	fake.GetQueryResultsStub = nil
	if fake.getQueryResultsReturnsOnCall == nil {
		fake.getQueryResultsReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiGetQueryResultsRequest
		})
	}
	fake.getQueryResultsReturnsOnCall[i] = struct {
		result1 openapi.ApiGetQueryResultsRequest
	}{result1}
}

func (fake *FakeQueriesApi) GetQueryResultsExecute(arg1 openapi.ApiGetQueryResultsRequest) (*openapi.QueryPaginationResponse, *http.Response, error) {
	fake.getQueryResultsExecuteMutex.Lock()
	ret, specificReturn := fake.getQueryResultsExecuteReturnsOnCall[len(fake.getQueryResultsExecuteArgsForCall)]
	fake.getQueryResultsExecuteArgsForCall = append(fake.getQueryResultsExecuteArgsForCall, struct {
		arg1 openapi.ApiGetQueryResultsRequest
	}{arg1})
	stub := fake.GetQueryResultsExecuteStub
	fakeReturns := fake.getQueryResultsExecuteReturns
	fake.recordInvocation("GetQueryResultsExecute", []interface{}{arg1})
	fake.getQueryResultsExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeQueriesApi) GetQueryResultsExecuteCallCount() int {
	fake.getQueryResultsExecuteMutex.RLock()
	defer fake.getQueryResultsExecuteMutex.RUnlock()
	return len(fake.getQueryResultsExecuteArgsForCall)
}

func (fake *FakeQueriesApi) GetQueryResultsExecuteCalls(stub func(openapi.ApiGetQueryResultsRequest) (*openapi.QueryPaginationResponse, *http.Response, error)) {
	fake.getQueryResultsExecuteMutex.Lock()
	defer fake.getQueryResultsExecuteMutex.Unlock()
	fake.GetQueryResultsExecuteStub = stub
}

func (fake *FakeQueriesApi) GetQueryResultsExecuteArgsForCall(i int) openapi.ApiGetQueryResultsRequest {
	fake.getQueryResultsExecuteMutex.RLock()
	defer fake.getQueryResultsExecuteMutex.RUnlock()
	argsForCall := fake.getQueryResultsExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQueriesApi) GetQueryResultsExecuteReturns(result1 *openapi.QueryPaginationResponse, result2 *http.Response, result3 error) {
	fake.getQueryResultsExecuteMutex.Lock()
	defer fake.getQueryResultsExecuteMutex.Unlock()
	fake.GetQueryResultsExecuteStub = nil
	fake.getQueryResultsExecuteReturns = struct {
		result1 *openapi.QueryPaginationResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueriesApi) GetQueryResultsExecuteReturnsOnCall(i int, result1 *openapi.QueryPaginationResponse, result2 *http.Response, result3 error) {
	fake.getQueryResultsExecuteMutex.Lock()
	defer fake.getQueryResultsExecuteMutex.Unlock()
	fake.GetQueryResultsExecuteStub = nil
	if fake.getQueryResultsExecuteReturnsOnCall == nil {
		fake.getQueryResultsExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.QueryPaginationResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.getQueryResultsExecuteReturnsOnCall[i] = struct {
		result1 *openapi.QueryPaginationResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueriesApi) ListActiveQueries(arg1 context.Context) openapi.ApiListActiveQueriesRequest {
	fake.listActiveQueriesMutex.Lock()
	ret, specificReturn := fake.listActiveQueriesReturnsOnCall[len(fake.listActiveQueriesArgsForCall)]
	fake.listActiveQueriesArgsForCall = append(fake.listActiveQueriesArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ListActiveQueriesStub
	fakeReturns := fake.listActiveQueriesReturns
	fake.recordInvocation("ListActiveQueries", []interface{}{arg1})
	fake.listActiveQueriesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQueriesApi) ListActiveQueriesCallCount() int {
	fake.listActiveQueriesMutex.RLock()
	defer fake.listActiveQueriesMutex.RUnlock()
	return len(fake.listActiveQueriesArgsForCall)
}

func (fake *FakeQueriesApi) ListActiveQueriesCalls(stub func(context.Context) openapi.ApiListActiveQueriesRequest) {
	fake.listActiveQueriesMutex.Lock()
	defer fake.listActiveQueriesMutex.Unlock()
	fake.ListActiveQueriesStub = stub
}

func (fake *FakeQueriesApi) ListActiveQueriesArgsForCall(i int) context.Context {
	fake.listActiveQueriesMutex.RLock()
	defer fake.listActiveQueriesMutex.RUnlock()
	argsForCall := fake.listActiveQueriesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQueriesApi) ListActiveQueriesReturns(result1 openapi.ApiListActiveQueriesRequest) {
	fake.listActiveQueriesMutex.Lock()
	defer fake.listActiveQueriesMutex.Unlock()
	fake.ListActiveQueriesStub = nil
	fake.listActiveQueriesReturns = struct {
		result1 openapi.ApiListActiveQueriesRequest
	}{result1}
}

func (fake *FakeQueriesApi) ListActiveQueriesReturnsOnCall(i int, result1 openapi.ApiListActiveQueriesRequest) {
	fake.listActiveQueriesMutex.Lock()
	defer fake.listActiveQueriesMutex.Unlock()
	fake.ListActiveQueriesStub = nil
	if fake.listActiveQueriesReturnsOnCall == nil {
		fake.listActiveQueriesReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiListActiveQueriesRequest
		})
	}
	fake.listActiveQueriesReturnsOnCall[i] = struct {
		result1 openapi.ApiListActiveQueriesRequest
	}{result1}
}

func (fake *FakeQueriesApi) ListActiveQueriesExecute(arg1 openapi.ApiListActiveQueriesRequest) (*openapi.ListQueriesResponse, *http.Response, error) {
	fake.listActiveQueriesExecuteMutex.Lock()
	ret, specificReturn := fake.listActiveQueriesExecuteReturnsOnCall[len(fake.listActiveQueriesExecuteArgsForCall)]
	fake.listActiveQueriesExecuteArgsForCall = append(fake.listActiveQueriesExecuteArgsForCall, struct {
		arg1 openapi.ApiListActiveQueriesRequest
	}{arg1})
	stub := fake.ListActiveQueriesExecuteStub
	fakeReturns := fake.listActiveQueriesExecuteReturns
	fake.recordInvocation("ListActiveQueriesExecute", []interface{}{arg1})
	fake.listActiveQueriesExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeQueriesApi) ListActiveQueriesExecuteCallCount() int {
	fake.listActiveQueriesExecuteMutex.RLock()
	defer fake.listActiveQueriesExecuteMutex.RUnlock()
	return len(fake.listActiveQueriesExecuteArgsForCall)
}

func (fake *FakeQueriesApi) ListActiveQueriesExecuteCalls(stub func(openapi.ApiListActiveQueriesRequest) (*openapi.ListQueriesResponse, *http.Response, error)) {
	fake.listActiveQueriesExecuteMutex.Lock()
	defer fake.listActiveQueriesExecuteMutex.Unlock()
	fake.ListActiveQueriesExecuteStub = stub
}

func (fake *FakeQueriesApi) ListActiveQueriesExecuteArgsForCall(i int) openapi.ApiListActiveQueriesRequest {
	fake.listActiveQueriesExecuteMutex.RLock()
	defer fake.listActiveQueriesExecuteMutex.RUnlock()
	argsForCall := fake.listActiveQueriesExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQueriesApi) ListActiveQueriesExecuteReturns(result1 *openapi.ListQueriesResponse, result2 *http.Response, result3 error) {
	fake.listActiveQueriesExecuteMutex.Lock()
	defer fake.listActiveQueriesExecuteMutex.Unlock()
	fake.ListActiveQueriesExecuteStub = nil
	fake.listActiveQueriesExecuteReturns = struct {
		result1 *openapi.ListQueriesResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueriesApi) ListActiveQueriesExecuteReturnsOnCall(i int, result1 *openapi.ListQueriesResponse, result2 *http.Response, result3 error) {
	fake.listActiveQueriesExecuteMutex.Lock()
	defer fake.listActiveQueriesExecuteMutex.Unlock()
	fake.ListActiveQueriesExecuteStub = nil
	if fake.listActiveQueriesExecuteReturnsOnCall == nil {
		fake.listActiveQueriesExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.ListQueriesResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.listActiveQueriesExecuteReturnsOnCall[i] = struct {
		result1 *openapi.ListQueriesResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueriesApi) Query(arg1 context.Context) openapi.ApiQueryRequest {
	fake.queryMutex.Lock()
	ret, specificReturn := fake.queryReturnsOnCall[len(fake.queryArgsForCall)]
	fake.queryArgsForCall = append(fake.queryArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.QueryStub
	fakeReturns := fake.queryReturns
	fake.recordInvocation("Query", []interface{}{arg1})
	fake.queryMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQueriesApi) QueryCallCount() int {
	fake.queryMutex.RLock()
	defer fake.queryMutex.RUnlock()
	return len(fake.queryArgsForCall)
}

func (fake *FakeQueriesApi) QueryCalls(stub func(context.Context) openapi.ApiQueryRequest) {
	fake.queryMutex.Lock()
	defer fake.queryMutex.Unlock()
	fake.QueryStub = stub
}

func (fake *FakeQueriesApi) QueryArgsForCall(i int) context.Context {
	fake.queryMutex.RLock()
	defer fake.queryMutex.RUnlock()
	argsForCall := fake.queryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQueriesApi) QueryReturns(result1 openapi.ApiQueryRequest) {
	fake.queryMutex.Lock()
	defer fake.queryMutex.Unlock()
	fake.QueryStub = nil
	fake.queryReturns = struct {
		result1 openapi.ApiQueryRequest
	}{result1}
}

func (fake *FakeQueriesApi) QueryReturnsOnCall(i int, result1 openapi.ApiQueryRequest) {
	fake.queryMutex.Lock()
	defer fake.queryMutex.Unlock()
	fake.QueryStub = nil
	if fake.queryReturnsOnCall == nil {
		fake.queryReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiQueryRequest
		})
	}
	fake.queryReturnsOnCall[i] = struct {
		result1 openapi.ApiQueryRequest
	}{result1}
}

func (fake *FakeQueriesApi) QueryExecute(arg1 openapi.ApiQueryRequest) (*openapi.QueryResponse, *http.Response, error) {
	fake.queryExecuteMutex.Lock()
	ret, specificReturn := fake.queryExecuteReturnsOnCall[len(fake.queryExecuteArgsForCall)]
	fake.queryExecuteArgsForCall = append(fake.queryExecuteArgsForCall, struct {
		arg1 openapi.ApiQueryRequest
	}{arg1})
	stub := fake.QueryExecuteStub
	fakeReturns := fake.queryExecuteReturns
	fake.recordInvocation("QueryExecute", []interface{}{arg1})
	fake.queryExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeQueriesApi) QueryExecuteCallCount() int {
	fake.queryExecuteMutex.RLock()
	defer fake.queryExecuteMutex.RUnlock()
	return len(fake.queryExecuteArgsForCall)
}

func (fake *FakeQueriesApi) QueryExecuteCalls(stub func(openapi.ApiQueryRequest) (*openapi.QueryResponse, *http.Response, error)) {
	fake.queryExecuteMutex.Lock()
	defer fake.queryExecuteMutex.Unlock()
	fake.QueryExecuteStub = stub
}

func (fake *FakeQueriesApi) QueryExecuteArgsForCall(i int) openapi.ApiQueryRequest {
	fake.queryExecuteMutex.RLock()
	defer fake.queryExecuteMutex.RUnlock()
	argsForCall := fake.queryExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQueriesApi) QueryExecuteReturns(result1 *openapi.QueryResponse, result2 *http.Response, result3 error) {
	fake.queryExecuteMutex.Lock()
	defer fake.queryExecuteMutex.Unlock()
	fake.QueryExecuteStub = nil
	fake.queryExecuteReturns = struct {
		result1 *openapi.QueryResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueriesApi) QueryExecuteReturnsOnCall(i int, result1 *openapi.QueryResponse, result2 *http.Response, result3 error) {
	fake.queryExecuteMutex.Lock()
	defer fake.queryExecuteMutex.Unlock()
	fake.QueryExecuteStub = nil
	if fake.queryExecuteReturnsOnCall == nil {
		fake.queryExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.QueryResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.queryExecuteReturnsOnCall[i] = struct {
		result1 *openapi.QueryResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueriesApi) Validate(arg1 context.Context) openapi.ApiValidateRequest {
	fake.validateMutex.Lock()
	ret, specificReturn := fake.validateReturnsOnCall[len(fake.validateArgsForCall)]
	fake.validateArgsForCall = append(fake.validateArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ValidateStub
	fakeReturns := fake.validateReturns
	fake.recordInvocation("Validate", []interface{}{arg1})
	fake.validateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeQueriesApi) ValidateCallCount() int {
	fake.validateMutex.RLock()
	defer fake.validateMutex.RUnlock()
	return len(fake.validateArgsForCall)
}

func (fake *FakeQueriesApi) ValidateCalls(stub func(context.Context) openapi.ApiValidateRequest) {
	fake.validateMutex.Lock()
	defer fake.validateMutex.Unlock()
	fake.ValidateStub = stub
}

func (fake *FakeQueriesApi) ValidateArgsForCall(i int) context.Context {
	fake.validateMutex.RLock()
	defer fake.validateMutex.RUnlock()
	argsForCall := fake.validateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQueriesApi) ValidateReturns(result1 openapi.ApiValidateRequest) {
	fake.validateMutex.Lock()
	defer fake.validateMutex.Unlock()
	fake.ValidateStub = nil
	fake.validateReturns = struct {
		result1 openapi.ApiValidateRequest
	}{result1}
}

func (fake *FakeQueriesApi) ValidateReturnsOnCall(i int, result1 openapi.ApiValidateRequest) {
	fake.validateMutex.Lock()
	defer fake.validateMutex.Unlock()
	fake.ValidateStub = nil
	if fake.validateReturnsOnCall == nil {
		fake.validateReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiValidateRequest
		})
	}
	fake.validateReturnsOnCall[i] = struct {
		result1 openapi.ApiValidateRequest
	}{result1}
}

func (fake *FakeQueriesApi) ValidateExecute(arg1 openapi.ApiValidateRequest) (*openapi.ValidateQueryResponse, *http.Response, error) {
	fake.validateExecuteMutex.Lock()
	ret, specificReturn := fake.validateExecuteReturnsOnCall[len(fake.validateExecuteArgsForCall)]
	fake.validateExecuteArgsForCall = append(fake.validateExecuteArgsForCall, struct {
		arg1 openapi.ApiValidateRequest
	}{arg1})
	stub := fake.ValidateExecuteStub
	fakeReturns := fake.validateExecuteReturns
	fake.recordInvocation("ValidateExecute", []interface{}{arg1})
	fake.validateExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeQueriesApi) ValidateExecuteCallCount() int {
	fake.validateExecuteMutex.RLock()
	defer fake.validateExecuteMutex.RUnlock()
	return len(fake.validateExecuteArgsForCall)
}

func (fake *FakeQueriesApi) ValidateExecuteCalls(stub func(openapi.ApiValidateRequest) (*openapi.ValidateQueryResponse, *http.Response, error)) {
	fake.validateExecuteMutex.Lock()
	defer fake.validateExecuteMutex.Unlock()
	fake.ValidateExecuteStub = stub
}

func (fake *FakeQueriesApi) ValidateExecuteArgsForCall(i int) openapi.ApiValidateRequest {
	fake.validateExecuteMutex.RLock()
	defer fake.validateExecuteMutex.RUnlock()
	argsForCall := fake.validateExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQueriesApi) ValidateExecuteReturns(result1 *openapi.ValidateQueryResponse, result2 *http.Response, result3 error) {
	fake.validateExecuteMutex.Lock()
	defer fake.validateExecuteMutex.Unlock()
	fake.ValidateExecuteStub = nil
	fake.validateExecuteReturns = struct {
		result1 *openapi.ValidateQueryResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueriesApi) ValidateExecuteReturnsOnCall(i int, result1 *openapi.ValidateQueryResponse, result2 *http.Response, result3 error) {
	fake.validateExecuteMutex.Lock()
	defer fake.validateExecuteMutex.Unlock()
	fake.ValidateExecuteStub = nil
	if fake.validateExecuteReturnsOnCall == nil {
		fake.validateExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.ValidateQueryResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.validateExecuteReturnsOnCall[i] = struct {
		result1 *openapi.ValidateQueryResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeQueriesApi) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cancelQueryMutex.RLock()
	defer fake.cancelQueryMutex.RUnlock()
	fake.cancelQueryExecuteMutex.RLock()
	defer fake.cancelQueryExecuteMutex.RUnlock()
	fake.getQueryMutex.RLock()
	defer fake.getQueryMutex.RUnlock()
	fake.getQueryExecuteMutex.RLock()
	defer fake.getQueryExecuteMutex.RUnlock()
	fake.getQueryResultsMutex.RLock()
	defer fake.getQueryResultsMutex.RUnlock()
	fake.getQueryResultsExecuteMutex.RLock()
	defer fake.getQueryResultsExecuteMutex.RUnlock()
	fake.listActiveQueriesMutex.RLock()
	defer fake.listActiveQueriesMutex.RUnlock()
	fake.listActiveQueriesExecuteMutex.RLock()
	defer fake.listActiveQueriesExecuteMutex.RUnlock()
	fake.queryMutex.RLock()
	defer fake.queryMutex.RUnlock()
	fake.queryExecuteMutex.RLock()
	defer fake.queryExecuteMutex.RUnlock()
	fake.validateMutex.RLock()
	defer fake.validateMutex.RUnlock()
	fake.validateExecuteMutex.RLock()
	defer fake.validateExecuteMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeQueriesApi) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ openapi.QueriesApi = new(FakeQueriesApi)
