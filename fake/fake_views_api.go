// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"context"
	"net/http"
	"sync"

	"github.com/rockset/rockset-go-client/openapi"
)

type FakeViewsApi struct {
	CreateViewStub        func(context.Context, string) openapi.ApiCreateViewRequest
	createViewMutex       sync.RWMutex
	createViewArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	createViewReturns struct {
		result1 openapi.ApiCreateViewRequest
	}
	createViewReturnsOnCall map[int]struct {
		result1 openapi.ApiCreateViewRequest
	}
	CreateViewExecuteStub        func(openapi.ApiCreateViewRequest) (*openapi.CreateViewResponse, *http.Response, error)
	createViewExecuteMutex       sync.RWMutex
	createViewExecuteArgsForCall []struct {
		arg1 openapi.ApiCreateViewRequest
	}
	createViewExecuteReturns struct {
		result1 *openapi.CreateViewResponse
		result2 *http.Response
		result3 error
	}
	createViewExecuteReturnsOnCall map[int]struct {
		result1 *openapi.CreateViewResponse
		result2 *http.Response
		result3 error
	}
	DeleteViewStub        func(context.Context, string, string) openapi.ApiDeleteViewRequest
	deleteViewMutex       sync.RWMutex
	deleteViewArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	deleteViewReturns struct {
		result1 openapi.ApiDeleteViewRequest
	}
	deleteViewReturnsOnCall map[int]struct {
		result1 openapi.ApiDeleteViewRequest
	}
	DeleteViewExecuteStub        func(openapi.ApiDeleteViewRequest) (*openapi.DeleteViewResponse, *http.Response, error)
	deleteViewExecuteMutex       sync.RWMutex
	deleteViewExecuteArgsForCall []struct {
		arg1 openapi.ApiDeleteViewRequest
	}
	deleteViewExecuteReturns struct {
		result1 *openapi.DeleteViewResponse
		result2 *http.Response
		result3 error
	}
	deleteViewExecuteReturnsOnCall map[int]struct {
		result1 *openapi.DeleteViewResponse
		result2 *http.Response
		result3 error
	}
	GetViewStub        func(context.Context, string, string) openapi.ApiGetViewRequest
	getViewMutex       sync.RWMutex
	getViewArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	getViewReturns struct {
		result1 openapi.ApiGetViewRequest
	}
	getViewReturnsOnCall map[int]struct {
		result1 openapi.ApiGetViewRequest
	}
	GetViewExecuteStub        func(openapi.ApiGetViewRequest) (*openapi.GetViewResponse, *http.Response, error)
	getViewExecuteMutex       sync.RWMutex
	getViewExecuteArgsForCall []struct {
		arg1 openapi.ApiGetViewRequest
	}
	getViewExecuteReturns struct {
		result1 *openapi.GetViewResponse
		result2 *http.Response
		result3 error
	}
	getViewExecuteReturnsOnCall map[int]struct {
		result1 *openapi.GetViewResponse
		result2 *http.Response
		result3 error
	}
	ListViewsStub        func(context.Context) openapi.ApiListViewsRequest
	listViewsMutex       sync.RWMutex
	listViewsArgsForCall []struct {
		arg1 context.Context
	}
	listViewsReturns struct {
		result1 openapi.ApiListViewsRequest
	}
	listViewsReturnsOnCall map[int]struct {
		result1 openapi.ApiListViewsRequest
	}
	ListViewsExecuteStub        func(openapi.ApiListViewsRequest) (*openapi.ListViewsResponse, *http.Response, error)
	listViewsExecuteMutex       sync.RWMutex
	listViewsExecuteArgsForCall []struct {
		arg1 openapi.ApiListViewsRequest
	}
	listViewsExecuteReturns struct {
		result1 *openapi.ListViewsResponse
		result2 *http.Response
		result3 error
	}
	listViewsExecuteReturnsOnCall map[int]struct {
		result1 *openapi.ListViewsResponse
		result2 *http.Response
		result3 error
	}
	UpdateViewStub        func(context.Context, string, string) openapi.ApiUpdateViewRequest
	updateViewMutex       sync.RWMutex
	updateViewArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	updateViewReturns struct {
		result1 openapi.ApiUpdateViewRequest
	}
	updateViewReturnsOnCall map[int]struct {
		result1 openapi.ApiUpdateViewRequest
	}
	UpdateViewExecuteStub        func(openapi.ApiUpdateViewRequest) (*openapi.UpdateViewResponse, *http.Response, error)
	updateViewExecuteMutex       sync.RWMutex
	updateViewExecuteArgsForCall []struct {
		arg1 openapi.ApiUpdateViewRequest
	}
	updateViewExecuteReturns struct {
		result1 *openapi.UpdateViewResponse
		result2 *http.Response
		result3 error
	}
	updateViewExecuteReturnsOnCall map[int]struct {
		result1 *openapi.UpdateViewResponse
		result2 *http.Response
		result3 error
	}
	WorkspaceViewsStub        func(context.Context, string) openapi.ApiWorkspaceViewsRequest
	workspaceViewsMutex       sync.RWMutex
	workspaceViewsArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	workspaceViewsReturns struct {
		result1 openapi.ApiWorkspaceViewsRequest
	}
	workspaceViewsReturnsOnCall map[int]struct {
		result1 openapi.ApiWorkspaceViewsRequest
	}
	WorkspaceViewsExecuteStub        func(openapi.ApiWorkspaceViewsRequest) (*openapi.ListViewsResponse, *http.Response, error)
	workspaceViewsExecuteMutex       sync.RWMutex
	workspaceViewsExecuteArgsForCall []struct {
		arg1 openapi.ApiWorkspaceViewsRequest
	}
	workspaceViewsExecuteReturns struct {
		result1 *openapi.ListViewsResponse
		result2 *http.Response
		result3 error
	}
	workspaceViewsExecuteReturnsOnCall map[int]struct {
		result1 *openapi.ListViewsResponse
		result2 *http.Response
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeViewsApi) CreateView(arg1 context.Context, arg2 string) openapi.ApiCreateViewRequest {
	fake.createViewMutex.Lock()
	ret, specificReturn := fake.createViewReturnsOnCall[len(fake.createViewArgsForCall)]
	fake.createViewArgsForCall = append(fake.createViewArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.CreateViewStub
	fakeReturns := fake.createViewReturns
	fake.recordInvocation("CreateView", []interface{}{arg1, arg2})
	fake.createViewMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeViewsApi) CreateViewCallCount() int {
	fake.createViewMutex.RLock()
	defer fake.createViewMutex.RUnlock()
	return len(fake.createViewArgsForCall)
}

func (fake *FakeViewsApi) CreateViewCalls(stub func(context.Context, string) openapi.ApiCreateViewRequest) {
	fake.createViewMutex.Lock()
	defer fake.createViewMutex.Unlock()
	fake.CreateViewStub = stub
}

func (fake *FakeViewsApi) CreateViewArgsForCall(i int) (context.Context, string) {
	fake.createViewMutex.RLock()
	defer fake.createViewMutex.RUnlock()
	argsForCall := fake.createViewArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeViewsApi) CreateViewReturns(result1 openapi.ApiCreateViewRequest) {
	fake.createViewMutex.Lock()
	defer fake.createViewMutex.Unlock()
	fake.CreateViewStub = nil
	fake.createViewReturns = struct {
		result1 openapi.ApiCreateViewRequest
	}{result1}
}

func (fake *FakeViewsApi) CreateViewReturnsOnCall(i int, result1 openapi.ApiCreateViewRequest) {
	fake.createViewMutex.Lock()
	defer fake.createViewMutex.Unlock()
	fake.CreateViewStub = nil
	if fake.createViewReturnsOnCall == nil {
		fake.createViewReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiCreateViewRequest
		})
	}
	fake.createViewReturnsOnCall[i] = struct {
		result1 openapi.ApiCreateViewRequest
	}{result1}
}

func (fake *FakeViewsApi) CreateViewExecute(arg1 openapi.ApiCreateViewRequest) (*openapi.CreateViewResponse, *http.Response, error) {
	fake.createViewExecuteMutex.Lock()
	ret, specificReturn := fake.createViewExecuteReturnsOnCall[len(fake.createViewExecuteArgsForCall)]
	fake.createViewExecuteArgsForCall = append(fake.createViewExecuteArgsForCall, struct {
		arg1 openapi.ApiCreateViewRequest
	}{arg1})
	stub := fake.CreateViewExecuteStub
	fakeReturns := fake.createViewExecuteReturns
	fake.recordInvocation("CreateViewExecute", []interface{}{arg1})
	fake.createViewExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeViewsApi) CreateViewExecuteCallCount() int {
	fake.createViewExecuteMutex.RLock()
	defer fake.createViewExecuteMutex.RUnlock()
	return len(fake.createViewExecuteArgsForCall)
}

func (fake *FakeViewsApi) CreateViewExecuteCalls(stub func(openapi.ApiCreateViewRequest) (*openapi.CreateViewResponse, *http.Response, error)) {
	fake.createViewExecuteMutex.Lock()
	defer fake.createViewExecuteMutex.Unlock()
	fake.CreateViewExecuteStub = stub
}

func (fake *FakeViewsApi) CreateViewExecuteArgsForCall(i int) openapi.ApiCreateViewRequest {
	fake.createViewExecuteMutex.RLock()
	defer fake.createViewExecuteMutex.RUnlock()
	argsForCall := fake.createViewExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeViewsApi) CreateViewExecuteReturns(result1 *openapi.CreateViewResponse, result2 *http.Response, result3 error) {
	fake.createViewExecuteMutex.Lock()
	defer fake.createViewExecuteMutex.Unlock()
	fake.CreateViewExecuteStub = nil
	fake.createViewExecuteReturns = struct {
		result1 *openapi.CreateViewResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeViewsApi) CreateViewExecuteReturnsOnCall(i int, result1 *openapi.CreateViewResponse, result2 *http.Response, result3 error) {
	fake.createViewExecuteMutex.Lock()
	defer fake.createViewExecuteMutex.Unlock()
	fake.CreateViewExecuteStub = nil
	if fake.createViewExecuteReturnsOnCall == nil {
		fake.createViewExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.CreateViewResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.createViewExecuteReturnsOnCall[i] = struct {
		result1 *openapi.CreateViewResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeViewsApi) DeleteView(arg1 context.Context, arg2 string, arg3 string) openapi.ApiDeleteViewRequest {
	fake.deleteViewMutex.Lock()
	ret, specificReturn := fake.deleteViewReturnsOnCall[len(fake.deleteViewArgsForCall)]
	fake.deleteViewArgsForCall = append(fake.deleteViewArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.DeleteViewStub
	fakeReturns := fake.deleteViewReturns
	fake.recordInvocation("DeleteView", []interface{}{arg1, arg2, arg3})
	fake.deleteViewMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeViewsApi) DeleteViewCallCount() int {
	fake.deleteViewMutex.RLock()
	defer fake.deleteViewMutex.RUnlock()
	return len(fake.deleteViewArgsForCall)
}

func (fake *FakeViewsApi) DeleteViewCalls(stub func(context.Context, string, string) openapi.ApiDeleteViewRequest) {
	fake.deleteViewMutex.Lock()
	defer fake.deleteViewMutex.Unlock()
	fake.DeleteViewStub = stub
}

func (fake *FakeViewsApi) DeleteViewArgsForCall(i int) (context.Context, string, string) {
	fake.deleteViewMutex.RLock()
	defer fake.deleteViewMutex.RUnlock()
	argsForCall := fake.deleteViewArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeViewsApi) DeleteViewReturns(result1 openapi.ApiDeleteViewRequest) {
	fake.deleteViewMutex.Lock()
	defer fake.deleteViewMutex.Unlock()
	fake.DeleteViewStub = nil
	fake.deleteViewReturns = struct {
		result1 openapi.ApiDeleteViewRequest
	}{result1}
}

func (fake *FakeViewsApi) DeleteViewReturnsOnCall(i int, result1 openapi.ApiDeleteViewRequest) {
	fake.deleteViewMutex.Lock()
	defer fake.deleteViewMutex.Unlock()
	fake.DeleteViewStub = nil
	if fake.deleteViewReturnsOnCall == nil {
		fake.deleteViewReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiDeleteViewRequest
		})
	}
	fake.deleteViewReturnsOnCall[i] = struct {
		result1 openapi.ApiDeleteViewRequest
	}{result1}
}

func (fake *FakeViewsApi) DeleteViewExecute(arg1 openapi.ApiDeleteViewRequest) (*openapi.DeleteViewResponse, *http.Response, error) {
	fake.deleteViewExecuteMutex.Lock()
	ret, specificReturn := fake.deleteViewExecuteReturnsOnCall[len(fake.deleteViewExecuteArgsForCall)]
	fake.deleteViewExecuteArgsForCall = append(fake.deleteViewExecuteArgsForCall, struct {
		arg1 openapi.ApiDeleteViewRequest
	}{arg1})
	stub := fake.DeleteViewExecuteStub
	fakeReturns := fake.deleteViewExecuteReturns
	fake.recordInvocation("DeleteViewExecute", []interface{}{arg1})
	fake.deleteViewExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeViewsApi) DeleteViewExecuteCallCount() int {
	fake.deleteViewExecuteMutex.RLock()
	defer fake.deleteViewExecuteMutex.RUnlock()
	return len(fake.deleteViewExecuteArgsForCall)
}

func (fake *FakeViewsApi) DeleteViewExecuteCalls(stub func(openapi.ApiDeleteViewRequest) (*openapi.DeleteViewResponse, *http.Response, error)) {
	fake.deleteViewExecuteMutex.Lock()
	defer fake.deleteViewExecuteMutex.Unlock()
	fake.DeleteViewExecuteStub = stub
}

func (fake *FakeViewsApi) DeleteViewExecuteArgsForCall(i int) openapi.ApiDeleteViewRequest {
	fake.deleteViewExecuteMutex.RLock()
	defer fake.deleteViewExecuteMutex.RUnlock()
	argsForCall := fake.deleteViewExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeViewsApi) DeleteViewExecuteReturns(result1 *openapi.DeleteViewResponse, result2 *http.Response, result3 error) {
	fake.deleteViewExecuteMutex.Lock()
	defer fake.deleteViewExecuteMutex.Unlock()
	fake.DeleteViewExecuteStub = nil
	fake.deleteViewExecuteReturns = struct {
		result1 *openapi.DeleteViewResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeViewsApi) DeleteViewExecuteReturnsOnCall(i int, result1 *openapi.DeleteViewResponse, result2 *http.Response, result3 error) {
	fake.deleteViewExecuteMutex.Lock()
	defer fake.deleteViewExecuteMutex.Unlock()
	fake.DeleteViewExecuteStub = nil
	if fake.deleteViewExecuteReturnsOnCall == nil {
		fake.deleteViewExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.DeleteViewResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.deleteViewExecuteReturnsOnCall[i] = struct {
		result1 *openapi.DeleteViewResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeViewsApi) GetView(arg1 context.Context, arg2 string, arg3 string) openapi.ApiGetViewRequest {
	fake.getViewMutex.Lock()
	ret, specificReturn := fake.getViewReturnsOnCall[len(fake.getViewArgsForCall)]
	fake.getViewArgsForCall = append(fake.getViewArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetViewStub
	fakeReturns := fake.getViewReturns
	fake.recordInvocation("GetView", []interface{}{arg1, arg2, arg3})
	fake.getViewMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeViewsApi) GetViewCallCount() int {
	fake.getViewMutex.RLock()
	defer fake.getViewMutex.RUnlock()
	return len(fake.getViewArgsForCall)
}

func (fake *FakeViewsApi) GetViewCalls(stub func(context.Context, string, string) openapi.ApiGetViewRequest) {
	fake.getViewMutex.Lock()
	defer fake.getViewMutex.Unlock()
	fake.GetViewStub = stub
}

func (fake *FakeViewsApi) GetViewArgsForCall(i int) (context.Context, string, string) {
	fake.getViewMutex.RLock()
	defer fake.getViewMutex.RUnlock()
	argsForCall := fake.getViewArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeViewsApi) GetViewReturns(result1 openapi.ApiGetViewRequest) {
	fake.getViewMutex.Lock()
	defer fake.getViewMutex.Unlock()
	fake.GetViewStub = nil
	fake.getViewReturns = struct {
		result1 openapi.ApiGetViewRequest
	}{result1}
}

func (fake *FakeViewsApi) GetViewReturnsOnCall(i int, result1 openapi.ApiGetViewRequest) {
	fake.getViewMutex.Lock()
	defer fake.getViewMutex.Unlock()
	fake.GetViewStub = nil
	if fake.getViewReturnsOnCall == nil {
		fake.getViewReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiGetViewRequest
		})
	}
	fake.getViewReturnsOnCall[i] = struct {
		result1 openapi.ApiGetViewRequest
	}{result1}
}

func (fake *FakeViewsApi) GetViewExecute(arg1 openapi.ApiGetViewRequest) (*openapi.GetViewResponse, *http.Response, error) {
	fake.getViewExecuteMutex.Lock()
	ret, specificReturn := fake.getViewExecuteReturnsOnCall[len(fake.getViewExecuteArgsForCall)]
	fake.getViewExecuteArgsForCall = append(fake.getViewExecuteArgsForCall, struct {
		arg1 openapi.ApiGetViewRequest
	}{arg1})
	stub := fake.GetViewExecuteStub
	fakeReturns := fake.getViewExecuteReturns
	fake.recordInvocation("GetViewExecute", []interface{}{arg1})
	fake.getViewExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeViewsApi) GetViewExecuteCallCount() int {
	fake.getViewExecuteMutex.RLock()
	defer fake.getViewExecuteMutex.RUnlock()
	return len(fake.getViewExecuteArgsForCall)
}

func (fake *FakeViewsApi) GetViewExecuteCalls(stub func(openapi.ApiGetViewRequest) (*openapi.GetViewResponse, *http.Response, error)) {
	fake.getViewExecuteMutex.Lock()
	defer fake.getViewExecuteMutex.Unlock()
	fake.GetViewExecuteStub = stub
}

func (fake *FakeViewsApi) GetViewExecuteArgsForCall(i int) openapi.ApiGetViewRequest {
	fake.getViewExecuteMutex.RLock()
	defer fake.getViewExecuteMutex.RUnlock()
	argsForCall := fake.getViewExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeViewsApi) GetViewExecuteReturns(result1 *openapi.GetViewResponse, result2 *http.Response, result3 error) {
	fake.getViewExecuteMutex.Lock()
	defer fake.getViewExecuteMutex.Unlock()
	fake.GetViewExecuteStub = nil
	fake.getViewExecuteReturns = struct {
		result1 *openapi.GetViewResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeViewsApi) GetViewExecuteReturnsOnCall(i int, result1 *openapi.GetViewResponse, result2 *http.Response, result3 error) {
	fake.getViewExecuteMutex.Lock()
	defer fake.getViewExecuteMutex.Unlock()
	fake.GetViewExecuteStub = nil
	if fake.getViewExecuteReturnsOnCall == nil {
		fake.getViewExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.GetViewResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.getViewExecuteReturnsOnCall[i] = struct {
		result1 *openapi.GetViewResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeViewsApi) ListViews(arg1 context.Context) openapi.ApiListViewsRequest {
	fake.listViewsMutex.Lock()
	ret, specificReturn := fake.listViewsReturnsOnCall[len(fake.listViewsArgsForCall)]
	fake.listViewsArgsForCall = append(fake.listViewsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ListViewsStub
	fakeReturns := fake.listViewsReturns
	fake.recordInvocation("ListViews", []interface{}{arg1})
	fake.listViewsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeViewsApi) ListViewsCallCount() int {
	fake.listViewsMutex.RLock()
	defer fake.listViewsMutex.RUnlock()
	return len(fake.listViewsArgsForCall)
}

func (fake *FakeViewsApi) ListViewsCalls(stub func(context.Context) openapi.ApiListViewsRequest) {
	fake.listViewsMutex.Lock()
	defer fake.listViewsMutex.Unlock()
	fake.ListViewsStub = stub
}

func (fake *FakeViewsApi) ListViewsArgsForCall(i int) context.Context {
	fake.listViewsMutex.RLock()
	defer fake.listViewsMutex.RUnlock()
	argsForCall := fake.listViewsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeViewsApi) ListViewsReturns(result1 openapi.ApiListViewsRequest) {
	fake.listViewsMutex.Lock()
	defer fake.listViewsMutex.Unlock()
	fake.ListViewsStub = nil
	fake.listViewsReturns = struct {
		result1 openapi.ApiListViewsRequest
	}{result1}
}

func (fake *FakeViewsApi) ListViewsReturnsOnCall(i int, result1 openapi.ApiListViewsRequest) {
	fake.listViewsMutex.Lock()
	defer fake.listViewsMutex.Unlock()
	fake.ListViewsStub = nil
	if fake.listViewsReturnsOnCall == nil {
		fake.listViewsReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiListViewsRequest
		})
	}
	fake.listViewsReturnsOnCall[i] = struct {
		result1 openapi.ApiListViewsRequest
	}{result1}
}

func (fake *FakeViewsApi) ListViewsExecute(arg1 openapi.ApiListViewsRequest) (*openapi.ListViewsResponse, *http.Response, error) {
	fake.listViewsExecuteMutex.Lock()
	ret, specificReturn := fake.listViewsExecuteReturnsOnCall[len(fake.listViewsExecuteArgsForCall)]
	fake.listViewsExecuteArgsForCall = append(fake.listViewsExecuteArgsForCall, struct {
		arg1 openapi.ApiListViewsRequest
	}{arg1})
	stub := fake.ListViewsExecuteStub
	fakeReturns := fake.listViewsExecuteReturns
	fake.recordInvocation("ListViewsExecute", []interface{}{arg1})
	fake.listViewsExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeViewsApi) ListViewsExecuteCallCount() int {
	fake.listViewsExecuteMutex.RLock()
	defer fake.listViewsExecuteMutex.RUnlock()
	return len(fake.listViewsExecuteArgsForCall)
}

func (fake *FakeViewsApi) ListViewsExecuteCalls(stub func(openapi.ApiListViewsRequest) (*openapi.ListViewsResponse, *http.Response, error)) {
	fake.listViewsExecuteMutex.Lock()
	defer fake.listViewsExecuteMutex.Unlock()
	fake.ListViewsExecuteStub = stub
}

func (fake *FakeViewsApi) ListViewsExecuteArgsForCall(i int) openapi.ApiListViewsRequest {
	fake.listViewsExecuteMutex.RLock()
	defer fake.listViewsExecuteMutex.RUnlock()
	argsForCall := fake.listViewsExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeViewsApi) ListViewsExecuteReturns(result1 *openapi.ListViewsResponse, result2 *http.Response, result3 error) {
	fake.listViewsExecuteMutex.Lock()
	defer fake.listViewsExecuteMutex.Unlock()
	fake.ListViewsExecuteStub = nil
	fake.listViewsExecuteReturns = struct {
		result1 *openapi.ListViewsResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeViewsApi) ListViewsExecuteReturnsOnCall(i int, result1 *openapi.ListViewsResponse, result2 *http.Response, result3 error) {
	fake.listViewsExecuteMutex.Lock()
	defer fake.listViewsExecuteMutex.Unlock()
	fake.ListViewsExecuteStub = nil
	if fake.listViewsExecuteReturnsOnCall == nil {
		fake.listViewsExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.ListViewsResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.listViewsExecuteReturnsOnCall[i] = struct {
		result1 *openapi.ListViewsResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeViewsApi) UpdateView(arg1 context.Context, arg2 string, arg3 string) openapi.ApiUpdateViewRequest {
	fake.updateViewMutex.Lock()
	ret, specificReturn := fake.updateViewReturnsOnCall[len(fake.updateViewArgsForCall)]
	fake.updateViewArgsForCall = append(fake.updateViewArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.UpdateViewStub
	fakeReturns := fake.updateViewReturns
	fake.recordInvocation("UpdateView", []interface{}{arg1, arg2, arg3})
	fake.updateViewMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeViewsApi) UpdateViewCallCount() int {
	fake.updateViewMutex.RLock()
	defer fake.updateViewMutex.RUnlock()
	return len(fake.updateViewArgsForCall)
}

func (fake *FakeViewsApi) UpdateViewCalls(stub func(context.Context, string, string) openapi.ApiUpdateViewRequest) {
	fake.updateViewMutex.Lock()
	defer fake.updateViewMutex.Unlock()
	fake.UpdateViewStub = stub
}

func (fake *FakeViewsApi) UpdateViewArgsForCall(i int) (context.Context, string, string) {
	fake.updateViewMutex.RLock()
	defer fake.updateViewMutex.RUnlock()
	argsForCall := fake.updateViewArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeViewsApi) UpdateViewReturns(result1 openapi.ApiUpdateViewRequest) {
	fake.updateViewMutex.Lock()
	defer fake.updateViewMutex.Unlock()
	fake.UpdateViewStub = nil
	fake.updateViewReturns = struct {
		result1 openapi.ApiUpdateViewRequest
	}{result1}
}

func (fake *FakeViewsApi) UpdateViewReturnsOnCall(i int, result1 openapi.ApiUpdateViewRequest) {
	fake.updateViewMutex.Lock()
	defer fake.updateViewMutex.Unlock()
	fake.UpdateViewStub = nil
	if fake.updateViewReturnsOnCall == nil {
		fake.updateViewReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiUpdateViewRequest
		})
	}
	fake.updateViewReturnsOnCall[i] = struct {
		result1 openapi.ApiUpdateViewRequest
	}{result1}
}

func (fake *FakeViewsApi) UpdateViewExecute(arg1 openapi.ApiUpdateViewRequest) (*openapi.UpdateViewResponse, *http.Response, error) {
	fake.updateViewExecuteMutex.Lock()
	ret, specificReturn := fake.updateViewExecuteReturnsOnCall[len(fake.updateViewExecuteArgsForCall)]
	fake.updateViewExecuteArgsForCall = append(fake.updateViewExecuteArgsForCall, struct {
		arg1 openapi.ApiUpdateViewRequest
	}{arg1})
	stub := fake.UpdateViewExecuteStub
	fakeReturns := fake.updateViewExecuteReturns
	fake.recordInvocation("UpdateViewExecute", []interface{}{arg1})
	fake.updateViewExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeViewsApi) UpdateViewExecuteCallCount() int {
	fake.updateViewExecuteMutex.RLock()
	defer fake.updateViewExecuteMutex.RUnlock()
	return len(fake.updateViewExecuteArgsForCall)
}

func (fake *FakeViewsApi) UpdateViewExecuteCalls(stub func(openapi.ApiUpdateViewRequest) (*openapi.UpdateViewResponse, *http.Response, error)) {
	fake.updateViewExecuteMutex.Lock()
	defer fake.updateViewExecuteMutex.Unlock()
	fake.UpdateViewExecuteStub = stub
}

func (fake *FakeViewsApi) UpdateViewExecuteArgsForCall(i int) openapi.ApiUpdateViewRequest {
	fake.updateViewExecuteMutex.RLock()
	defer fake.updateViewExecuteMutex.RUnlock()
	argsForCall := fake.updateViewExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeViewsApi) UpdateViewExecuteReturns(result1 *openapi.UpdateViewResponse, result2 *http.Response, result3 error) {
	fake.updateViewExecuteMutex.Lock()
	defer fake.updateViewExecuteMutex.Unlock()
	fake.UpdateViewExecuteStub = nil
	fake.updateViewExecuteReturns = struct {
		result1 *openapi.UpdateViewResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeViewsApi) UpdateViewExecuteReturnsOnCall(i int, result1 *openapi.UpdateViewResponse, result2 *http.Response, result3 error) {
	fake.updateViewExecuteMutex.Lock()
	defer fake.updateViewExecuteMutex.Unlock()
	fake.UpdateViewExecuteStub = nil
	if fake.updateViewExecuteReturnsOnCall == nil {
		fake.updateViewExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.UpdateViewResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.updateViewExecuteReturnsOnCall[i] = struct {
		result1 *openapi.UpdateViewResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeViewsApi) WorkspaceViews(arg1 context.Context, arg2 string) openapi.ApiWorkspaceViewsRequest {
	fake.workspaceViewsMutex.Lock()
	ret, specificReturn := fake.workspaceViewsReturnsOnCall[len(fake.workspaceViewsArgsForCall)]
	fake.workspaceViewsArgsForCall = append(fake.workspaceViewsArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.WorkspaceViewsStub
	fakeReturns := fake.workspaceViewsReturns
	fake.recordInvocation("WorkspaceViews", []interface{}{arg1, arg2})
	fake.workspaceViewsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeViewsApi) WorkspaceViewsCallCount() int {
	fake.workspaceViewsMutex.RLock()
	defer fake.workspaceViewsMutex.RUnlock()
	return len(fake.workspaceViewsArgsForCall)
}

func (fake *FakeViewsApi) WorkspaceViewsCalls(stub func(context.Context, string) openapi.ApiWorkspaceViewsRequest) {
	fake.workspaceViewsMutex.Lock()
	defer fake.workspaceViewsMutex.Unlock()
	fake.WorkspaceViewsStub = stub
}

func (fake *FakeViewsApi) WorkspaceViewsArgsForCall(i int) (context.Context, string) {
	fake.workspaceViewsMutex.RLock()
	defer fake.workspaceViewsMutex.RUnlock()
	argsForCall := fake.workspaceViewsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeViewsApi) WorkspaceViewsReturns(result1 openapi.ApiWorkspaceViewsRequest) {
	fake.workspaceViewsMutex.Lock()
	defer fake.workspaceViewsMutex.Unlock()
	fake.WorkspaceViewsStub = nil
	fake.workspaceViewsReturns = struct {
		result1 openapi.ApiWorkspaceViewsRequest
	}{result1}
}

func (fake *FakeViewsApi) WorkspaceViewsReturnsOnCall(i int, result1 openapi.ApiWorkspaceViewsRequest) {
	fake.workspaceViewsMutex.Lock()
	defer fake.workspaceViewsMutex.Unlock()
	fake.WorkspaceViewsStub = nil
	if fake.workspaceViewsReturnsOnCall == nil {
		fake.workspaceViewsReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiWorkspaceViewsRequest
		})
	}
	fake.workspaceViewsReturnsOnCall[i] = struct {
		result1 openapi.ApiWorkspaceViewsRequest
	}{result1}
}

func (fake *FakeViewsApi) WorkspaceViewsExecute(arg1 openapi.ApiWorkspaceViewsRequest) (*openapi.ListViewsResponse, *http.Response, error) {
	fake.workspaceViewsExecuteMutex.Lock()
	ret, specificReturn := fake.workspaceViewsExecuteReturnsOnCall[len(fake.workspaceViewsExecuteArgsForCall)]
	fake.workspaceViewsExecuteArgsForCall = append(fake.workspaceViewsExecuteArgsForCall, struct {
		arg1 openapi.ApiWorkspaceViewsRequest
	}{arg1})
	stub := fake.WorkspaceViewsExecuteStub
	fakeReturns := fake.workspaceViewsExecuteReturns
	fake.recordInvocation("WorkspaceViewsExecute", []interface{}{arg1})
	fake.workspaceViewsExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeViewsApi) WorkspaceViewsExecuteCallCount() int {
	fake.workspaceViewsExecuteMutex.RLock()
	defer fake.workspaceViewsExecuteMutex.RUnlock()
	return len(fake.workspaceViewsExecuteArgsForCall)
}

func (fake *FakeViewsApi) WorkspaceViewsExecuteCalls(stub func(openapi.ApiWorkspaceViewsRequest) (*openapi.ListViewsResponse, *http.Response, error)) {
	fake.workspaceViewsExecuteMutex.Lock()
	defer fake.workspaceViewsExecuteMutex.Unlock()
	fake.WorkspaceViewsExecuteStub = stub
}

func (fake *FakeViewsApi) WorkspaceViewsExecuteArgsForCall(i int) openapi.ApiWorkspaceViewsRequest {
	fake.workspaceViewsExecuteMutex.RLock()
	defer fake.workspaceViewsExecuteMutex.RUnlock()
	argsForCall := fake.workspaceViewsExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeViewsApi) WorkspaceViewsExecuteReturns(result1 *openapi.ListViewsResponse, result2 *http.Response, result3 error) {
	fake.workspaceViewsExecuteMutex.Lock()
	defer fake.workspaceViewsExecuteMutex.Unlock()
	fake.WorkspaceViewsExecuteStub = nil
	fake.workspaceViewsExecuteReturns = struct {
		result1 *openapi.ListViewsResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeViewsApi) WorkspaceViewsExecuteReturnsOnCall(i int, result1 *openapi.ListViewsResponse, result2 *http.Response, result3 error) {
	fake.workspaceViewsExecuteMutex.Lock()
	defer fake.workspaceViewsExecuteMutex.Unlock()
	fake.WorkspaceViewsExecuteStub = nil
	if fake.workspaceViewsExecuteReturnsOnCall == nil {
		fake.workspaceViewsExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.ListViewsResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.workspaceViewsExecuteReturnsOnCall[i] = struct {
		result1 *openapi.ListViewsResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeViewsApi) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createViewMutex.RLock()
	defer fake.createViewMutex.RUnlock()
	fake.createViewExecuteMutex.RLock()
	defer fake.createViewExecuteMutex.RUnlock()
	fake.deleteViewMutex.RLock()
	defer fake.deleteViewMutex.RUnlock()
	fake.deleteViewExecuteMutex.RLock()
	defer fake.deleteViewExecuteMutex.RUnlock()
	fake.getViewMutex.RLock()
	defer fake.getViewMutex.RUnlock()
	fake.getViewExecuteMutex.RLock()
	defer fake.getViewExecuteMutex.RUnlock()
	fake.listViewsMutex.RLock()
	defer fake.listViewsMutex.RUnlock()
	fake.listViewsExecuteMutex.RLock()
	defer fake.listViewsExecuteMutex.RUnlock()
	fake.updateViewMutex.RLock()
	defer fake.updateViewMutex.RUnlock()
	fake.updateViewExecuteMutex.RLock()
	defer fake.updateViewExecuteMutex.RUnlock()
	fake.workspaceViewsMutex.RLock()
	defer fake.workspaceViewsMutex.RUnlock()
	fake.workspaceViewsExecuteMutex.RLock()
	defer fake.workspaceViewsExecuteMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeViewsApi) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ openapi.ViewsApi = new(FakeViewsApi)
