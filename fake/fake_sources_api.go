// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"context"
	"net/http"
	"sync"

	"github.com/rockset/rockset-go-client/openapi"
)

type FakeSourcesApi struct {
	CreateSourceStub        func(context.Context, string, string) openapi.ApiCreateSourceRequest
	createSourceMutex       sync.RWMutex
	createSourceArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	createSourceReturns struct {
		result1 openapi.ApiCreateSourceRequest
	}
	createSourceReturnsOnCall map[int]struct {
		result1 openapi.ApiCreateSourceRequest
	}
	CreateSourceExecuteStub        func(openapi.ApiCreateSourceRequest) (*openapi.GetSourceResponse, *http.Response, error)
	createSourceExecuteMutex       sync.RWMutex
	createSourceExecuteArgsForCall []struct {
		arg1 openapi.ApiCreateSourceRequest
	}
	createSourceExecuteReturns struct {
		result1 *openapi.GetSourceResponse
		result2 *http.Response
		result3 error
	}
	createSourceExecuteReturnsOnCall map[int]struct {
		result1 *openapi.GetSourceResponse
		result2 *http.Response
		result3 error
	}
	DeleteSourceStub        func(context.Context, string, string, string) openapi.ApiDeleteSourceRequest
	deleteSourceMutex       sync.RWMutex
	deleteSourceArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	deleteSourceReturns struct {
		result1 openapi.ApiDeleteSourceRequest
	}
	deleteSourceReturnsOnCall map[int]struct {
		result1 openapi.ApiDeleteSourceRequest
	}
	DeleteSourceExecuteStub        func(openapi.ApiDeleteSourceRequest) (*openapi.DeleteSourceResponse, *http.Response, error)
	deleteSourceExecuteMutex       sync.RWMutex
	deleteSourceExecuteArgsForCall []struct {
		arg1 openapi.ApiDeleteSourceRequest
	}
	deleteSourceExecuteReturns struct {
		result1 *openapi.DeleteSourceResponse
		result2 *http.Response
		result3 error
	}
	deleteSourceExecuteReturnsOnCall map[int]struct {
		result1 *openapi.DeleteSourceResponse
		result2 *http.Response
		result3 error
	}
	GetSourceStub        func(context.Context, string, string, string) openapi.ApiGetSourceRequest
	getSourceMutex       sync.RWMutex
	getSourceArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	getSourceReturns struct {
		result1 openapi.ApiGetSourceRequest
	}
	getSourceReturnsOnCall map[int]struct {
		result1 openapi.ApiGetSourceRequest
	}
	GetSourceExecuteStub        func(openapi.ApiGetSourceRequest) (*openapi.GetSourceResponse, *http.Response, error)
	getSourceExecuteMutex       sync.RWMutex
	getSourceExecuteArgsForCall []struct {
		arg1 openapi.ApiGetSourceRequest
	}
	getSourceExecuteReturns struct {
		result1 *openapi.GetSourceResponse
		result2 *http.Response
		result3 error
	}
	getSourceExecuteReturnsOnCall map[int]struct {
		result1 *openapi.GetSourceResponse
		result2 *http.Response
		result3 error
	}
	ListCollectionSourcesStub        func(context.Context, string, string) openapi.ApiListCollectionSourcesRequest
	listCollectionSourcesMutex       sync.RWMutex
	listCollectionSourcesArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	listCollectionSourcesReturns struct {
		result1 openapi.ApiListCollectionSourcesRequest
	}
	listCollectionSourcesReturnsOnCall map[int]struct {
		result1 openapi.ApiListCollectionSourcesRequest
	}
	ListCollectionSourcesExecuteStub        func(openapi.ApiListCollectionSourcesRequest) (*openapi.ListSourcesResponse, *http.Response, error)
	listCollectionSourcesExecuteMutex       sync.RWMutex
	listCollectionSourcesExecuteArgsForCall []struct {
		arg1 openapi.ApiListCollectionSourcesRequest
	}
	listCollectionSourcesExecuteReturns struct {
		result1 *openapi.ListSourcesResponse
		result2 *http.Response
		result3 error
	}
	listCollectionSourcesExecuteReturnsOnCall map[int]struct {
		result1 *openapi.ListSourcesResponse
		result2 *http.Response
		result3 error
	}
	ResumeSourceStub        func(context.Context, string, string, string) openapi.ApiResumeSourceRequest
	resumeSourceMutex       sync.RWMutex
	resumeSourceArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	resumeSourceReturns struct {
		result1 openapi.ApiResumeSourceRequest
	}
	resumeSourceReturnsOnCall map[int]struct {
		result1 openapi.ApiResumeSourceRequest
	}
	ResumeSourceExecuteStub        func(openapi.ApiResumeSourceRequest) (*openapi.GetSourceResponse, *http.Response, error)
	resumeSourceExecuteMutex       sync.RWMutex
	resumeSourceExecuteArgsForCall []struct {
		arg1 openapi.ApiResumeSourceRequest
	}
	resumeSourceExecuteReturns struct {
		result1 *openapi.GetSourceResponse
		result2 *http.Response
		result3 error
	}
	resumeSourceExecuteReturnsOnCall map[int]struct {
		result1 *openapi.GetSourceResponse
		result2 *http.Response
		result3 error
	}
	SuspendSourceStub        func(context.Context, string, string, string) openapi.ApiSuspendSourceRequest
	suspendSourceMutex       sync.RWMutex
	suspendSourceArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	suspendSourceReturns struct {
		result1 openapi.ApiSuspendSourceRequest
	}
	suspendSourceReturnsOnCall map[int]struct {
		result1 openapi.ApiSuspendSourceRequest
	}
	SuspendSourceExecuteStub        func(openapi.ApiSuspendSourceRequest) (*openapi.GetSourceResponse, *http.Response, error)
	suspendSourceExecuteMutex       sync.RWMutex
	suspendSourceExecuteArgsForCall []struct {
		arg1 openapi.ApiSuspendSourceRequest
	}
	suspendSourceExecuteReturns struct {
		result1 *openapi.GetSourceResponse
		result2 *http.Response
		result3 error
	}
	suspendSourceExecuteReturnsOnCall map[int]struct {
		result1 *openapi.GetSourceResponse
		result2 *http.Response
		result3 error
	}
	UpdateSourceStub        func(context.Context, string, string, string) openapi.ApiUpdateSourceRequest
	updateSourceMutex       sync.RWMutex
	updateSourceArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	updateSourceReturns struct {
		result1 openapi.ApiUpdateSourceRequest
	}
	updateSourceReturnsOnCall map[int]struct {
		result1 openapi.ApiUpdateSourceRequest
	}
	UpdateSourceExecuteStub        func(openapi.ApiUpdateSourceRequest) (*openapi.GetSourceResponse, *http.Response, error)
	updateSourceExecuteMutex       sync.RWMutex
	updateSourceExecuteArgsForCall []struct {
		arg1 openapi.ApiUpdateSourceRequest
	}
	updateSourceExecuteReturns struct {
		result1 *openapi.GetSourceResponse
		result2 *http.Response
		result3 error
	}
	updateSourceExecuteReturnsOnCall map[int]struct {
		result1 *openapi.GetSourceResponse
		result2 *http.Response
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSourcesApi) CreateSource(arg1 context.Context, arg2 string, arg3 string) openapi.ApiCreateSourceRequest {
	fake.createSourceMutex.Lock()
	ret, specificReturn := fake.createSourceReturnsOnCall[len(fake.createSourceArgsForCall)]
	fake.createSourceArgsForCall = append(fake.createSourceArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.CreateSourceStub
	fakeReturns := fake.createSourceReturns
	fake.recordInvocation("CreateSource", []interface{}{arg1, arg2, arg3})
	fake.createSourceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSourcesApi) CreateSourceCallCount() int {
	fake.createSourceMutex.RLock()
	defer fake.createSourceMutex.RUnlock()
	return len(fake.createSourceArgsForCall)
}

func (fake *FakeSourcesApi) CreateSourceCalls(stub func(context.Context, string, string) openapi.ApiCreateSourceRequest) {
	fake.createSourceMutex.Lock()
	defer fake.createSourceMutex.Unlock()
	fake.CreateSourceStub = stub
}

func (fake *FakeSourcesApi) CreateSourceArgsForCall(i int) (context.Context, string, string) {
	fake.createSourceMutex.RLock()
	defer fake.createSourceMutex.RUnlock()
	argsForCall := fake.createSourceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeSourcesApi) CreateSourceReturns(result1 openapi.ApiCreateSourceRequest) {
	fake.createSourceMutex.Lock()
	defer fake.createSourceMutex.Unlock()
	fake.CreateSourceStub = nil
	fake.createSourceReturns = struct {
		result1 openapi.ApiCreateSourceRequest
	}{result1}
}

func (fake *FakeSourcesApi) CreateSourceReturnsOnCall(i int, result1 openapi.ApiCreateSourceRequest) {
	fake.createSourceMutex.Lock()
	defer fake.createSourceMutex.Unlock()
	fake.CreateSourceStub = nil
	if fake.createSourceReturnsOnCall == nil {
		fake.createSourceReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiCreateSourceRequest
		})
	}
	fake.createSourceReturnsOnCall[i] = struct {
		result1 openapi.ApiCreateSourceRequest
	}{result1}
}

func (fake *FakeSourcesApi) CreateSourceExecute(arg1 openapi.ApiCreateSourceRequest) (*openapi.GetSourceResponse, *http.Response, error) {
	fake.createSourceExecuteMutex.Lock()
	ret, specificReturn := fake.createSourceExecuteReturnsOnCall[len(fake.createSourceExecuteArgsForCall)]
	fake.createSourceExecuteArgsForCall = append(fake.createSourceExecuteArgsForCall, struct {
		arg1 openapi.ApiCreateSourceRequest
	}{arg1})
	stub := fake.CreateSourceExecuteStub
	fakeReturns := fake.createSourceExecuteReturns
	fake.recordInvocation("CreateSourceExecute", []interface{}{arg1})
	fake.createSourceExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeSourcesApi) CreateSourceExecuteCallCount() int {
	fake.createSourceExecuteMutex.RLock()
	defer fake.createSourceExecuteMutex.RUnlock()
	return len(fake.createSourceExecuteArgsForCall)
}

func (fake *FakeSourcesApi) CreateSourceExecuteCalls(stub func(openapi.ApiCreateSourceRequest) (*openapi.GetSourceResponse, *http.Response, error)) {
	fake.createSourceExecuteMutex.Lock()
	defer fake.createSourceExecuteMutex.Unlock()
	fake.CreateSourceExecuteStub = stub
}

func (fake *FakeSourcesApi) CreateSourceExecuteArgsForCall(i int) openapi.ApiCreateSourceRequest {
	fake.createSourceExecuteMutex.RLock()
	defer fake.createSourceExecuteMutex.RUnlock()
	argsForCall := fake.createSourceExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSourcesApi) CreateSourceExecuteReturns(result1 *openapi.GetSourceResponse, result2 *http.Response, result3 error) {
	fake.createSourceExecuteMutex.Lock()
	defer fake.createSourceExecuteMutex.Unlock()
	fake.CreateSourceExecuteStub = nil
	fake.createSourceExecuteReturns = struct {
		result1 *openapi.GetSourceResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSourcesApi) CreateSourceExecuteReturnsOnCall(i int, result1 *openapi.GetSourceResponse, result2 *http.Response, result3 error) {
	fake.createSourceExecuteMutex.Lock()
	defer fake.createSourceExecuteMutex.Unlock()
	fake.CreateSourceExecuteStub = nil
	if fake.createSourceExecuteReturnsOnCall == nil {
		fake.createSourceExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.GetSourceResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.createSourceExecuteReturnsOnCall[i] = struct {
		result1 *openapi.GetSourceResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSourcesApi) DeleteSource(arg1 context.Context, arg2 string, arg3 string, arg4 string) openapi.ApiDeleteSourceRequest {
	fake.deleteSourceMutex.Lock()
	ret, specificReturn := fake.deleteSourceReturnsOnCall[len(fake.deleteSourceArgsForCall)]
	fake.deleteSourceArgsForCall = append(fake.deleteSourceArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.DeleteSourceStub
	fakeReturns := fake.deleteSourceReturns
	fake.recordInvocation("DeleteSource", []interface{}{arg1, arg2, arg3, arg4})
	fake.deleteSourceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSourcesApi) DeleteSourceCallCount() int {
	fake.deleteSourceMutex.RLock()
	defer fake.deleteSourceMutex.RUnlock()
	return len(fake.deleteSourceArgsForCall)
}

func (fake *FakeSourcesApi) DeleteSourceCalls(stub func(context.Context, string, string, string) openapi.ApiDeleteSourceRequest) {
	fake.deleteSourceMutex.Lock()
	defer fake.deleteSourceMutex.Unlock()
	fake.DeleteSourceStub = stub
}

func (fake *FakeSourcesApi) DeleteSourceArgsForCall(i int) (context.Context, string, string, string) {
	fake.deleteSourceMutex.RLock()
	defer fake.deleteSourceMutex.RUnlock()
	argsForCall := fake.deleteSourceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeSourcesApi) DeleteSourceReturns(result1 openapi.ApiDeleteSourceRequest) {
	fake.deleteSourceMutex.Lock()
	defer fake.deleteSourceMutex.Unlock()
	fake.DeleteSourceStub = nil
	fake.deleteSourceReturns = struct {
		result1 openapi.ApiDeleteSourceRequest
	}{result1}
}

func (fake *FakeSourcesApi) DeleteSourceReturnsOnCall(i int, result1 openapi.ApiDeleteSourceRequest) {
	fake.deleteSourceMutex.Lock()
	defer fake.deleteSourceMutex.Unlock()
	fake.DeleteSourceStub = nil
	if fake.deleteSourceReturnsOnCall == nil {
		fake.deleteSourceReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiDeleteSourceRequest
		})
	}
	fake.deleteSourceReturnsOnCall[i] = struct {
		result1 openapi.ApiDeleteSourceRequest
	}{result1}
}

func (fake *FakeSourcesApi) DeleteSourceExecute(arg1 openapi.ApiDeleteSourceRequest) (*openapi.DeleteSourceResponse, *http.Response, error) {
	fake.deleteSourceExecuteMutex.Lock()
	ret, specificReturn := fake.deleteSourceExecuteReturnsOnCall[len(fake.deleteSourceExecuteArgsForCall)]
	fake.deleteSourceExecuteArgsForCall = append(fake.deleteSourceExecuteArgsForCall, struct {
		arg1 openapi.ApiDeleteSourceRequest
	}{arg1})
	stub := fake.DeleteSourceExecuteStub
	fakeReturns := fake.deleteSourceExecuteReturns
	fake.recordInvocation("DeleteSourceExecute", []interface{}{arg1})
	fake.deleteSourceExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeSourcesApi) DeleteSourceExecuteCallCount() int {
	fake.deleteSourceExecuteMutex.RLock()
	defer fake.deleteSourceExecuteMutex.RUnlock()
	return len(fake.deleteSourceExecuteArgsForCall)
}

func (fake *FakeSourcesApi) DeleteSourceExecuteCalls(stub func(openapi.ApiDeleteSourceRequest) (*openapi.DeleteSourceResponse, *http.Response, error)) {
	fake.deleteSourceExecuteMutex.Lock()
	defer fake.deleteSourceExecuteMutex.Unlock()
	fake.DeleteSourceExecuteStub = stub
}

func (fake *FakeSourcesApi) DeleteSourceExecuteArgsForCall(i int) openapi.ApiDeleteSourceRequest {
	fake.deleteSourceExecuteMutex.RLock()
	defer fake.deleteSourceExecuteMutex.RUnlock()
	argsForCall := fake.deleteSourceExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSourcesApi) DeleteSourceExecuteReturns(result1 *openapi.DeleteSourceResponse, result2 *http.Response, result3 error) {
	fake.deleteSourceExecuteMutex.Lock()
	defer fake.deleteSourceExecuteMutex.Unlock()
	fake.DeleteSourceExecuteStub = nil
	fake.deleteSourceExecuteReturns = struct {
		result1 *openapi.DeleteSourceResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSourcesApi) DeleteSourceExecuteReturnsOnCall(i int, result1 *openapi.DeleteSourceResponse, result2 *http.Response, result3 error) {
	fake.deleteSourceExecuteMutex.Lock()
	defer fake.deleteSourceExecuteMutex.Unlock()
	fake.DeleteSourceExecuteStub = nil
	if fake.deleteSourceExecuteReturnsOnCall == nil {
		fake.deleteSourceExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.DeleteSourceResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.deleteSourceExecuteReturnsOnCall[i] = struct {
		result1 *openapi.DeleteSourceResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSourcesApi) GetSource(arg1 context.Context, arg2 string, arg3 string, arg4 string) openapi.ApiGetSourceRequest {
	fake.getSourceMutex.Lock()
	ret, specificReturn := fake.getSourceReturnsOnCall[len(fake.getSourceArgsForCall)]
	fake.getSourceArgsForCall = append(fake.getSourceArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetSourceStub
	fakeReturns := fake.getSourceReturns
	fake.recordInvocation("GetSource", []interface{}{arg1, arg2, arg3, arg4})
	fake.getSourceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSourcesApi) GetSourceCallCount() int {
	fake.getSourceMutex.RLock()
	defer fake.getSourceMutex.RUnlock()
	return len(fake.getSourceArgsForCall)
}

func (fake *FakeSourcesApi) GetSourceCalls(stub func(context.Context, string, string, string) openapi.ApiGetSourceRequest) {
	fake.getSourceMutex.Lock()
	defer fake.getSourceMutex.Unlock()
	fake.GetSourceStub = stub
}

func (fake *FakeSourcesApi) GetSourceArgsForCall(i int) (context.Context, string, string, string) {
	fake.getSourceMutex.RLock()
	defer fake.getSourceMutex.RUnlock()
	argsForCall := fake.getSourceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeSourcesApi) GetSourceReturns(result1 openapi.ApiGetSourceRequest) {
	fake.getSourceMutex.Lock()
	defer fake.getSourceMutex.Unlock()
	fake.GetSourceStub = nil
	fake.getSourceReturns = struct {
		result1 openapi.ApiGetSourceRequest
	}{result1}
}

func (fake *FakeSourcesApi) GetSourceReturnsOnCall(i int, result1 openapi.ApiGetSourceRequest) {
	fake.getSourceMutex.Lock()
	defer fake.getSourceMutex.Unlock()
	fake.GetSourceStub = nil
	if fake.getSourceReturnsOnCall == nil {
		fake.getSourceReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiGetSourceRequest
		})
	}
	fake.getSourceReturnsOnCall[i] = struct {
		result1 openapi.ApiGetSourceRequest
	}{result1}
}

func (fake *FakeSourcesApi) GetSourceExecute(arg1 openapi.ApiGetSourceRequest) (*openapi.GetSourceResponse, *http.Response, error) {
	fake.getSourceExecuteMutex.Lock()
	ret, specificReturn := fake.getSourceExecuteReturnsOnCall[len(fake.getSourceExecuteArgsForCall)]
	fake.getSourceExecuteArgsForCall = append(fake.getSourceExecuteArgsForCall, struct {
		arg1 openapi.ApiGetSourceRequest
	}{arg1})
	stub := fake.GetSourceExecuteStub
	fakeReturns := fake.getSourceExecuteReturns
	fake.recordInvocation("GetSourceExecute", []interface{}{arg1})
	fake.getSourceExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeSourcesApi) GetSourceExecuteCallCount() int {
	fake.getSourceExecuteMutex.RLock()
	defer fake.getSourceExecuteMutex.RUnlock()
	return len(fake.getSourceExecuteArgsForCall)
}

func (fake *FakeSourcesApi) GetSourceExecuteCalls(stub func(openapi.ApiGetSourceRequest) (*openapi.GetSourceResponse, *http.Response, error)) {
	fake.getSourceExecuteMutex.Lock()
	defer fake.getSourceExecuteMutex.Unlock()
	fake.GetSourceExecuteStub = stub
}

func (fake *FakeSourcesApi) GetSourceExecuteArgsForCall(i int) openapi.ApiGetSourceRequest {
	fake.getSourceExecuteMutex.RLock()
	defer fake.getSourceExecuteMutex.RUnlock()
	argsForCall := fake.getSourceExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSourcesApi) GetSourceExecuteReturns(result1 *openapi.GetSourceResponse, result2 *http.Response, result3 error) {
	fake.getSourceExecuteMutex.Lock()
	defer fake.getSourceExecuteMutex.Unlock()
	fake.GetSourceExecuteStub = nil
	fake.getSourceExecuteReturns = struct {
		result1 *openapi.GetSourceResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSourcesApi) GetSourceExecuteReturnsOnCall(i int, result1 *openapi.GetSourceResponse, result2 *http.Response, result3 error) {
	fake.getSourceExecuteMutex.Lock()
	defer fake.getSourceExecuteMutex.Unlock()
	fake.GetSourceExecuteStub = nil
	if fake.getSourceExecuteReturnsOnCall == nil {
		fake.getSourceExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.GetSourceResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.getSourceExecuteReturnsOnCall[i] = struct {
		result1 *openapi.GetSourceResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSourcesApi) ListCollectionSources(arg1 context.Context, arg2 string, arg3 string) openapi.ApiListCollectionSourcesRequest {
	fake.listCollectionSourcesMutex.Lock()
	ret, specificReturn := fake.listCollectionSourcesReturnsOnCall[len(fake.listCollectionSourcesArgsForCall)]
	fake.listCollectionSourcesArgsForCall = append(fake.listCollectionSourcesArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ListCollectionSourcesStub
	fakeReturns := fake.listCollectionSourcesReturns
	fake.recordInvocation("ListCollectionSources", []interface{}{arg1, arg2, arg3})
	fake.listCollectionSourcesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSourcesApi) ListCollectionSourcesCallCount() int {
	fake.listCollectionSourcesMutex.RLock()
	defer fake.listCollectionSourcesMutex.RUnlock()
	return len(fake.listCollectionSourcesArgsForCall)
}

func (fake *FakeSourcesApi) ListCollectionSourcesCalls(stub func(context.Context, string, string) openapi.ApiListCollectionSourcesRequest) {
	fake.listCollectionSourcesMutex.Lock()
	defer fake.listCollectionSourcesMutex.Unlock()
	fake.ListCollectionSourcesStub = stub
}

func (fake *FakeSourcesApi) ListCollectionSourcesArgsForCall(i int) (context.Context, string, string) {
	fake.listCollectionSourcesMutex.RLock()
	defer fake.listCollectionSourcesMutex.RUnlock()
	argsForCall := fake.listCollectionSourcesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeSourcesApi) ListCollectionSourcesReturns(result1 openapi.ApiListCollectionSourcesRequest) {
	fake.listCollectionSourcesMutex.Lock()
	defer fake.listCollectionSourcesMutex.Unlock()
	fake.ListCollectionSourcesStub = nil
	fake.listCollectionSourcesReturns = struct {
		result1 openapi.ApiListCollectionSourcesRequest
	}{result1}
}

func (fake *FakeSourcesApi) ListCollectionSourcesReturnsOnCall(i int, result1 openapi.ApiListCollectionSourcesRequest) {
	fake.listCollectionSourcesMutex.Lock()
	defer fake.listCollectionSourcesMutex.Unlock()
	fake.ListCollectionSourcesStub = nil
	if fake.listCollectionSourcesReturnsOnCall == nil {
		fake.listCollectionSourcesReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiListCollectionSourcesRequest
		})
	}
	fake.listCollectionSourcesReturnsOnCall[i] = struct {
		result1 openapi.ApiListCollectionSourcesRequest
	}{result1}
}

func (fake *FakeSourcesApi) ListCollectionSourcesExecute(arg1 openapi.ApiListCollectionSourcesRequest) (*openapi.ListSourcesResponse, *http.Response, error) {
	fake.listCollectionSourcesExecuteMutex.Lock()
	ret, specificReturn := fake.listCollectionSourcesExecuteReturnsOnCall[len(fake.listCollectionSourcesExecuteArgsForCall)]
	fake.listCollectionSourcesExecuteArgsForCall = append(fake.listCollectionSourcesExecuteArgsForCall, struct {
		arg1 openapi.ApiListCollectionSourcesRequest
	}{arg1})
	stub := fake.ListCollectionSourcesExecuteStub
	fakeReturns := fake.listCollectionSourcesExecuteReturns
	fake.recordInvocation("ListCollectionSourcesExecute", []interface{}{arg1})
	fake.listCollectionSourcesExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeSourcesApi) ListCollectionSourcesExecuteCallCount() int {
	fake.listCollectionSourcesExecuteMutex.RLock()
	defer fake.listCollectionSourcesExecuteMutex.RUnlock()
	return len(fake.listCollectionSourcesExecuteArgsForCall)
}

func (fake *FakeSourcesApi) ListCollectionSourcesExecuteCalls(stub func(openapi.ApiListCollectionSourcesRequest) (*openapi.ListSourcesResponse, *http.Response, error)) {
	fake.listCollectionSourcesExecuteMutex.Lock()
	defer fake.listCollectionSourcesExecuteMutex.Unlock()
	fake.ListCollectionSourcesExecuteStub = stub
}

func (fake *FakeSourcesApi) ListCollectionSourcesExecuteArgsForCall(i int) openapi.ApiListCollectionSourcesRequest {
	fake.listCollectionSourcesExecuteMutex.RLock()
	defer fake.listCollectionSourcesExecuteMutex.RUnlock()
	argsForCall := fake.listCollectionSourcesExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSourcesApi) ListCollectionSourcesExecuteReturns(result1 *openapi.ListSourcesResponse, result2 *http.Response, result3 error) {
	fake.listCollectionSourcesExecuteMutex.Lock()
	defer fake.listCollectionSourcesExecuteMutex.Unlock()
	fake.ListCollectionSourcesExecuteStub = nil
	fake.listCollectionSourcesExecuteReturns = struct {
		result1 *openapi.ListSourcesResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSourcesApi) ListCollectionSourcesExecuteReturnsOnCall(i int, result1 *openapi.ListSourcesResponse, result2 *http.Response, result3 error) {
	fake.listCollectionSourcesExecuteMutex.Lock()
	defer fake.listCollectionSourcesExecuteMutex.Unlock()
	fake.ListCollectionSourcesExecuteStub = nil
	if fake.listCollectionSourcesExecuteReturnsOnCall == nil {
		fake.listCollectionSourcesExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.ListSourcesResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.listCollectionSourcesExecuteReturnsOnCall[i] = struct {
		result1 *openapi.ListSourcesResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSourcesApi) ResumeSource(arg1 context.Context, arg2 string, arg3 string, arg4 string) openapi.ApiResumeSourceRequest {
	fake.resumeSourceMutex.Lock()
	ret, specificReturn := fake.resumeSourceReturnsOnCall[len(fake.resumeSourceArgsForCall)]
	fake.resumeSourceArgsForCall = append(fake.resumeSourceArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.ResumeSourceStub
	fakeReturns := fake.resumeSourceReturns
	fake.recordInvocation("ResumeSource", []interface{}{arg1, arg2, arg3, arg4})
	fake.resumeSourceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSourcesApi) ResumeSourceCallCount() int {
	fake.resumeSourceMutex.RLock()
	defer fake.resumeSourceMutex.RUnlock()
	return len(fake.resumeSourceArgsForCall)
}

func (fake *FakeSourcesApi) ResumeSourceCalls(stub func(context.Context, string, string, string) openapi.ApiResumeSourceRequest) {
	fake.resumeSourceMutex.Lock()
	defer fake.resumeSourceMutex.Unlock()
	fake.ResumeSourceStub = stub
}

func (fake *FakeSourcesApi) ResumeSourceArgsForCall(i int) (context.Context, string, string, string) {
	fake.resumeSourceMutex.RLock()
	defer fake.resumeSourceMutex.RUnlock()
	argsForCall := fake.resumeSourceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeSourcesApi) ResumeSourceReturns(result1 openapi.ApiResumeSourceRequest) {
	fake.resumeSourceMutex.Lock()
	defer fake.resumeSourceMutex.Unlock()
	fake.ResumeSourceStub = nil
	fake.resumeSourceReturns = struct {
		result1 openapi.ApiResumeSourceRequest
	}{result1}
}

func (fake *FakeSourcesApi) ResumeSourceReturnsOnCall(i int, result1 openapi.ApiResumeSourceRequest) {
	fake.resumeSourceMutex.Lock()
	defer fake.resumeSourceMutex.Unlock()
	fake.ResumeSourceStub = nil
	if fake.resumeSourceReturnsOnCall == nil {
		fake.resumeSourceReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiResumeSourceRequest
		})
	}
	fake.resumeSourceReturnsOnCall[i] = struct {
		result1 openapi.ApiResumeSourceRequest
	}{result1}
}

func (fake *FakeSourcesApi) ResumeSourceExecute(arg1 openapi.ApiResumeSourceRequest) (*openapi.GetSourceResponse, *http.Response, error) {
	fake.resumeSourceExecuteMutex.Lock()
	ret, specificReturn := fake.resumeSourceExecuteReturnsOnCall[len(fake.resumeSourceExecuteArgsForCall)]
	fake.resumeSourceExecuteArgsForCall = append(fake.resumeSourceExecuteArgsForCall, struct {
		arg1 openapi.ApiResumeSourceRequest
	}{arg1})
	stub := fake.ResumeSourceExecuteStub
	fakeReturns := fake.resumeSourceExecuteReturns
	fake.recordInvocation("ResumeSourceExecute", []interface{}{arg1})
	fake.resumeSourceExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeSourcesApi) ResumeSourceExecuteCallCount() int {
	fake.resumeSourceExecuteMutex.RLock()
	defer fake.resumeSourceExecuteMutex.RUnlock()
	return len(fake.resumeSourceExecuteArgsForCall)
}

func (fake *FakeSourcesApi) ResumeSourceExecuteCalls(stub func(openapi.ApiResumeSourceRequest) (*openapi.GetSourceResponse, *http.Response, error)) {
	fake.resumeSourceExecuteMutex.Lock()
	defer fake.resumeSourceExecuteMutex.Unlock()
	fake.ResumeSourceExecuteStub = stub
}

func (fake *FakeSourcesApi) ResumeSourceExecuteArgsForCall(i int) openapi.ApiResumeSourceRequest {
	fake.resumeSourceExecuteMutex.RLock()
	defer fake.resumeSourceExecuteMutex.RUnlock()
	argsForCall := fake.resumeSourceExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSourcesApi) ResumeSourceExecuteReturns(result1 *openapi.GetSourceResponse, result2 *http.Response, result3 error) {
	fake.resumeSourceExecuteMutex.Lock()
	defer fake.resumeSourceExecuteMutex.Unlock()
	fake.ResumeSourceExecuteStub = nil
	fake.resumeSourceExecuteReturns = struct {
		result1 *openapi.GetSourceResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSourcesApi) ResumeSourceExecuteReturnsOnCall(i int, result1 *openapi.GetSourceResponse, result2 *http.Response, result3 error) {
	fake.resumeSourceExecuteMutex.Lock()
	defer fake.resumeSourceExecuteMutex.Unlock()
	fake.ResumeSourceExecuteStub = nil
	if fake.resumeSourceExecuteReturnsOnCall == nil {
		fake.resumeSourceExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.GetSourceResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.resumeSourceExecuteReturnsOnCall[i] = struct {
		result1 *openapi.GetSourceResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSourcesApi) SuspendSource(arg1 context.Context, arg2 string, arg3 string, arg4 string) openapi.ApiSuspendSourceRequest {
	fake.suspendSourceMutex.Lock()
	ret, specificReturn := fake.suspendSourceReturnsOnCall[len(fake.suspendSourceArgsForCall)]
	fake.suspendSourceArgsForCall = append(fake.suspendSourceArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.SuspendSourceStub
	fakeReturns := fake.suspendSourceReturns
	fake.recordInvocation("SuspendSource", []interface{}{arg1, arg2, arg3, arg4})
	fake.suspendSourceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSourcesApi) SuspendSourceCallCount() int {
	fake.suspendSourceMutex.RLock()
	defer fake.suspendSourceMutex.RUnlock()
	return len(fake.suspendSourceArgsForCall)
}

func (fake *FakeSourcesApi) SuspendSourceCalls(stub func(context.Context, string, string, string) openapi.ApiSuspendSourceRequest) {
	fake.suspendSourceMutex.Lock()
	defer fake.suspendSourceMutex.Unlock()
	fake.SuspendSourceStub = stub
}

func (fake *FakeSourcesApi) SuspendSourceArgsForCall(i int) (context.Context, string, string, string) {
	fake.suspendSourceMutex.RLock()
	defer fake.suspendSourceMutex.RUnlock()
	argsForCall := fake.suspendSourceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeSourcesApi) SuspendSourceReturns(result1 openapi.ApiSuspendSourceRequest) {
	fake.suspendSourceMutex.Lock()
	defer fake.suspendSourceMutex.Unlock()
	fake.SuspendSourceStub = nil
	fake.suspendSourceReturns = struct {
		result1 openapi.ApiSuspendSourceRequest
	}{result1}
}

func (fake *FakeSourcesApi) SuspendSourceReturnsOnCall(i int, result1 openapi.ApiSuspendSourceRequest) {
	fake.suspendSourceMutex.Lock()
	defer fake.suspendSourceMutex.Unlock()
	fake.SuspendSourceStub = nil
	if fake.suspendSourceReturnsOnCall == nil {
		fake.suspendSourceReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiSuspendSourceRequest
		})
	}
	fake.suspendSourceReturnsOnCall[i] = struct {
		result1 openapi.ApiSuspendSourceRequest
	}{result1}
}

func (fake *FakeSourcesApi) SuspendSourceExecute(arg1 openapi.ApiSuspendSourceRequest) (*openapi.GetSourceResponse, *http.Response, error) {
	fake.suspendSourceExecuteMutex.Lock()
	ret, specificReturn := fake.suspendSourceExecuteReturnsOnCall[len(fake.suspendSourceExecuteArgsForCall)]
	fake.suspendSourceExecuteArgsForCall = append(fake.suspendSourceExecuteArgsForCall, struct {
		arg1 openapi.ApiSuspendSourceRequest
	}{arg1})
	stub := fake.SuspendSourceExecuteStub
	fakeReturns := fake.suspendSourceExecuteReturns
	fake.recordInvocation("SuspendSourceExecute", []interface{}{arg1})
	fake.suspendSourceExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeSourcesApi) SuspendSourceExecuteCallCount() int {
	fake.suspendSourceExecuteMutex.RLock()
	defer fake.suspendSourceExecuteMutex.RUnlock()
	return len(fake.suspendSourceExecuteArgsForCall)
}

func (fake *FakeSourcesApi) SuspendSourceExecuteCalls(stub func(openapi.ApiSuspendSourceRequest) (*openapi.GetSourceResponse, *http.Response, error)) {
	fake.suspendSourceExecuteMutex.Lock()
	defer fake.suspendSourceExecuteMutex.Unlock()
	fake.SuspendSourceExecuteStub = stub
}

func (fake *FakeSourcesApi) SuspendSourceExecuteArgsForCall(i int) openapi.ApiSuspendSourceRequest {
	fake.suspendSourceExecuteMutex.RLock()
	defer fake.suspendSourceExecuteMutex.RUnlock()
	argsForCall := fake.suspendSourceExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSourcesApi) SuspendSourceExecuteReturns(result1 *openapi.GetSourceResponse, result2 *http.Response, result3 error) {
	fake.suspendSourceExecuteMutex.Lock()
	defer fake.suspendSourceExecuteMutex.Unlock()
	fake.SuspendSourceExecuteStub = nil
	fake.suspendSourceExecuteReturns = struct {
		result1 *openapi.GetSourceResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSourcesApi) SuspendSourceExecuteReturnsOnCall(i int, result1 *openapi.GetSourceResponse, result2 *http.Response, result3 error) {
	fake.suspendSourceExecuteMutex.Lock()
	defer fake.suspendSourceExecuteMutex.Unlock()
	fake.SuspendSourceExecuteStub = nil
	if fake.suspendSourceExecuteReturnsOnCall == nil {
		fake.suspendSourceExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.GetSourceResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.suspendSourceExecuteReturnsOnCall[i] = struct {
		result1 *openapi.GetSourceResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSourcesApi) UpdateSource(arg1 context.Context, arg2 string, arg3 string, arg4 string) openapi.ApiUpdateSourceRequest {
	fake.updateSourceMutex.Lock()
	ret, specificReturn := fake.updateSourceReturnsOnCall[len(fake.updateSourceArgsForCall)]
	fake.updateSourceArgsForCall = append(fake.updateSourceArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.UpdateSourceStub
	fakeReturns := fake.updateSourceReturns
	fake.recordInvocation("UpdateSource", []interface{}{arg1, arg2, arg3, arg4})
	fake.updateSourceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSourcesApi) UpdateSourceCallCount() int {
	fake.updateSourceMutex.RLock()
	defer fake.updateSourceMutex.RUnlock()
	return len(fake.updateSourceArgsForCall)
}

func (fake *FakeSourcesApi) UpdateSourceCalls(stub func(context.Context, string, string, string) openapi.ApiUpdateSourceRequest) {
	fake.updateSourceMutex.Lock()
	defer fake.updateSourceMutex.Unlock()
	fake.UpdateSourceStub = stub
}

func (fake *FakeSourcesApi) UpdateSourceArgsForCall(i int) (context.Context, string, string, string) {
	fake.updateSourceMutex.RLock()
	defer fake.updateSourceMutex.RUnlock()
	argsForCall := fake.updateSourceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeSourcesApi) UpdateSourceReturns(result1 openapi.ApiUpdateSourceRequest) {
	fake.updateSourceMutex.Lock()
	defer fake.updateSourceMutex.Unlock()
	fake.UpdateSourceStub = nil
	fake.updateSourceReturns = struct {
		result1 openapi.ApiUpdateSourceRequest
	}{result1}
}

func (fake *FakeSourcesApi) UpdateSourceReturnsOnCall(i int, result1 openapi.ApiUpdateSourceRequest) {
	fake.updateSourceMutex.Lock()
	defer fake.updateSourceMutex.Unlock()
	fake.UpdateSourceStub = nil
	if fake.updateSourceReturnsOnCall == nil {
		fake.updateSourceReturnsOnCall = make(map[int]struct {
			result1 openapi.ApiUpdateSourceRequest
		})
	}
	fake.updateSourceReturnsOnCall[i] = struct {
		result1 openapi.ApiUpdateSourceRequest
	}{result1}
}

func (fake *FakeSourcesApi) UpdateSourceExecute(arg1 openapi.ApiUpdateSourceRequest) (*openapi.GetSourceResponse, *http.Response, error) {
	fake.updateSourceExecuteMutex.Lock()
	ret, specificReturn := fake.updateSourceExecuteReturnsOnCall[len(fake.updateSourceExecuteArgsForCall)]
	fake.updateSourceExecuteArgsForCall = append(fake.updateSourceExecuteArgsForCall, struct {
		arg1 openapi.ApiUpdateSourceRequest
	}{arg1})
	stub := fake.UpdateSourceExecuteStub
	fakeReturns := fake.updateSourceExecuteReturns
	fake.recordInvocation("UpdateSourceExecute", []interface{}{arg1})
	fake.updateSourceExecuteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeSourcesApi) UpdateSourceExecuteCallCount() int {
	fake.updateSourceExecuteMutex.RLock()
	defer fake.updateSourceExecuteMutex.RUnlock()
	return len(fake.updateSourceExecuteArgsForCall)
}

func (fake *FakeSourcesApi) UpdateSourceExecuteCalls(stub func(openapi.ApiUpdateSourceRequest) (*openapi.GetSourceResponse, *http.Response, error)) {
	fake.updateSourceExecuteMutex.Lock()
	defer fake.updateSourceExecuteMutex.Unlock()
	fake.UpdateSourceExecuteStub = stub
}

func (fake *FakeSourcesApi) UpdateSourceExecuteArgsForCall(i int) openapi.ApiUpdateSourceRequest {
	fake.updateSourceExecuteMutex.RLock()
	defer fake.updateSourceExecuteMutex.RUnlock()
	argsForCall := fake.updateSourceExecuteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSourcesApi) UpdateSourceExecuteReturns(result1 *openapi.GetSourceResponse, result2 *http.Response, result3 error) {
	fake.updateSourceExecuteMutex.Lock()
	defer fake.updateSourceExecuteMutex.Unlock()
	fake.UpdateSourceExecuteStub = nil
	fake.updateSourceExecuteReturns = struct {
		result1 *openapi.GetSourceResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSourcesApi) UpdateSourceExecuteReturnsOnCall(i int, result1 *openapi.GetSourceResponse, result2 *http.Response, result3 error) {
	fake.updateSourceExecuteMutex.Lock()
	defer fake.updateSourceExecuteMutex.Unlock()
	fake.UpdateSourceExecuteStub = nil
	if fake.updateSourceExecuteReturnsOnCall == nil {
		fake.updateSourceExecuteReturnsOnCall = make(map[int]struct {
			result1 *openapi.GetSourceResponse
			result2 *http.Response
			result3 error
		})
	}
	fake.updateSourceExecuteReturnsOnCall[i] = struct {
		result1 *openapi.GetSourceResponse
		result2 *http.Response
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSourcesApi) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createSourceMutex.RLock()
	defer fake.createSourceMutex.RUnlock()
	fake.createSourceExecuteMutex.RLock()
	defer fake.createSourceExecuteMutex.RUnlock()
	fake.deleteSourceMutex.RLock()
	defer fake.deleteSourceMutex.RUnlock()
	fake.deleteSourceExecuteMutex.RLock()
	defer fake.deleteSourceExecuteMutex.RUnlock()
	fake.getSourceMutex.RLock()
	defer fake.getSourceMutex.RUnlock()
	fake.getSourceExecuteMutex.RLock()
	defer fake.getSourceExecuteMutex.RUnlock()
	fake.listCollectionSourcesMutex.RLock()
	defer fake.listCollectionSourcesMutex.RUnlock()
	fake.listCollectionSourcesExecuteMutex.RLock()
	defer fake.listCollectionSourcesExecuteMutex.RUnlock()
	fake.resumeSourceMutex.RLock()
	defer fake.resumeSourceMutex.RUnlock()
	fake.resumeSourceExecuteMutex.RLock()
	defer fake.resumeSourceExecuteMutex.RUnlock()
	fake.suspendSourceMutex.RLock()
	defer fake.suspendSourceMutex.RUnlock()
	fake.suspendSourceExecuteMutex.RLock()
	defer fake.suspendSourceExecuteMutex.RUnlock()
	fake.updateSourceMutex.RLock()
	defer fake.updateSourceMutex.RUnlock()
	fake.updateSourceExecuteMutex.RLock()
	defer fake.updateSourceExecuteMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeSourcesApi) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ openapi.SourcesApi = new(FakeSourcesApi)
